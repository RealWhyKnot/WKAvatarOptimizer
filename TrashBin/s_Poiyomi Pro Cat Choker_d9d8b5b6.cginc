#pragma warning (disable : 3557) // loop only executes for 1 iteration(s), forcing loop to unroll
#pragma warning (disable : 4008) // A floating point division by zero occurred.
#pragma warning (disable : 3554) // The attribute is unknown or invalid for the specified statement.
cbuffer WKVRCOptimizerAnimatedScalars
{
float WKVRCOptimizerAnimatedScalars[507] : packoffset(c0);
float _IsActiveMesh0 : packoffset(c0);
float _IsActiveMesh1 : packoffset(c1);
float _IsActiveMesh2 : packoffset(c2);
float _IsActiveMesh3 : packoffset(c3);
float _IsActiveMesh4 : packoffset(c4);
float _IsActiveMesh5 : packoffset(c5);
float _IsActiveMesh6 : packoffset(c6);
float _IsActiveMesh7 : packoffset(c7);
float _IsActiveMesh8 : packoffset(c8);
float _IsActiveMesh9 : packoffset(c9);
float _IsActiveMesh10 : packoffset(c10);
float _IsActiveMesh11 : packoffset(c11);
float _IsActiveMesh12 : packoffset(c12);
float _IsActiveMesh13 : packoffset(c13);
float _IsActiveMesh14 : packoffset(c14);
float _IsActiveMesh15 : packoffset(c15);
float _IsActiveMesh16 : packoffset(c16);
float _IsActiveMesh17 : packoffset(c17);
float _IsActiveMesh18 : packoffset(c18);
float _IsActiveMesh19 : packoffset(c19);
float _IsActiveMesh20 : packoffset(c20);
float _IsActiveMesh21 : packoffset(c21);
float _IsActiveMesh22 : packoffset(c22);
float _IsActiveMesh23 : packoffset(c23);
float _IsActiveMesh24 : packoffset(c24);
float _IsActiveMesh25 : packoffset(c25);
float _IsActiveMesh26 : packoffset(c26);
float _IsActiveMesh27 : packoffset(c27);
float _IsActiveMesh28 : packoffset(c28);
float _IsActiveMesh29 : packoffset(c29);
float _IsActiveMesh30 : packoffset(c30);
float _IsActiveMesh31 : packoffset(c31);
float _IsActiveMesh32 : packoffset(c32);
float _IsActiveMesh33 : packoffset(c33);
float _IsActiveMesh34 : packoffset(c34);
float _IsActiveMesh35 : packoffset(c35);
float _IsActiveMesh36 : packoffset(c36);
float _IsActiveMesh37 : packoffset(c37);
float _IsActiveMesh38 : packoffset(c38);
float WKVRCOptimizer_LightingCap_ArrayIndex0 : packoffset(c39);
float WKVRCOptimizer_LightingCap_ArrayIndex1 : packoffset(c40);
float WKVRCOptimizer_LightingCap_ArrayIndex2 : packoffset(c41);
float WKVRCOptimizer_LightingCap_ArrayIndex3 : packoffset(c42);
float WKVRCOptimizer_LightingCap_ArrayIndex4 : packoffset(c43);
float WKVRCOptimizer_LightingCap_ArrayIndex5 : packoffset(c44);
float WKVRCOptimizer_LightingCap_ArrayIndex6 : packoffset(c45);
float WKVRCOptimizer_LightingCap_ArrayIndex7 : packoffset(c46);
float WKVRCOptimizer_LightingCap_ArrayIndex8 : packoffset(c47);
float WKVRCOptimizer_LightingCap_ArrayIndex9 : packoffset(c48);
float WKVRCOptimizer_LightingCap_ArrayIndex10 : packoffset(c49);
float WKVRCOptimizer_LightingCap_ArrayIndex11 : packoffset(c50);
float WKVRCOptimizer_LightingCap_ArrayIndex12 : packoffset(c51);
float WKVRCOptimizer_LightingCap_ArrayIndex13 : packoffset(c52);
float WKVRCOptimizer_LightingCap_ArrayIndex14 : packoffset(c53);
float WKVRCOptimizer_LightingCap_ArrayIndex15 : packoffset(c54);
float WKVRCOptimizer_LightingCap_ArrayIndex16 : packoffset(c55);
float WKVRCOptimizer_LightingCap_ArrayIndex17 : packoffset(c56);
float WKVRCOptimizer_LightingCap_ArrayIndex18 : packoffset(c57);
float WKVRCOptimizer_LightingCap_ArrayIndex19 : packoffset(c58);
float WKVRCOptimizer_LightingCap_ArrayIndex20 : packoffset(c59);
float WKVRCOptimizer_LightingCap_ArrayIndex21 : packoffset(c60);
float WKVRCOptimizer_LightingCap_ArrayIndex22 : packoffset(c61);
float WKVRCOptimizer_LightingCap_ArrayIndex23 : packoffset(c62);
float WKVRCOptimizer_LightingCap_ArrayIndex24 : packoffset(c63);
float WKVRCOptimizer_LightingCap_ArrayIndex25 : packoffset(c64);
float WKVRCOptimizer_LightingCap_ArrayIndex26 : packoffset(c65);
float WKVRCOptimizer_LightingCap_ArrayIndex27 : packoffset(c66);
float WKVRCOptimizer_LightingCap_ArrayIndex28 : packoffset(c67);
float WKVRCOptimizer_LightingCap_ArrayIndex29 : packoffset(c68);
float WKVRCOptimizer_LightingCap_ArrayIndex30 : packoffset(c69);
float WKVRCOptimizer_LightingCap_ArrayIndex31 : packoffset(c70);
float WKVRCOptimizer_LightingCap_ArrayIndex32 : packoffset(c71);
float WKVRCOptimizer_LightingCap_ArrayIndex33 : packoffset(c72);
float WKVRCOptimizer_LightingCap_ArrayIndex34 : packoffset(c73);
float WKVRCOptimizer_LightingCap_ArrayIndex35 : packoffset(c74);
float WKVRCOptimizer_LightingCap_ArrayIndex36 : packoffset(c75);
float WKVRCOptimizer_LightingCap_ArrayIndex37 : packoffset(c76);
float WKVRCOptimizer_LightingCap_ArrayIndex38 : packoffset(c77);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex0 : packoffset(c78);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex1 : packoffset(c79);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex2 : packoffset(c80);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex3 : packoffset(c81);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex4 : packoffset(c82);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex5 : packoffset(c83);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex6 : packoffset(c84);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex7 : packoffset(c85);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex8 : packoffset(c86);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex9 : packoffset(c87);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex10 : packoffset(c88);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex11 : packoffset(c89);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex12 : packoffset(c90);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex13 : packoffset(c91);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex14 : packoffset(c92);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex15 : packoffset(c93);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex16 : packoffset(c94);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex17 : packoffset(c95);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex18 : packoffset(c96);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex19 : packoffset(c97);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex20 : packoffset(c98);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex21 : packoffset(c99);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex22 : packoffset(c100);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex23 : packoffset(c101);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex24 : packoffset(c102);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex25 : packoffset(c103);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex26 : packoffset(c104);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex27 : packoffset(c105);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex28 : packoffset(c106);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex29 : packoffset(c107);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex30 : packoffset(c108);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex31 : packoffset(c109);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex32 : packoffset(c110);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex33 : packoffset(c111);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex34 : packoffset(c112);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex35 : packoffset(c113);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex36 : packoffset(c114);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex37 : packoffset(c115);
float WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex38 : packoffset(c116);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex0 : packoffset(c117);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex1 : packoffset(c118);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex2 : packoffset(c119);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex3 : packoffset(c120);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex4 : packoffset(c121);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex5 : packoffset(c122);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex6 : packoffset(c123);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex7 : packoffset(c124);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex8 : packoffset(c125);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex9 : packoffset(c126);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex10 : packoffset(c127);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex11 : packoffset(c128);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex12 : packoffset(c129);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex13 : packoffset(c130);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex14 : packoffset(c131);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex15 : packoffset(c132);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex16 : packoffset(c133);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex17 : packoffset(c134);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex18 : packoffset(c135);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex19 : packoffset(c136);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex20 : packoffset(c137);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex21 : packoffset(c138);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex22 : packoffset(c139);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex23 : packoffset(c140);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex24 : packoffset(c141);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex25 : packoffset(c142);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex26 : packoffset(c143);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex27 : packoffset(c144);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex28 : packoffset(c145);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex29 : packoffset(c146);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex30 : packoffset(c147);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex31 : packoffset(c148);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex32 : packoffset(c149);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex33 : packoffset(c150);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex34 : packoffset(c151);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex35 : packoffset(c152);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex36 : packoffset(c153);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex37 : packoffset(c154);
float WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex38 : packoffset(c155);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex0 : packoffset(c156);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex1 : packoffset(c157);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex2 : packoffset(c158);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex3 : packoffset(c159);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex4 : packoffset(c160);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex5 : packoffset(c161);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex6 : packoffset(c162);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex7 : packoffset(c163);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex8 : packoffset(c164);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex9 : packoffset(c165);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex10 : packoffset(c166);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex11 : packoffset(c167);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex12 : packoffset(c168);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex13 : packoffset(c169);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex14 : packoffset(c170);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex15 : packoffset(c171);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex16 : packoffset(c172);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex17 : packoffset(c173);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex18 : packoffset(c174);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex19 : packoffset(c175);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex20 : packoffset(c176);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex21 : packoffset(c177);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex22 : packoffset(c178);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex23 : packoffset(c179);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex24 : packoffset(c180);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex25 : packoffset(c181);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex26 : packoffset(c182);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex27 : packoffset(c183);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex28 : packoffset(c184);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex29 : packoffset(c185);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex30 : packoffset(c186);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex31 : packoffset(c187);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex32 : packoffset(c188);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex33 : packoffset(c189);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex34 : packoffset(c190);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex35 : packoffset(c191);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex36 : packoffset(c192);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex37 : packoffset(c193);
float WKVRCOptimizer_LightingMonochromatic_ArrayIndex38 : packoffset(c194);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex0 : packoffset(c195);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex1 : packoffset(c196);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex2 : packoffset(c197);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex3 : packoffset(c198);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex4 : packoffset(c199);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex5 : packoffset(c200);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex6 : packoffset(c201);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex7 : packoffset(c202);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex8 : packoffset(c203);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex9 : packoffset(c204);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex10 : packoffset(c205);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex11 : packoffset(c206);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex12 : packoffset(c207);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex13 : packoffset(c208);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex14 : packoffset(c209);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex15 : packoffset(c210);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex16 : packoffset(c211);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex17 : packoffset(c212);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex18 : packoffset(c213);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex19 : packoffset(c214);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex20 : packoffset(c215);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex21 : packoffset(c216);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex22 : packoffset(c217);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex23 : packoffset(c218);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex24 : packoffset(c219);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex25 : packoffset(c220);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex26 : packoffset(c221);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex27 : packoffset(c222);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex28 : packoffset(c223);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex29 : packoffset(c224);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex30 : packoffset(c225);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex31 : packoffset(c226);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex32 : packoffset(c227);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex33 : packoffset(c228);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex34 : packoffset(c229);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex35 : packoffset(c230);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex36 : packoffset(c231);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex37 : packoffset(c232);
float WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex38 : packoffset(c233);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex0 : packoffset(c234);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex1 : packoffset(c235);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex2 : packoffset(c236);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex3 : packoffset(c237);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex4 : packoffset(c238);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex5 : packoffset(c239);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex6 : packoffset(c240);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex7 : packoffset(c241);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex8 : packoffset(c242);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex9 : packoffset(c243);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex10 : packoffset(c244);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex11 : packoffset(c245);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex12 : packoffset(c246);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex13 : packoffset(c247);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex14 : packoffset(c248);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex15 : packoffset(c249);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex16 : packoffset(c250);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex17 : packoffset(c251);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex18 : packoffset(c252);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex19 : packoffset(c253);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex20 : packoffset(c254);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex21 : packoffset(c255);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex22 : packoffset(c256);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex23 : packoffset(c257);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex24 : packoffset(c258);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex25 : packoffset(c259);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex26 : packoffset(c260);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex27 : packoffset(c261);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex28 : packoffset(c262);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex29 : packoffset(c263);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex30 : packoffset(c264);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex31 : packoffset(c265);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex32 : packoffset(c266);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex33 : packoffset(c267);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex34 : packoffset(c268);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex35 : packoffset(c269);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex36 : packoffset(c270);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex37 : packoffset(c271);
float WKVRCOptimizer_SSAOIntensity_ArrayIndex38 : packoffset(c272);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex0 : packoffset(c273);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex1 : packoffset(c274);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex2 : packoffset(c275);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex3 : packoffset(c276);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex4 : packoffset(c277);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex5 : packoffset(c278);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex6 : packoffset(c279);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex7 : packoffset(c280);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex8 : packoffset(c281);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex9 : packoffset(c282);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex10 : packoffset(c283);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex11 : packoffset(c284);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex12 : packoffset(c285);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex13 : packoffset(c286);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex14 : packoffset(c287);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex15 : packoffset(c288);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex16 : packoffset(c289);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex17 : packoffset(c290);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex18 : packoffset(c291);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex19 : packoffset(c292);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex20 : packoffset(c293);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex21 : packoffset(c294);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex22 : packoffset(c295);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex23 : packoffset(c296);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex24 : packoffset(c297);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex25 : packoffset(c298);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex26 : packoffset(c299);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex27 : packoffset(c300);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex28 : packoffset(c301);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex29 : packoffset(c302);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex30 : packoffset(c303);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex31 : packoffset(c304);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex32 : packoffset(c305);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex33 : packoffset(c306);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex34 : packoffset(c307);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex35 : packoffset(c308);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex36 : packoffset(c309);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex37 : packoffset(c310);
float WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex38 : packoffset(c311);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex0 : packoffset(c312);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex1 : packoffset(c313);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex2 : packoffset(c314);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex3 : packoffset(c315);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex4 : packoffset(c316);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex5 : packoffset(c317);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex6 : packoffset(c318);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex7 : packoffset(c319);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex8 : packoffset(c320);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex9 : packoffset(c321);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex10 : packoffset(c322);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex11 : packoffset(c323);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex12 : packoffset(c324);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex13 : packoffset(c325);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex14 : packoffset(c326);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex15 : packoffset(c327);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex16 : packoffset(c328);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex17 : packoffset(c329);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex18 : packoffset(c330);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex19 : packoffset(c331);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex20 : packoffset(c332);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex21 : packoffset(c333);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex22 : packoffset(c334);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex23 : packoffset(c335);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex24 : packoffset(c336);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex25 : packoffset(c337);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex26 : packoffset(c338);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex27 : packoffset(c339);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex28 : packoffset(c340);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex29 : packoffset(c341);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex30 : packoffset(c342);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex31 : packoffset(c343);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex32 : packoffset(c344);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex33 : packoffset(c345);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex34 : packoffset(c346);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex35 : packoffset(c347);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex36 : packoffset(c348);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex37 : packoffset(c349);
float WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex38 : packoffset(c350);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex0 : packoffset(c351);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex1 : packoffset(c352);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex2 : packoffset(c353);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex3 : packoffset(c354);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex4 : packoffset(c355);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex5 : packoffset(c356);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex6 : packoffset(c357);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex7 : packoffset(c358);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex8 : packoffset(c359);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex9 : packoffset(c360);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex10 : packoffset(c361);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex11 : packoffset(c362);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex12 : packoffset(c363);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex13 : packoffset(c364);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex14 : packoffset(c365);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex15 : packoffset(c366);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex16 : packoffset(c367);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex17 : packoffset(c368);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex18 : packoffset(c369);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex19 : packoffset(c370);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex20 : packoffset(c371);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex21 : packoffset(c372);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex22 : packoffset(c373);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex23 : packoffset(c374);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex24 : packoffset(c375);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex25 : packoffset(c376);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex26 : packoffset(c377);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex27 : packoffset(c378);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex28 : packoffset(c379);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex29 : packoffset(c380);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex30 : packoffset(c381);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex31 : packoffset(c382);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex32 : packoffset(c383);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex33 : packoffset(c384);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex34 : packoffset(c385);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex35 : packoffset(c386);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex36 : packoffset(c387);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex37 : packoffset(c388);
float WKVRCOptimizer_CubeMapHueShift_ArrayIndex38 : packoffset(c389);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex0 : packoffset(c390);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex1 : packoffset(c391);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex2 : packoffset(c392);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex3 : packoffset(c393);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex4 : packoffset(c394);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex5 : packoffset(c395);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex6 : packoffset(c396);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex7 : packoffset(c397);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex8 : packoffset(c398);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex9 : packoffset(c399);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex10 : packoffset(c400);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex11 : packoffset(c401);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex12 : packoffset(c402);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex13 : packoffset(c403);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex14 : packoffset(c404);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex15 : packoffset(c405);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex16 : packoffset(c406);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex17 : packoffset(c407);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex18 : packoffset(c408);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex19 : packoffset(c409);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex20 : packoffset(c410);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex21 : packoffset(c411);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex22 : packoffset(c412);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex23 : packoffset(c413);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex24 : packoffset(c414);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex25 : packoffset(c415);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex26 : packoffset(c416);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex27 : packoffset(c417);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex28 : packoffset(c418);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex29 : packoffset(c419);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex30 : packoffset(c420);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex31 : packoffset(c421);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex32 : packoffset(c422);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex33 : packoffset(c423);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex34 : packoffset(c424);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex35 : packoffset(c425);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex36 : packoffset(c426);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex37 : packoffset(c427);
float WKVRCOptimizer_DecalBlendAlpha_ArrayIndex38 : packoffset(c428);
float WKVRCOptimizer_MainHueShift_ArrayIndex0 : packoffset(c429);
float WKVRCOptimizer_MainHueShift_ArrayIndex1 : packoffset(c430);
float WKVRCOptimizer_MainHueShift_ArrayIndex2 : packoffset(c431);
float WKVRCOptimizer_MainHueShift_ArrayIndex3 : packoffset(c432);
float WKVRCOptimizer_MainHueShift_ArrayIndex4 : packoffset(c433);
float WKVRCOptimizer_MainHueShift_ArrayIndex5 : packoffset(c434);
float WKVRCOptimizer_MainHueShift_ArrayIndex6 : packoffset(c435);
float WKVRCOptimizer_MainHueShift_ArrayIndex7 : packoffset(c436);
float WKVRCOptimizer_MainHueShift_ArrayIndex8 : packoffset(c437);
float WKVRCOptimizer_MainHueShift_ArrayIndex9 : packoffset(c438);
float WKVRCOptimizer_MainHueShift_ArrayIndex10 : packoffset(c439);
float WKVRCOptimizer_MainHueShift_ArrayIndex11 : packoffset(c440);
float WKVRCOptimizer_MainHueShift_ArrayIndex12 : packoffset(c441);
float WKVRCOptimizer_MainHueShift_ArrayIndex13 : packoffset(c442);
float WKVRCOptimizer_MainHueShift_ArrayIndex14 : packoffset(c443);
float WKVRCOptimizer_MainHueShift_ArrayIndex15 : packoffset(c444);
float WKVRCOptimizer_MainHueShift_ArrayIndex16 : packoffset(c445);
float WKVRCOptimizer_MainHueShift_ArrayIndex17 : packoffset(c446);
float WKVRCOptimizer_MainHueShift_ArrayIndex18 : packoffset(c447);
float WKVRCOptimizer_MainHueShift_ArrayIndex19 : packoffset(c448);
float WKVRCOptimizer_MainHueShift_ArrayIndex20 : packoffset(c449);
float WKVRCOptimizer_MainHueShift_ArrayIndex21 : packoffset(c450);
float WKVRCOptimizer_MainHueShift_ArrayIndex22 : packoffset(c451);
float WKVRCOptimizer_MainHueShift_ArrayIndex23 : packoffset(c452);
float WKVRCOptimizer_MainHueShift_ArrayIndex24 : packoffset(c453);
float WKVRCOptimizer_MainHueShift_ArrayIndex25 : packoffset(c454);
float WKVRCOptimizer_MainHueShift_ArrayIndex26 : packoffset(c455);
float WKVRCOptimizer_MainHueShift_ArrayIndex27 : packoffset(c456);
float WKVRCOptimizer_MainHueShift_ArrayIndex28 : packoffset(c457);
float WKVRCOptimizer_MainHueShift_ArrayIndex29 : packoffset(c458);
float WKVRCOptimizer_MainHueShift_ArrayIndex30 : packoffset(c459);
float WKVRCOptimizer_MainHueShift_ArrayIndex31 : packoffset(c460);
float WKVRCOptimizer_MainHueShift_ArrayIndex32 : packoffset(c461);
float WKVRCOptimizer_MainHueShift_ArrayIndex33 : packoffset(c462);
float WKVRCOptimizer_MainHueShift_ArrayIndex34 : packoffset(c463);
float WKVRCOptimizer_MainHueShift_ArrayIndex35 : packoffset(c464);
float WKVRCOptimizer_MainHueShift_ArrayIndex36 : packoffset(c465);
float WKVRCOptimizer_MainHueShift_ArrayIndex37 : packoffset(c466);
float WKVRCOptimizer_MainHueShift_ArrayIndex38 : packoffset(c467);
float WKVRCOptimizer_Saturation_ArrayIndex0 : packoffset(c468);
float WKVRCOptimizer_Saturation_ArrayIndex1 : packoffset(c469);
float WKVRCOptimizer_Saturation_ArrayIndex2 : packoffset(c470);
float WKVRCOptimizer_Saturation_ArrayIndex3 : packoffset(c471);
float WKVRCOptimizer_Saturation_ArrayIndex4 : packoffset(c472);
float WKVRCOptimizer_Saturation_ArrayIndex5 : packoffset(c473);
float WKVRCOptimizer_Saturation_ArrayIndex6 : packoffset(c474);
float WKVRCOptimizer_Saturation_ArrayIndex7 : packoffset(c475);
float WKVRCOptimizer_Saturation_ArrayIndex8 : packoffset(c476);
float WKVRCOptimizer_Saturation_ArrayIndex9 : packoffset(c477);
float WKVRCOptimizer_Saturation_ArrayIndex10 : packoffset(c478);
float WKVRCOptimizer_Saturation_ArrayIndex11 : packoffset(c479);
float WKVRCOptimizer_Saturation_ArrayIndex12 : packoffset(c480);
float WKVRCOptimizer_Saturation_ArrayIndex13 : packoffset(c481);
float WKVRCOptimizer_Saturation_ArrayIndex14 : packoffset(c482);
float WKVRCOptimizer_Saturation_ArrayIndex15 : packoffset(c483);
float WKVRCOptimizer_Saturation_ArrayIndex16 : packoffset(c484);
float WKVRCOptimizer_Saturation_ArrayIndex17 : packoffset(c485);
float WKVRCOptimizer_Saturation_ArrayIndex18 : packoffset(c486);
float WKVRCOptimizer_Saturation_ArrayIndex19 : packoffset(c487);
float WKVRCOptimizer_Saturation_ArrayIndex20 : packoffset(c488);
float WKVRCOptimizer_Saturation_ArrayIndex21 : packoffset(c489);
float WKVRCOptimizer_Saturation_ArrayIndex22 : packoffset(c490);
float WKVRCOptimizer_Saturation_ArrayIndex23 : packoffset(c491);
float WKVRCOptimizer_Saturation_ArrayIndex24 : packoffset(c492);
float WKVRCOptimizer_Saturation_ArrayIndex25 : packoffset(c493);
float WKVRCOptimizer_Saturation_ArrayIndex26 : packoffset(c494);
float WKVRCOptimizer_Saturation_ArrayIndex27 : packoffset(c495);
float WKVRCOptimizer_Saturation_ArrayIndex28 : packoffset(c496);
float WKVRCOptimizer_Saturation_ArrayIndex29 : packoffset(c497);
float WKVRCOptimizer_Saturation_ArrayIndex30 : packoffset(c498);
float WKVRCOptimizer_Saturation_ArrayIndex31 : packoffset(c499);
float WKVRCOptimizer_Saturation_ArrayIndex32 : packoffset(c500);
float WKVRCOptimizer_Saturation_ArrayIndex33 : packoffset(c501);
float WKVRCOptimizer_Saturation_ArrayIndex34 : packoffset(c502);
float WKVRCOptimizer_Saturation_ArrayIndex35 : packoffset(c503);
float WKVRCOptimizer_Saturation_ArrayIndex36 : packoffset(c504);
float WKVRCOptimizer_Saturation_ArrayIndex37 : packoffset(c505);
float WKVRCOptimizer_Saturation_ArrayIndex38 : packoffset(c506);
};
cbuffer WKVRCOptimizerAnimatedVectors
{
float4 WKVRCOptimizerAnimatedVectors[78] : packoffset(c0);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex0 : packoffset(c0);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex1 : packoffset(c1);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex2 : packoffset(c2);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex3 : packoffset(c3);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex4 : packoffset(c4);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex5 : packoffset(c5);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex6 : packoffset(c6);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex7 : packoffset(c7);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex8 : packoffset(c8);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex9 : packoffset(c9);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex10 : packoffset(c10);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex11 : packoffset(c11);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex12 : packoffset(c12);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex13 : packoffset(c13);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex14 : packoffset(c14);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex15 : packoffset(c15);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex16 : packoffset(c16);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex17 : packoffset(c17);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex18 : packoffset(c18);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex19 : packoffset(c19);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex20 : packoffset(c20);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex21 : packoffset(c21);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex22 : packoffset(c22);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex23 : packoffset(c23);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex24 : packoffset(c24);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex25 : packoffset(c25);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex26 : packoffset(c26);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex27 : packoffset(c27);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex28 : packoffset(c28);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex29 : packoffset(c29);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex30 : packoffset(c30);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex31 : packoffset(c31);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex32 : packoffset(c32);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex33 : packoffset(c33);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex34 : packoffset(c34);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex35 : packoffset(c35);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex36 : packoffset(c36);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex37 : packoffset(c37);
float4 WKVRCOptimizer_CubeMapColor_ArrayIndex38 : packoffset(c38);
float4 WKVRCOptimizer_Color_ArrayIndex0 : packoffset(c39);
float4 WKVRCOptimizer_Color_ArrayIndex1 : packoffset(c40);
float4 WKVRCOptimizer_Color_ArrayIndex2 : packoffset(c41);
float4 WKVRCOptimizer_Color_ArrayIndex3 : packoffset(c42);
float4 WKVRCOptimizer_Color_ArrayIndex4 : packoffset(c43);
float4 WKVRCOptimizer_Color_ArrayIndex5 : packoffset(c44);
float4 WKVRCOptimizer_Color_ArrayIndex6 : packoffset(c45);
float4 WKVRCOptimizer_Color_ArrayIndex7 : packoffset(c46);
float4 WKVRCOptimizer_Color_ArrayIndex8 : packoffset(c47);
float4 WKVRCOptimizer_Color_ArrayIndex9 : packoffset(c48);
float4 WKVRCOptimizer_Color_ArrayIndex10 : packoffset(c49);
float4 WKVRCOptimizer_Color_ArrayIndex11 : packoffset(c50);
float4 WKVRCOptimizer_Color_ArrayIndex12 : packoffset(c51);
float4 WKVRCOptimizer_Color_ArrayIndex13 : packoffset(c52);
float4 WKVRCOptimizer_Color_ArrayIndex14 : packoffset(c53);
float4 WKVRCOptimizer_Color_ArrayIndex15 : packoffset(c54);
float4 WKVRCOptimizer_Color_ArrayIndex16 : packoffset(c55);
float4 WKVRCOptimizer_Color_ArrayIndex17 : packoffset(c56);
float4 WKVRCOptimizer_Color_ArrayIndex18 : packoffset(c57);
float4 WKVRCOptimizer_Color_ArrayIndex19 : packoffset(c58);
float4 WKVRCOptimizer_Color_ArrayIndex20 : packoffset(c59);
float4 WKVRCOptimizer_Color_ArrayIndex21 : packoffset(c60);
float4 WKVRCOptimizer_Color_ArrayIndex22 : packoffset(c61);
float4 WKVRCOptimizer_Color_ArrayIndex23 : packoffset(c62);
float4 WKVRCOptimizer_Color_ArrayIndex24 : packoffset(c63);
float4 WKVRCOptimizer_Color_ArrayIndex25 : packoffset(c64);
float4 WKVRCOptimizer_Color_ArrayIndex26 : packoffset(c65);
float4 WKVRCOptimizer_Color_ArrayIndex27 : packoffset(c66);
float4 WKVRCOptimizer_Color_ArrayIndex28 : packoffset(c67);
float4 WKVRCOptimizer_Color_ArrayIndex29 : packoffset(c68);
float4 WKVRCOptimizer_Color_ArrayIndex30 : packoffset(c69);
float4 WKVRCOptimizer_Color_ArrayIndex31 : packoffset(c70);
float4 WKVRCOptimizer_Color_ArrayIndex32 : packoffset(c71);
float4 WKVRCOptimizer_Color_ArrayIndex33 : packoffset(c72);
float4 WKVRCOptimizer_Color_ArrayIndex34 : packoffset(c73);
float4 WKVRCOptimizer_Color_ArrayIndex35 : packoffset(c74);
float4 WKVRCOptimizer_Color_ArrayIndex36 : packoffset(c75);
float4 WKVRCOptimizer_Color_ArrayIndex37 : packoffset(c76);
float4 WKVRCOptimizer_Color_ArrayIndex38 : packoffset(c77);
};
static float _LightingCap = 1;
static float _LightingAdditiveLimit = 1;
static float _LightingMinLightBrightness = 0;
static float _LightingMonochromatic = 0;
static float _LightingAdditiveMonochromatic = 0;
static float _SSAOIntensity = 0;
static float _LightingEnableLightVolumes = 1;
static float _SSAOAnimationToggle = 1;
static float4 _CubeMapColor = 0;
static float _CubeMapHueShift = 0;
static float _DecalBlendAlpha = 0;
static float _MainHueShift = 0;
static float _Saturation = 0;
static float4 _Color = 0;
static float shader_is_using_thry_editor = 0;
static float _Mode = 0;
static float m_mainCategory = 0;
static bool shouldSample_MainTex = 0;
static float4 _MainTex_TexelSize = 0;
static bool shouldSample_BumpMap = 0;
static float4 _BumpMap_TexelSize = 0;
static float4 _BumpMap_ST = 0;
static float _BumpScale = 0;
static bool shouldSample_AlphaMask = 0;
static float4 _AlphaMask_TexelSize = 0;
static float4 _AlphaMask_ST = 0;
static float _MainAlphaMaskMode = 0;
static float _Cutoff = 0;
static float _MainHueShiftToggle = 0;
static float _AlphaForceOpaque = 0;
static float m_start_DecalSection = 0;
static bool shouldSample_DecalMask = 0;
static float4 _DecalMask_TexelSize = 0;
static float4 _DecalColor = 0;
static bool shouldSample_DecalTexture = 0;
static float4 _DecalTexture_TexelSize = 0;
static float m_start_PoiShading = 0;
static float s_start_ShadingAddPass = 0;
static float m_start_matcap = 0;
static float _MatcapMultiply = 0;
static bool shouldSample_Matcap0NormalMap = 0;
static float4 _Matcap0NormalMap_TexelSize = 0;
static float _CubeMapBlendAmount = 0;
static bool shouldSample_CubeMapMask = 0;
static float4 _CubeMapMask_TexelSize = 0;
static float _CubeMapMaskInvert = 0;
static float m_start_rimLight1Options = 0;
static float _RimBlendStrength = 0;
static float _RimSharpness = 0;
static float m_start_brdf = 0;
static float _MochieMetallicMultiplier = 0;
static float _MochieRoughnessMultiplier = 0;
static float m_start_poiSSAO = 0;
static float m_specialFXCategory = 0;
static float m_vertexCategory = 0;
static float m_start_PoiGlobalCategory = 0;
static float m_start_PoiPostProcessingCategory = 0;
static float m_start_PPAnimations = 0;
static float m_renderingCategory = 0;
static float _Cull = 0;
static float _ZWrite = 0;
static float _RenderingEarlyZEnabled = 0;
static float _SrcBlend = 0;
static float _DstBlend = 0;
static float _AddSrcBlend = 0;
static float _BlendOpAlpha = 0;
static float _DstBlendAlpha = 0;
uniform float WKVRCOptimizer_Zero;
static uint WKVRCOptimizer_MaterialID = 0;
static uint WKVRCOptimizer_MeshID = 0;
static const float WKVRCOptimizerArray_Mode[33] = 
{
9,
9,
0,
9,
1,
0,
0,
0,
3,
0,
3,
0,
1,
1,
1,
2,
2,
1,
2,
9,
9,
9,
9,
9,
9,
9,
9,
3,
9,
9,
0,
1,
1,
};
static const float4 WKVRCOptimizerArray_Color[34] = 
{
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(0.1579265, 0, 0, 1),
float4(0.003686107, 0.003686107, 0.003686107, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(0, 0, 0, 0),
float4(1, 0.9404936, 0.8631573, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(0.2702231, 0.2702231, 0.2702231, 1),
float4(0.01982389, 0.01982389, 0.01982389, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 0, 0, 1),
float4(0.01982389, 0.01982389, 0.01982389, 1),
float4(0.2054128, 0.2054128, 0.2054128, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(0.1114872, 0.003367036, 0.003367036, 1),
float4(0.1507121, 0, 0, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(0.002920729, 0.002920729, 0.002920729, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(0.003686107, 0.003686107, 0.003686107, 1),
float4(0, 0, 0, 1),
};
static const bool WKVRCOptimizerArrayshouldSample_MainTex[33] = 
{
true,
true,
false,
false,
false,
true,
true,
true,
true,
false,
false,
false,
true,
true,
false,
false,
true,
true,
true,
false,
false,
true,
true,
true,
true,
true,
false,
true,
true,
true,
true,
false,
false,
};
static const float4 WKVRCOptimizerArray_MainTex_TexelSize[33] = 
{
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 2048, 1.0 / 2048, 2048, 2048),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 2048, 1.0 / 2048, 2048, 2048),
float4(1.0 / 512, 1.0 / 512, 512, 512),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
};
static const bool WKVRCOptimizerArrayshouldSample_BumpMap[33] = 
{
true,
true,
false,
false,
false,
true,
true,
false,
false,
false,
false,
false,
false,
false,
false,
false,
true,
true,
true,
true,
true,
true,
true,
true,
true,
true,
true,
true,
true,
true,
true,
true,
true,
};
static const float4 WKVRCOptimizerArray_BumpMap_TexelSize[33] = 
{
float4(1.0 / 2048, 1.0 / 2048, 2048, 2048),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 2048, 1.0 / 2048, 2048, 2048),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 512, 1.0 / 512, 512, 512),
float4(1.0 / 512, 1.0 / 512, 512, 512),
float4(1.0 / 512, 1.0 / 512, 512, 512),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 2048, 1.0 / 2048, 2048, 2048),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 2048, 1.0 / 2048, 2048, 2048),
float4(1.0 / 2048, 1.0 / 2048, 2048, 2048),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 2048, 1.0 / 2048, 2048, 2048),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 2048, 1.0 / 2048, 2048, 2048),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 2048, 1.0 / 2048, 2048, 2048),
float4(1.0 / 2048, 1.0 / 2048, 2048, 2048),
float4(1.0 / 2048, 1.0 / 2048, 2048, 2048),
};
static const float4 WKVRCOptimizerArray_BumpMap_ST[33] = 
{
float4(20, 20, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(10, 10, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(1, 1, 0, 0),
float4(15, 15, 0, 0),
};
static const float WKVRCOptimizerArray_BumpScale[33] = 
{
1.8,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1.5,
1.5,
1.5,
5.55,
1,
1.48,
1,
1,
1,
1,
1,
1,
2.9,
1,
1,
1.93,
1,
};
static const bool WKVRCOptimizerArrayshouldSample_AlphaMask[33] = 
{
false,
false,
false,
false,
false,
false,
false,
false,
false,
false,
true,
false,
false,
false,
true,
true,
true,
true,
true,
false,
false,
false,
false,
false,
false,
false,
false,
true,
false,
false,
false,
true,
false,
};
static const float4 WKVRCOptimizerArray_AlphaMask_TexelSize[33] = 
{
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 2048, 1.0 / 2048, 2048, 2048),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 4, 1.0 / 4, 4, 4),
float4(1.0 / 1024, 1.0 / 1024, 1024, 1024),
float4(1.0 / 4, 1.0 / 4, 4, 4),
};
static const float WKVRCOptimizerArray_MainAlphaMaskMode[33] = 
{
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
1,
1,
1,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
2,
};
static const float WKVRCOptimizerArray_Cutoff[32] = 
{
0.01,
0.01,
0.5,
0.01,
0.5,
0.5,
0.5,
0.5,
0,
0.5,
0,
0.5,
0.5,
0.5,
0.5,
0.002,
0.002,
0.5,
0.002,
0.01,
0.01,
0.01,
0.01,
0.01,
0.01,
0.01,
0.01,
0,
0.01,
0.01,
0,
0.5,
};
static const float WKVRCOptimizerArray_Saturation[25] = 
{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
3.37,
0,
0,
0,
0,
3.37,
0,
0,
4,
0,
};
static const float WKVRCOptimizerArray_AlphaForceOpaque[33] = 
{
0,
0,
1,
0,
1,
1,
1,
1,
0,
1,
0,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
0,
0,
};
static const float4 WKVRCOptimizerArray_DecalColor[17] = 
{
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(0, 0, 0, 1),
float4(0, 0, 0, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(1, 1, 1, 1),
float4(0.9162945, 0.9162945, 0.9162945, 1),
};
static const float WKVRCOptimizerArraym_start_PoiShading[33] = 
{
0,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
0,
0,
0,
0,
0,
0,
0,
0,
1,
};
static const float4 WKVRCOptimizerArray_CubeMapColor[12] = 
{
float4(1, 1, 1, 1),
float4(0.301212, 0.301212, 0.301212, 1),
float4(0.2411783, 0.2411783, 0.2411783, 1),
float4(0.3341808, 0.3341808, 0.3341808, 1),
float4(0.2702231, 0.2702231, 0.2702231, 1),
float4(0.418999, 0.418999, 0.418999, 1),
float4(1, 1, 1, 1),
float4(0.3229691, 0.3229691, 0.3229691, 1),
float4(0.301212, 0.301212, 0.301212, 1),
float4(0.3341808, 0.3341808, 0.3341808, 1),
float4(0.3229691, 0.3229691, 0.3229691, 1),
float4(0.3572768, 0.3572768, 0.3572768, 1),
};
static const float WKVRCOptimizerArray_MochieRoughnessMultiplier[28] = 
{
0.5,
0.5,
0.5,
1,
0.758,
0.829,
0.5,
0.5,
0.5,
1,
1,
0.5,
0.5,
0.5,
0.5,
0.5,
0.5,
0.5,
0.5,
0.5,
0.5,
0.5,
0.5,
0.5,
0.5,
0.5,
0.5,
0.5,
};
static const float WKVRCOptimizerArraym_vertexCategory[33] = 
{
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
};
static const float WKVRCOptimizerArraym_renderingCategory[33] = 
{
1,
1,
1,
1,
1,
0,
0,
0,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
0,
};
static const float WKVRCOptimizerArray_ZWrite[33] = 
{
1,
1,
1,
1,
1,
1,
1,
1,
0,
1,
0,
1,
1,
1,
1,
0,
0,
1,
0,
1,
1,
1,
1,
1,
1,
1,
1,
0,
1,
1,
1,
1,
1,
};
static const float WKVRCOptimizerArray_RenderingEarlyZEnabled[33] = 
{
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
1,
0,
1,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
0,
};
static const float WKVRCOptimizerArray_SrcBlend[33] = 
{
5,
5,
1,
5,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
5,
5,
1,
5,
5,
5,
5,
5,
5,
5,
5,
5,
1,
5,
5,
1,
1,
1,
};
static const float WKVRCOptimizerArray_DstBlend[33] = 
{
10,
10,
0,
10,
0,
0,
0,
0,
10,
0,
10,
0,
0,
0,
0,
10,
10,
0,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
10,
0,
0,
0,
};
static const float WKVRCOptimizerArray_AddSrcBlend[33] = 
{
5,
5,
1,
5,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
5,
5,
1,
5,
5,
5,
5,
5,
5,
5,
5,
5,
1,
5,
5,
1,
1,
1,
};
static const float WKVRCOptimizerArray_BlendOpAlpha[33] = 
{
4,
4,
0,
4,
0,
0,
0,
0,
4,
0,
4,
0,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
4,
};
static const float WKVRCOptimizerArray_DstBlendAlpha[33] = 
{
1,
1,
10,
1,
10,
10,
10,
10,
1,
10,
1,
10,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
1,
};
#define DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__MainTex
Texture2D<float4> _MainTex;
SamplerState sampler_MainTex;
class _MainTex_Wrapper {
float memberToDifferentiateWrapperClasses[1];
float4 Sample(SamplerState sampl, float2 uv) {
float2 ddxuv = ddx(uv);
float2 ddyuv = ddy(uv);
if (!shouldSample_MainTex) return float4(1,1,1,1);
return _MainTex.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleGrad(SamplerState sampl, float2 uv, float2 ddxuv, float2 ddyuv) {
if (!shouldSample_MainTex) return float4(1,1,1,1);
return _MainTex.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleLevel(SamplerState sampl, float2 uv, int mipLevel) {
if (!shouldSample_MainTex) return float4(1,1,1,1);
return _MainTex.SampleLevel(sampl, uv, mipLevel);}
float4 SampleBias(SamplerState sampl, float2 uv, float bias) {
if (!shouldSample_MainTex) return float4(1,1,1,1);
return _MainTex.SampleBias(sampl, uv, bias);}
float4 Load(uint3 uv) {
if (!shouldSample_MainTex) return float4(1,1,1,1);
return _MainTex.Load(uv);}
void GetDimensions(out float width, out float height) {
if (!shouldSample_MainTex) { width = 4; height = 4; return; }
_MainTex.GetDimensions(width, height);}
void GetDimensions(out uint width, out uint height) {
if (!shouldSample_MainTex) { width = 4; height = 4; return; }
_MainTex.GetDimensions(width, height);}
void GetDimensions(uint mipLevel, out float width, out float height, out float numberOfLevels) {
if (!shouldSample_MainTex) { width = 4; height = 4; numberOfLevels = 1; return; }
_MainTex.GetDimensions(mipLevel, width, height, numberOfLevels);}
void GetDimensions(uint mipLevel, out uint width, out uint height, out uint numberOfLevels) {
if (!shouldSample_MainTex) { width = 4; height = 4; numberOfLevels = 1; return; }
_MainTex.GetDimensions(mipLevel, width, height, numberOfLevels);}
};
float4 tex2D(_MainTex_Wrapper wrapper, float2 uv) {
return wrapper.Sample(sampler_MainTex, uv);}
float4 tex2Dproj(_MainTex_Wrapper wrapper, float4 uv) {
return wrapper.Sample(sampler_MainTex, uv.xy / uv.w);}
float4 tex2D(_MainTex_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_MainTex, uv, ddxuv, ddyuv);}
float4 tex2Dgrad(_MainTex_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_MainTex, uv, ddxuv, ddyuv);}
float4 tex2Dlod(_MainTex_Wrapper wrapper, float4 uv) {
return wrapper.SampleLevel(sampler_MainTex, uv.xy, uv.w);}
float4 tex2Dbias(_MainTex_Wrapper wrapper, float4 uv) {
return wrapper.SampleBias(sampler_MainTex, uv.xy, uv.w);}
static _MainTex_Wrapper _MainTex_Wrapper_Instance;
#define _MainTex _MainTex_Wrapper_Instance
#define _MainTex_Wrapper_Instance_ST _MainTex_ST
#define sampler_MainTex_Wrapper_Instance sampler_MainTex
#define _MainTex_Wrapper_Instance_TexelSize _MainTex_TexelSize
#define DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__BumpMap
Texture2D<float4> _BumpMap;
SamplerState sampler_BumpMap;
class _BumpMap_Wrapper {
float memberToDifferentiateWrapperClasses[2];
float4 Sample(SamplerState sampl, float2 uv) {
float2 ddxuv = ddx(uv);
float2 ddyuv = ddy(uv);
if (!shouldSample_BumpMap) return float4(0.5,0.5,1,1);
return _BumpMap.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleGrad(SamplerState sampl, float2 uv, float2 ddxuv, float2 ddyuv) {
if (!shouldSample_BumpMap) return float4(0.5,0.5,1,1);
return _BumpMap.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleLevel(SamplerState sampl, float2 uv, int mipLevel) {
if (!shouldSample_BumpMap) return float4(0.5,0.5,1,1);
return _BumpMap.SampleLevel(sampl, uv, mipLevel);}
float4 SampleBias(SamplerState sampl, float2 uv, float bias) {
if (!shouldSample_BumpMap) return float4(0.5,0.5,1,1);
return _BumpMap.SampleBias(sampl, uv, bias);}
float4 Load(uint3 uv) {
if (!shouldSample_BumpMap) return float4(0.5,0.5,1,1);
return _BumpMap.Load(uv);}
void GetDimensions(out float width, out float height) {
if (!shouldSample_BumpMap) { width = 4; height = 4; return; }
_BumpMap.GetDimensions(width, height);}
void GetDimensions(out uint width, out uint height) {
if (!shouldSample_BumpMap) { width = 4; height = 4; return; }
_BumpMap.GetDimensions(width, height);}
void GetDimensions(uint mipLevel, out float width, out float height, out float numberOfLevels) {
if (!shouldSample_BumpMap) { width = 4; height = 4; numberOfLevels = 1; return; }
_BumpMap.GetDimensions(mipLevel, width, height, numberOfLevels);}
void GetDimensions(uint mipLevel, out uint width, out uint height, out uint numberOfLevels) {
if (!shouldSample_BumpMap) { width = 4; height = 4; numberOfLevels = 1; return; }
_BumpMap.GetDimensions(mipLevel, width, height, numberOfLevels);}
};
float4 tex2D(_BumpMap_Wrapper wrapper, float2 uv) {
return wrapper.Sample(sampler_BumpMap, uv);}
float4 tex2Dproj(_BumpMap_Wrapper wrapper, float4 uv) {
return wrapper.Sample(sampler_BumpMap, uv.xy / uv.w);}
float4 tex2D(_BumpMap_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_BumpMap, uv, ddxuv, ddyuv);}
float4 tex2Dgrad(_BumpMap_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_BumpMap, uv, ddxuv, ddyuv);}
float4 tex2Dlod(_BumpMap_Wrapper wrapper, float4 uv) {
return wrapper.SampleLevel(sampler_BumpMap, uv.xy, uv.w);}
float4 tex2Dbias(_BumpMap_Wrapper wrapper, float4 uv) {
return wrapper.SampleBias(sampler_BumpMap, uv.xy, uv.w);}
static _BumpMap_Wrapper _BumpMap_Wrapper_Instance;
#define _BumpMap _BumpMap_Wrapper_Instance
#define _BumpMap_Wrapper_Instance_ST _BumpMap_ST
#define sampler_BumpMap_Wrapper_Instance sampler_BumpMap
#define _BumpMap_Wrapper_Instance_TexelSize _BumpMap_TexelSize
#define DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__AlphaMask
Texture2D<float4> _AlphaMask;
SamplerState sampler_AlphaMask;
class _AlphaMask_Wrapper {
float memberToDifferentiateWrapperClasses[3];
float4 Sample(SamplerState sampl, float2 uv) {
float2 ddxuv = ddx(uv);
float2 ddyuv = ddy(uv);
if (!shouldSample_AlphaMask) return float4(1,1,1,1);
return _AlphaMask.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleGrad(SamplerState sampl, float2 uv, float2 ddxuv, float2 ddyuv) {
if (!shouldSample_AlphaMask) return float4(1,1,1,1);
return _AlphaMask.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleLevel(SamplerState sampl, float2 uv, int mipLevel) {
if (!shouldSample_AlphaMask) return float4(1,1,1,1);
return _AlphaMask.SampleLevel(sampl, uv, mipLevel);}
float4 SampleBias(SamplerState sampl, float2 uv, float bias) {
if (!shouldSample_AlphaMask) return float4(1,1,1,1);
return _AlphaMask.SampleBias(sampl, uv, bias);}
float4 Load(uint3 uv) {
if (!shouldSample_AlphaMask) return float4(1,1,1,1);
return _AlphaMask.Load(uv);}
void GetDimensions(out float width, out float height) {
if (!shouldSample_AlphaMask) { width = 4; height = 4; return; }
_AlphaMask.GetDimensions(width, height);}
void GetDimensions(out uint width, out uint height) {
if (!shouldSample_AlphaMask) { width = 4; height = 4; return; }
_AlphaMask.GetDimensions(width, height);}
void GetDimensions(uint mipLevel, out float width, out float height, out float numberOfLevels) {
if (!shouldSample_AlphaMask) { width = 4; height = 4; numberOfLevels = 1; return; }
_AlphaMask.GetDimensions(mipLevel, width, height, numberOfLevels);}
void GetDimensions(uint mipLevel, out uint width, out uint height, out uint numberOfLevels) {
if (!shouldSample_AlphaMask) { width = 4; height = 4; numberOfLevels = 1; return; }
_AlphaMask.GetDimensions(mipLevel, width, height, numberOfLevels);}
};
float4 tex2D(_AlphaMask_Wrapper wrapper, float2 uv) {
return wrapper.Sample(sampler_AlphaMask, uv);}
float4 tex2Dproj(_AlphaMask_Wrapper wrapper, float4 uv) {
return wrapper.Sample(sampler_AlphaMask, uv.xy / uv.w);}
float4 tex2D(_AlphaMask_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_AlphaMask, uv, ddxuv, ddyuv);}
float4 tex2Dgrad(_AlphaMask_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_AlphaMask, uv, ddxuv, ddyuv);}
float4 tex2Dlod(_AlphaMask_Wrapper wrapper, float4 uv) {
return wrapper.SampleLevel(sampler_AlphaMask, uv.xy, uv.w);}
float4 tex2Dbias(_AlphaMask_Wrapper wrapper, float4 uv) {
return wrapper.SampleBias(sampler_AlphaMask, uv.xy, uv.w);}
static _AlphaMask_Wrapper _AlphaMask_Wrapper_Instance;
#define _AlphaMask _AlphaMask_Wrapper_Instance
#define _AlphaMask_Wrapper_Instance_ST _AlphaMask_ST
#define sampler_AlphaMask_Wrapper_Instance sampler_AlphaMask
#define _AlphaMask_Wrapper_Instance_TexelSize _AlphaMask_TexelSize
#define DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__DecalMask
Texture2D<float4> _DecalMask;
SamplerState sampler_DecalMask;
class _DecalMask_Wrapper {
float memberToDifferentiateWrapperClasses[4];
float4 Sample(SamplerState sampl, float2 uv) {
float2 ddxuv = ddx(uv);
float2 ddyuv = ddy(uv);
if (!shouldSample_DecalMask) return float4(1,1,1,1);
return _DecalMask.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleGrad(SamplerState sampl, float2 uv, float2 ddxuv, float2 ddyuv) {
if (!shouldSample_DecalMask) return float4(1,1,1,1);
return _DecalMask.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleLevel(SamplerState sampl, float2 uv, int mipLevel) {
if (!shouldSample_DecalMask) return float4(1,1,1,1);
return _DecalMask.SampleLevel(sampl, uv, mipLevel);}
float4 SampleBias(SamplerState sampl, float2 uv, float bias) {
if (!shouldSample_DecalMask) return float4(1,1,1,1);
return _DecalMask.SampleBias(sampl, uv, bias);}
float4 Load(uint3 uv) {
if (!shouldSample_DecalMask) return float4(1,1,1,1);
return _DecalMask.Load(uv);}
void GetDimensions(out float width, out float height) {
if (!shouldSample_DecalMask) { width = 4; height = 4; return; }
_DecalMask.GetDimensions(width, height);}
void GetDimensions(out uint width, out uint height) {
if (!shouldSample_DecalMask) { width = 4; height = 4; return; }
_DecalMask.GetDimensions(width, height);}
void GetDimensions(uint mipLevel, out float width, out float height, out float numberOfLevels) {
if (!shouldSample_DecalMask) { width = 4; height = 4; numberOfLevels = 1; return; }
_DecalMask.GetDimensions(mipLevel, width, height, numberOfLevels);}
void GetDimensions(uint mipLevel, out uint width, out uint height, out uint numberOfLevels) {
if (!shouldSample_DecalMask) { width = 4; height = 4; numberOfLevels = 1; return; }
_DecalMask.GetDimensions(mipLevel, width, height, numberOfLevels);}
};
float4 tex2D(_DecalMask_Wrapper wrapper, float2 uv) {
return wrapper.Sample(sampler_DecalMask, uv);}
float4 tex2Dproj(_DecalMask_Wrapper wrapper, float4 uv) {
return wrapper.Sample(sampler_DecalMask, uv.xy / uv.w);}
float4 tex2D(_DecalMask_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_DecalMask, uv, ddxuv, ddyuv);}
float4 tex2Dgrad(_DecalMask_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_DecalMask, uv, ddxuv, ddyuv);}
float4 tex2Dlod(_DecalMask_Wrapper wrapper, float4 uv) {
return wrapper.SampleLevel(sampler_DecalMask, uv.xy, uv.w);}
float4 tex2Dbias(_DecalMask_Wrapper wrapper, float4 uv) {
return wrapper.SampleBias(sampler_DecalMask, uv.xy, uv.w);}
static _DecalMask_Wrapper _DecalMask_Wrapper_Instance;
#define _DecalMask _DecalMask_Wrapper_Instance
#define _DecalMask_Wrapper_Instance_ST _DecalMask_ST
#define sampler_DecalMask_Wrapper_Instance sampler_DecalMask
#define _DecalMask_Wrapper_Instance_TexelSize _DecalMask_TexelSize
#define DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__DecalTexture
Texture2D<float4> _DecalTexture;
SamplerState sampler_DecalTexture;
class _DecalTexture_Wrapper {
float memberToDifferentiateWrapperClasses[5];
float4 Sample(SamplerState sampl, float2 uv) {
float2 ddxuv = ddx(uv);
float2 ddyuv = ddy(uv);
if (!shouldSample_DecalTexture) return float4(1,1,1,1);
return _DecalTexture.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleGrad(SamplerState sampl, float2 uv, float2 ddxuv, float2 ddyuv) {
if (!shouldSample_DecalTexture) return float4(1,1,1,1);
return _DecalTexture.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleLevel(SamplerState sampl, float2 uv, int mipLevel) {
if (!shouldSample_DecalTexture) return float4(1,1,1,1);
return _DecalTexture.SampleLevel(sampl, uv, mipLevel);}
float4 SampleBias(SamplerState sampl, float2 uv, float bias) {
if (!shouldSample_DecalTexture) return float4(1,1,1,1);
return _DecalTexture.SampleBias(sampl, uv, bias);}
float4 Load(uint3 uv) {
if (!shouldSample_DecalTexture) return float4(1,1,1,1);
return _DecalTexture.Load(uv);}
void GetDimensions(out float width, out float height) {
if (!shouldSample_DecalTexture) { width = 4; height = 4; return; }
_DecalTexture.GetDimensions(width, height);}
void GetDimensions(out uint width, out uint height) {
if (!shouldSample_DecalTexture) { width = 4; height = 4; return; }
_DecalTexture.GetDimensions(width, height);}
void GetDimensions(uint mipLevel, out float width, out float height, out float numberOfLevels) {
if (!shouldSample_DecalTexture) { width = 4; height = 4; numberOfLevels = 1; return; }
_DecalTexture.GetDimensions(mipLevel, width, height, numberOfLevels);}
void GetDimensions(uint mipLevel, out uint width, out uint height, out uint numberOfLevels) {
if (!shouldSample_DecalTexture) { width = 4; height = 4; numberOfLevels = 1; return; }
_DecalTexture.GetDimensions(mipLevel, width, height, numberOfLevels);}
};
float4 tex2D(_DecalTexture_Wrapper wrapper, float2 uv) {
return wrapper.Sample(sampler_DecalTexture, uv);}
float4 tex2Dproj(_DecalTexture_Wrapper wrapper, float4 uv) {
return wrapper.Sample(sampler_DecalTexture, uv.xy / uv.w);}
float4 tex2D(_DecalTexture_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_DecalTexture, uv, ddxuv, ddyuv);}
float4 tex2Dgrad(_DecalTexture_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_DecalTexture, uv, ddxuv, ddyuv);}
float4 tex2Dlod(_DecalTexture_Wrapper wrapper, float4 uv) {
return wrapper.SampleLevel(sampler_DecalTexture, uv.xy, uv.w);}
float4 tex2Dbias(_DecalTexture_Wrapper wrapper, float4 uv) {
return wrapper.SampleBias(sampler_DecalTexture, uv.xy, uv.w);}
static _DecalTexture_Wrapper _DecalTexture_Wrapper_Instance;
#define _DecalTexture _DecalTexture_Wrapper_Instance
#define _DecalTexture_Wrapper_Instance_ST _DecalTexture_ST
#define sampler_DecalTexture_Wrapper_Instance sampler_DecalTexture
#define _DecalTexture_Wrapper_Instance_TexelSize _DecalTexture_TexelSize
#define DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__Matcap0NormalMap
Texture2D<float4> _Matcap0NormalMap;
SamplerState sampler_Matcap0NormalMap;
class _Matcap0NormalMap_Wrapper {
float memberToDifferentiateWrapperClasses[6];
float4 Sample(SamplerState sampl, float2 uv) {
float2 ddxuv = ddx(uv);
float2 ddyuv = ddy(uv);
if (!shouldSample_Matcap0NormalMap) return float4(0.5,0.5,1,1);
return _Matcap0NormalMap.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleGrad(SamplerState sampl, float2 uv, float2 ddxuv, float2 ddyuv) {
if (!shouldSample_Matcap0NormalMap) return float4(0.5,0.5,1,1);
return _Matcap0NormalMap.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleLevel(SamplerState sampl, float2 uv, int mipLevel) {
if (!shouldSample_Matcap0NormalMap) return float4(0.5,0.5,1,1);
return _Matcap0NormalMap.SampleLevel(sampl, uv, mipLevel);}
float4 SampleBias(SamplerState sampl, float2 uv, float bias) {
if (!shouldSample_Matcap0NormalMap) return float4(0.5,0.5,1,1);
return _Matcap0NormalMap.SampleBias(sampl, uv, bias);}
float4 Load(uint3 uv) {
if (!shouldSample_Matcap0NormalMap) return float4(0.5,0.5,1,1);
return _Matcap0NormalMap.Load(uv);}
void GetDimensions(out float width, out float height) {
if (!shouldSample_Matcap0NormalMap) { width = 4; height = 4; return; }
_Matcap0NormalMap.GetDimensions(width, height);}
void GetDimensions(out uint width, out uint height) {
if (!shouldSample_Matcap0NormalMap) { width = 4; height = 4; return; }
_Matcap0NormalMap.GetDimensions(width, height);}
void GetDimensions(uint mipLevel, out float width, out float height, out float numberOfLevels) {
if (!shouldSample_Matcap0NormalMap) { width = 4; height = 4; numberOfLevels = 1; return; }
_Matcap0NormalMap.GetDimensions(mipLevel, width, height, numberOfLevels);}
void GetDimensions(uint mipLevel, out uint width, out uint height, out uint numberOfLevels) {
if (!shouldSample_Matcap0NormalMap) { width = 4; height = 4; numberOfLevels = 1; return; }
_Matcap0NormalMap.GetDimensions(mipLevel, width, height, numberOfLevels);}
};
float4 tex2D(_Matcap0NormalMap_Wrapper wrapper, float2 uv) {
return wrapper.Sample(sampler_Matcap0NormalMap, uv);}
float4 tex2Dproj(_Matcap0NormalMap_Wrapper wrapper, float4 uv) {
return wrapper.Sample(sampler_Matcap0NormalMap, uv.xy / uv.w);}
float4 tex2D(_Matcap0NormalMap_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_Matcap0NormalMap, uv, ddxuv, ddyuv);}
float4 tex2Dgrad(_Matcap0NormalMap_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_Matcap0NormalMap, uv, ddxuv, ddyuv);}
float4 tex2Dlod(_Matcap0NormalMap_Wrapper wrapper, float4 uv) {
return wrapper.SampleLevel(sampler_Matcap0NormalMap, uv.xy, uv.w);}
float4 tex2Dbias(_Matcap0NormalMap_Wrapper wrapper, float4 uv) {
return wrapper.SampleBias(sampler_Matcap0NormalMap, uv.xy, uv.w);}
static _Matcap0NormalMap_Wrapper _Matcap0NormalMap_Wrapper_Instance;
#define _Matcap0NormalMap _Matcap0NormalMap_Wrapper_Instance
#define _Matcap0NormalMap_Wrapper_Instance_ST _Matcap0NormalMap_ST
#define sampler_Matcap0NormalMap_Wrapper_Instance sampler_Matcap0NormalMap
#define _Matcap0NormalMap_Wrapper_Instance_TexelSize _Matcap0NormalMap_TexelSize
#define DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__CubeMapMask
Texture2D<float4> _CubeMapMask;
SamplerState sampler_CubeMapMask;
class _CubeMapMask_Wrapper {
float memberToDifferentiateWrapperClasses[7];
float4 Sample(SamplerState sampl, float2 uv) {
float2 ddxuv = ddx(uv);
float2 ddyuv = ddy(uv);
if (!shouldSample_CubeMapMask) return float4(1,1,1,1);
return _CubeMapMask.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleGrad(SamplerState sampl, float2 uv, float2 ddxuv, float2 ddyuv) {
if (!shouldSample_CubeMapMask) return float4(1,1,1,1);
return _CubeMapMask.SampleGrad(sampl, uv, ddxuv, ddyuv);}
float4 SampleLevel(SamplerState sampl, float2 uv, int mipLevel) {
if (!shouldSample_CubeMapMask) return float4(1,1,1,1);
return _CubeMapMask.SampleLevel(sampl, uv, mipLevel);}
float4 SampleBias(SamplerState sampl, float2 uv, float bias) {
if (!shouldSample_CubeMapMask) return float4(1,1,1,1);
return _CubeMapMask.SampleBias(sampl, uv, bias);}
float4 Load(uint3 uv) {
if (!shouldSample_CubeMapMask) return float4(1,1,1,1);
return _CubeMapMask.Load(uv);}
void GetDimensions(out float width, out float height) {
if (!shouldSample_CubeMapMask) { width = 4; height = 4; return; }
_CubeMapMask.GetDimensions(width, height);}
void GetDimensions(out uint width, out uint height) {
if (!shouldSample_CubeMapMask) { width = 4; height = 4; return; }
_CubeMapMask.GetDimensions(width, height);}
void GetDimensions(uint mipLevel, out float width, out float height, out float numberOfLevels) {
if (!shouldSample_CubeMapMask) { width = 4; height = 4; numberOfLevels = 1; return; }
_CubeMapMask.GetDimensions(mipLevel, width, height, numberOfLevels);}
void GetDimensions(uint mipLevel, out uint width, out uint height, out uint numberOfLevels) {
if (!shouldSample_CubeMapMask) { width = 4; height = 4; numberOfLevels = 1; return; }
_CubeMapMask.GetDimensions(mipLevel, width, height, numberOfLevels);}
};
float4 tex2D(_CubeMapMask_Wrapper wrapper, float2 uv) {
return wrapper.Sample(sampler_CubeMapMask, uv);}
float4 tex2Dproj(_CubeMapMask_Wrapper wrapper, float4 uv) {
return wrapper.Sample(sampler_CubeMapMask, uv.xy / uv.w);}
float4 tex2D(_CubeMapMask_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_CubeMapMask, uv, ddxuv, ddyuv);}
float4 tex2Dgrad(_CubeMapMask_Wrapper wrapper, float2 uv, float2 ddxuv, float2 ddyuv) {
return wrapper.SampleGrad(sampler_CubeMapMask, uv, ddxuv, ddyuv);}
float4 tex2Dlod(_CubeMapMask_Wrapper wrapper, float4 uv) {
return wrapper.SampleLevel(sampler_CubeMapMask, uv.xy, uv.w);}
float4 tex2Dbias(_CubeMapMask_Wrapper wrapper, float4 uv) {
return wrapper.SampleBias(sampler_CubeMapMask, uv.xy, uv.w);}
static _CubeMapMask_Wrapper _CubeMapMask_Wrapper_Instance;
#define _CubeMapMask _CubeMapMask_Wrapper_Instance
#define _CubeMapMask_Wrapper_Instance_ST _CubeMapMask_ST
#define sampler_CubeMapMask_Wrapper_Instance sampler_CubeMapMask
#define _CubeMapMask_Wrapper_Instance_TexelSize _CubeMapMask_TexelSize
// Include UnityLightingCommon.cginc
#ifndef UNITY_LIGHTING_COMMON_INCLUDED
#define UNITY_LIGHTING_COMMON_INCLUDED
float4 _LightColor0;
float4 _SpecColor;
struct UnityLight
{
half3 color;
half3 dir;
half ndotl;
}
;
struct UnityIndirect
{
half3 diffuse;
half3 specular;
}
;
struct UnityGI
{
UnityLight light;
UnityIndirect indirect;
}
;
struct UnityGIInput
{
UnityLight light;
float3 worldPos;
half3 worldViewDir;
half atten;
half3 ambient;
float4 lightmapUV;
#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION) || defined(UNITY_ENABLE_REFLECTION_BUFFERS)
float4 boxMin[2];
#endif
#ifdef UNITY_SPECCUBE_BOX_PROJECTION
float4 boxMax[2];
float4 probePosition[2];
#endif
float4 probeHDR[2];
}
;
#endif
#define COLOR_GRADING_HDR
#define GEOM_TYPE_BRANCH
#define MOCHIE_PBR
#define POI_MATCAP0
#define POI_SSAO
#define POI_UZUMORE
#define VIGNETTE_MASKED
#define _CUBEMAP
#define _GLOSSYREFLECTIONS_OFF
#define _LIGHTINGMODE_FLAT
#define _RIM2STYLE_POIYOMI
#define _RIMSTYLE_POIYOMI
#define _STOCHASTICMODE_DELIOT_HEITZ
#define PROP_BUMPMAP
#define PROP_MATCAP
#define PROP_CUBEMAP
#define PROP_CUBEMAPMASK
#define OPTIMIZER_ENABLED
#define POI_PASS_BASE
#include "UnityCG.cginc"
#include "AutoLight.cginc"
#ifndef VRC_LIGHT_VOLUMES_INCLUDED
#define VRC_LIGHT_VOLUMES_INCLUDED
#define VRCLV_VERSION 2
#define VRCLV_MAX_VOLUMES_COUNT 32
#define VRCLV_MAX_LIGHTS_COUNT 128
cbuffer LightVolumeUniforms
{
float _UdonLightVolumeEnabled;
float _UdonLightVolumeVersion;
float _UdonLightVolumeCount;
float _UdonLightVolumeAdditiveMaxOverdraw;
float _UdonLightVolumeAdditiveCount;
float _UdonLightVolumeProbesBlend;
float _UdonLightVolumeSharpBounds;
uniform float4x4 _UdonLightVolumeInvWorldMatrix[VRCLV_MAX_VOLUMES_COUNT];
uniform float4 _UdonLightVolumeRotation[VRCLV_MAX_VOLUMES_COUNT * 2];
uniform float3 _UdonLightVolumeInvLocalEdgeSmooth[VRCLV_MAX_VOLUMES_COUNT];
uniform float3 _UdonLightVolumeUvw[VRCLV_MAX_VOLUMES_COUNT * 6];
uniform float4 _UdonLightVolumeOcclusionUvw[VRCLV_MAX_VOLUMES_COUNT];
uniform float4 _UdonLightVolumeColor[VRCLV_MAX_VOLUMES_COUNT];
float _UdonPointLightVolumeCount;
float _UdonPointLightVolumeCubeCount;
uniform float4 _UdonPointLightVolumePosition[VRCLV_MAX_LIGHTS_COUNT];
uniform float4 _UdonPointLightVolumeColor[VRCLV_MAX_LIGHTS_COUNT];
uniform float4 _UdonPointLightVolumeDirection[VRCLV_MAX_LIGHTS_COUNT];
uniform float3 _UdonPointLightVolumeCustomID[VRCLV_MAX_LIGHTS_COUNT];
float _UdonLightBrightnessCutoff;
float _UdonLightVolumeOcclusionCount;
}
Texture3D _UdonLightVolume;
SamplerState sampler_UdonLightVolume;
Texture2DArray _UdonPointLightVolumeTexture;
#define LV_SAMPLE(tex, uvw) tex.SampleLevel(sampler_UdonLightVolume, uvw, 0)
// Skipped 1 lines
#define LV_PI 3.141592653589793f
#define LV_PI2 6.283185307179586f
float LV_Smoothstep01(float x)
{
return x * x * (3 - 2 * x);
}
float3 LV_MultiplyVectorByQuaternion(float3 v, float4 q)
{
float3 t = 2.0 * cross(q.xyz, v);
return v + q.w * t + cross(q.xyz, t);
}
float3 LV_MultiplyVectorByMatrix2x3(float3 v, float3 r0, float3 r1)
{
float3 r2 = cross(r0, r1);
return float3(dot(v, r0), dot(v, r1), dot(v, r2));
}
float LV_FastAcos(float x)
{
float absX = abs(x);
float res = -0.156583f * absX + LV_PI * 0.5f;
res *= sqrt(1.0f - absX);
return (x >= 0) ? res : (LV_PI - res);
}
float LV_DistributionGGX(float NoH, float roughness)
{
float f = (roughness - 1) * ((roughness + 1) * (NoH * NoH)) + 1;
return (roughness * roughness) / ((float) LV_PI * f * f);
}
bool LV_PointLocalAABB(float3 localUVW)
{
return all(abs(localUVW) <= 0.5);
}
float3 LV_LocalFromVolume(uint volumeID, float3 worldPos)
{
return mul(_UdonLightVolumeInvWorldMatrix[volumeID], float4(worldPos, 1.0)).xyz;
}
float LV_EvaluateSH(float L0, float3 L1, float3 n)
{
return L0 + dot(L1, n);
}
float4 LV_SampleCubemapArray(uint id, float3 dir)
{
float3 absDir = abs(dir);
float2 uv;
uint face;
if (absDir.x >= absDir.y && absDir.x >= absDir.z)
{
face = dir.x > 0 ? 0 : 1;
uv = float2((dir.x > 0 ? -dir.z : dir.z), -dir.y) * rcp(absDir.x);
}
else if (absDir.y >= absDir.z)
{
face = dir.y > 0 ? 2 : 3;
uv = float2(dir.x, (dir.y > 0 ? dir.z : -dir.z)) * rcp(absDir.y);
}
else
{
face = dir.z > 0 ? 4 : 5;
uv = float2((dir.z > 0 ? dir.x : -dir.x), -dir.y) * rcp(absDir.z);
}
float3 uvid = float3(uv * 0.5 + 0.5, id * 6 + face);
return LV_SAMPLE(_UdonPointLightVolumeTexture, uvid);
}
float4 LV_ProjectQuadLightIrradianceSH(float3 shadingPosition, float3 lightVertices[4])
{
[unroll] for (uint edge0 = 0;
edge0 < 4;
edge0++)
{
lightVertices[edge0] = normalize(lightVertices[edge0] - shadingPosition);
}
const float3 zhDir0 = float3(0.866025, -0.500001, -0.000004);
const float3 zhDir1 = float3(-0.759553, 0.438522, -0.480394);
const float3 zhDir2 = float3(-0.000002, 0.638694,  0.769461);
const float3 zhWeightL1y = float3(2.1995339f, 2.50785367f, 1.56572711f);
const float3 zhWeightL1z = float3(-1.82572523f, -2.08165037f, 0.00000000f);
const float3 zhWeightL1x = float3(2.42459869f, 1.44790525f, 0.90397552f);
float solidAngle = 0.0;
float3 surfaceIntegral = 0.0;
[loop] for (uint edge1 = 0;
edge1 < 4;
edge1++)
{
uint next = (edge1 + 1) % 4;
uint prev = (edge1 + 4 - 1) % 4;
float3 prevVert = lightVertices[prev];
float3 thisVert = lightVertices[edge1];
float3 nextVert = lightVertices[next];
float3 a = cross(thisVert, prevVert);
float3 b = cross(thisVert, nextVert);
float lenA = length(a);
float lenB = length(b);
solidAngle += LV_FastAcos(clamp(dot(a, b) / (lenA * lenB), -1, 1));
float3 mu = b * rcp(lenB);
float cosGamma = dot(thisVert, nextVert);
float gamma = LV_FastAcos(clamp(cosGamma, -1, 1));
surfaceIntegral.x += gamma * dot(zhDir0, mu);
surfaceIntegral.y += gamma * dot(zhDir1, mu);
surfaceIntegral.z += gamma * dot(zhDir2, mu);
}
solidAngle = solidAngle - LV_PI2;
surfaceIntegral *= 0.5;
const float normalizationL0 = 0.5f * sqrt(1.0f / LV_PI);
float l0 = normalizationL0 * solidAngle;
float l1y = dot(zhWeightL1y, surfaceIntegral);
float l1z = dot(zhWeightL1z, surfaceIntegral);
float l1x = dot(zhWeightL1x, surfaceIntegral);
const float cosineKernelL0 = LV_PI;
const float cosineKernelL1 = LV_PI2 / 3.0f;
const float oneOverPi = 1.0f / LV_PI;
const float normalizationL1 = 0.5f * sqrt(3.0f / LV_PI);
const float weightL0 = cosineKernelL0 * normalizationL0 * oneOverPi;
const float weightL1 = cosineKernelL1 * normalizationL1 * oneOverPi;
l0  *= weightL0;
l1y *= weightL1;
l1z *= weightL1;
l1x *= weightL1;
return float4(l1x, l1y, l1z, l0);
}
void LV_QuadLight(float3 worldPos, float3 centroidPos, float4 rotationQuat, float2 size, float3 color, float sqMaxDist, float occlusion, inout float3 L0, inout float3 L1r, inout float3 L1g, inout float3 L1b, inout uint count)
{
float3 lightToWorldPos = worldPos - centroidPos;
float3 normal = LV_MultiplyVectorByQuaternion(float3(0, 0, 1), rotationQuat);
if (dot(normal, lightToWorldPos) < 0.0)
return;
float sqCutoffDist = sqMaxDist - dot(lightToWorldPos, lightToWorldPos);
color.rgb *= saturate(sqCutoffDist / sqMaxDist) * LV_PI * occlusion;
float2 halfSize = size * 0.5f;
float3 xAxis = LV_MultiplyVectorByQuaternion(float3(1, 0, 0), rotationQuat);
float3 yAxis = cross(normal, xAxis);
float3 verts[4];
verts[0] = centroidPos + (-halfSize.x * xAxis) + ( halfSize.y * yAxis);
verts[1] = centroidPos + ( halfSize.x * xAxis) + ( halfSize.y * yAxis);
verts[2] = centroidPos + ( halfSize.x * xAxis) + (-halfSize.y * yAxis);
verts[3] = centroidPos + (-halfSize.x * xAxis) + (-halfSize.y * yAxis);
float4 areaLightSH = LV_ProjectQuadLightIrradianceSH(worldPos, verts);
float lenL1 = length(areaLightSH.xyz);
if (lenL1 > areaLightSH.w) areaLightSH.xyz *= areaLightSH.w / lenL1;
L0  += areaLightSH.w * color.rgb;
L1r += areaLightSH.xyz * color.r;
L1g += areaLightSH.xyz * color.g;
L1b += areaLightSH.xyz * color.b;
count++;
}
float3 LV_PointLightAttenuation(float sqdist, float sqlightSize, float3 color, float brightnessCutoff, float sqMaxDist)
{
float mask = saturate(1 - sqdist / sqMaxDist);
return mask * mask * color * sqlightSize / (sqdist + sqlightSize);
}
float LV_PointLightSolidAngle(float sqdist, float sqlightSize)
{
return saturate(sqrt(sqdist / (sqlightSize + sqdist)));
}
void LV_SphereLight(float sqdist, float3 dirN, float sqlightSize, float3 color, float occlusion, float sqMaxDist, inout float3 L0, inout float3 L1r, inout float3 L1g, inout float3 L1b, inout uint count)
{
float3 att = LV_PointLightAttenuation(sqdist, sqlightSize, color, _UdonLightBrightnessCutoff, sqMaxDist);
float3 l0 = att * occlusion;
float3 l1 = dirN * LV_PointLightSolidAngle(sqdist, sqlightSize);
L0 += l0;
L1r += l0.r * l1;
L1g += l0.g * l1;
L1b += l0.b * l1;
count++;
}
void LV_SphereSpotLight(float sqdist, float3 dirN, float sqlightSize, float3 att, float spotMask, float cosAngle, float coneFalloff, float occlusion, inout float3 L0, inout float3 L1r, inout float3 L1g, inout float3 L1b, inout uint count)
{
float smoothedCone = LV_Smoothstep01(saturate(spotMask * coneFalloff));
float3 l0 = att * (occlusion * smoothedCone);
float3 l1 = dirN * LV_PointLightSolidAngle(sqdist, sqlightSize * saturate(1 - cosAngle));
L0 += l0;
L1r += l0.r * l1;
L1g += l0.g * l1;
L1b += l0.b * l1;
count++;
}
void LV_SphereSpotLightCookie(float sqdist, float3 dirN, float sqlightSize, float3 att, float4 lightRot, float tanAngle, uint customId, float occlusion, inout float3 L0, inout float3 L1r, inout float3 L1g, inout float3 L1b, inout uint count)
{
float3 localDir = LV_MultiplyVectorByQuaternion(-dirN, lightRot);
float2 uv = localDir.xy * rcp(localDir.z * tanAngle);
if ( localDir.z <= 0.0 || abs(uv.x) > 1.0 || abs(uv.y) > 1.0 )
return;
uint id = (uint) _UdonPointLightVolumeCubeCount * 5 - customId - 1;
float3 uvid = float3(uv * 0.5 + 0.5, id);
float angleSize = saturate(rsqrt(1 + tanAngle * tanAngle));
float4 cookie = LV_SAMPLE(_UdonPointLightVolumeTexture, uvid);
float3 l0 = att * cookie.rgb * (cookie.a * occlusion);
float3 l1 = dirN * LV_PointLightSolidAngle(sqdist, sqlightSize * (1 - angleSize));
L0 += l0;
L1r += l0.r * l1;
L1g += l0.g * l1;
L1b += l0.b * l1;
count++;
}
void LV_SphereSpotLightAttenuationLUT(float sqdist, float3 dirN, float sqlightSize, float3 color, float spotMask, float cosAngle, uint customId, float occlusion, inout float3 L0, inout float3 L1r, inout float3 L1g, inout float3 L1b, inout uint count)
{
float dirRadius = sqdist * abs(sqlightSize);
float spot = 1 - saturate(spotMask * rcp(1 - cosAngle));
uint id = (uint) _UdonPointLightVolumeCubeCount * 5 + customId - 1;
float3 uvid = float3(sqrt(float2(spot, dirRadius)), id);
float3 att = color.rgb * LV_SAMPLE(_UdonPointLightVolumeTexture, uvid).xyz * occlusion;
L0 += att;
L1r += dirN * att.r;
L1g += dirN * att.g;
L1b += dirN * att.b;
count++;
}
void LV_PointLight(uint id, float3 worldPos, float4 occlusion, inout float3 L0, inout float3 L1r, inout float3 L1g, inout float3 L1b, inout uint count)
{
float3 customID_data = _UdonPointLightVolumeCustomID[id];
int shadowId = (int) customID_data.y;
int customId = (int) customID_data.x;
float sqrRange = customID_data.z;
float4 pos = _UdonPointLightVolumePosition[id];
float3 dir = pos.xyz - worldPos;
float sqlen = max(dot(dir, dir), 1e-6);
if (sqlen > sqrRange)
return;
float3 dirN = dir * rsqrt(sqlen);
float lightOcclusion = 1;
if (_UdonLightVolumeOcclusionCount != 0 && shadowId >= 0)
{
lightOcclusion = dot(occlusion, float4(shadowId == 0, shadowId == 1, shadowId == 2, shadowId == 3));
}
float4 color = _UdonPointLightVolumeColor[id];
float4 ldir = _UdonPointLightVolumeDirection[id];
if (pos.w < 0)
{
float angle = color.w;
float spotMask = dot(ldir.xyz, -dirN) - angle;
if(customId >= 0 && spotMask < 0)
return;
if (customId > 0)
{
LV_SphereSpotLightAttenuationLUT(sqlen, dirN, -pos.w, color.rgb, spotMask, angle, customId, lightOcclusion, L0, L1r, L1g, L1b, count);
}
else
{
float3 att = LV_PointLightAttenuation(sqlen, -pos.w, color.rgb, _UdonLightBrightnessCutoff, sqrRange);
if (customId < 0)
{
LV_SphereSpotLightCookie(sqlen, dirN, -pos.w, att, ldir, angle, customId, lightOcclusion, L0, L1r, L1g, L1b, count);
}
else
{
LV_SphereSpotLight(sqlen, dirN, -pos.w, att, spotMask, angle, ldir.w, lightOcclusion, L0, L1r, L1g, L1b, count);
}
}
}
else if (color.w <= 1.5f)
{
if (customId > 0)
{
float invSqRange = abs(pos.w);
float dirRadius = sqlen * invSqRange;
uint id = (uint) _UdonPointLightVolumeCubeCount * 5 + customId;
float3 uvid = float3(sqrt(float2(0, dirRadius)), id);
float3 att = color.rgb * LV_SAMPLE(_UdonPointLightVolumeTexture, uvid).xyz * lightOcclusion;
L0 += att;
L1r += dirN * att.r;
L1g += dirN * att.g;
L1b += dirN * att.b;
count++;
}
else
{
float3 l0 = 0, l1r = 0, l1g = 0, l1b = 0;
LV_SphereLight(sqlen, dirN, pos.w, color.rgb, lightOcclusion, sqrRange, l0, l1r, l1g, l1b, count);
float3 cubeColor = 1;
if (customId < 0)
{
uint id = -customId - 1;
cubeColor = LV_SampleCubemapArray(id, LV_MultiplyVectorByQuaternion(dirN, ldir)).xyz;
}
L0 += l0 * cubeColor;
L1r += l1r * cubeColor.r;
L1g += l1g * cubeColor.g;
L1b += l1b * cubeColor.b;
}
}
else
{
LV_QuadLight(worldPos, pos.xyz, ldir, float2(pos.w, color.w - 2.0f), color.rgb, sqrRange, lightOcclusion, L0, L1r, L1g, L1b, count);
}
}
void LV_SampleLightVolumeTex(float3 uvw0, float3 uvw1, float3 uvw2, out float3 L0, out float3 L1r, out float3 L1g, out float3 L1b)
{
float4 tex0 = LV_SAMPLE(_UdonLightVolume, uvw0);
float4 tex1 = LV_SAMPLE(_UdonLightVolume, uvw1);
float4 tex2 = LV_SAMPLE(_UdonLightVolume, uvw2);
L0 = tex0.rgb;
L1r = float3(tex1.r, tex2.r, tex0.a);
L1g = float3(tex1.g, tex2.g, tex1.a);
L1b = float3(tex1.b, tex2.b, tex2.a);
}
float LV_BoundsMask(float3 localUVW, float3 invLocalEdgeSmooth)
{
float3 distToMin = (localUVW + 0.5) * invLocalEdgeSmooth;
float3 distToMax = (0.5 - localUVW) * invLocalEdgeSmooth;
float3 fade = saturate(min(distToMin, distToMax));
return fade.x * fade.y * fade.z;
}
void LV_SampleLightProbe(inout float3 L0, inout float3 L1r, inout float3 L1g, inout float3 L1b)
{
L0 += float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);
L1r += unity_SHAr.xyz;
L1g += unity_SHAg.xyz;
L1b += unity_SHAb.xyz;
}
void LV_SampleLightProbeDering(inout float3 L0, inout float3 L1r, inout float3 L1g, inout float3 L1b)
{
L0 += float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);
L1r += unity_SHAr.xyz * 0.565f;
L1g += unity_SHAg.xyz * 0.565f;
L1b += unity_SHAb.xyz * 0.565f;
}
void LV_SampleVolume(uint id, float3 localUVW, inout float3 L0, inout float3 L1r, inout float3 L1g, inout float3 L1b, out float4 occlusion)
{
uint uvwID = id * 6;
float3 uvwScaled = saturate(localUVW + 0.5) * (_UdonLightVolumeUvw[uvwID + 1].xyz - _UdonLightVolumeUvw[uvwID].xyz);
float3 uvw0 = uvwScaled + _UdonLightVolumeUvw[uvwID].xyz;
float3 uvw1 = uvwScaled + _UdonLightVolumeUvw[uvwID + 2].xyz;
float3 uvw2 = uvwScaled + _UdonLightVolumeUvw[uvwID + 4].xyz;
float3 l0;
float3 l1r;
float3 l1g;
float3 l1b;
LV_SampleLightVolumeTex(uvw0, uvw1, uvw2, l0, l1r, l1g, l1b);
float4 uvwOcclusion = _UdonLightVolumeOcclusionUvw[id];
if (uvwOcclusion.x >= 0)
{
occlusion = 1.0f - LV_SAMPLE(_UdonLightVolume, uvwOcclusion.xyz + uvwScaled * uvwOcclusion.w);
}
else
{
occlusion = 1;
}
float4 color = _UdonLightVolumeColor[id];
L0 += l0 * color.rgb;
l1r *= color.r;
l1g *= color.g;
l1b *= color.b;
if (color.a != 0)
{
float3 r0 = _UdonLightVolumeRotation[id * 2].xyz;
float3 r1 = _UdonLightVolumeRotation[id * 2 + 1].xyz;
L1r += LV_MultiplyVectorByMatrix2x3(l1r, r0, r1);
L1g += LV_MultiplyVectorByMatrix2x3(l1g, r0, r1);
L1b += LV_MultiplyVectorByMatrix2x3(l1b, r0, r1);
}
else
{
L1r += l1r;
L1g += l1g;
L1b += l1b;
}
}
float4 LV_SampleVolumeOcclusion(uint id, float3 localUVW)
{
float4 uvwOcclusion = _UdonLightVolumeOcclusionUvw[id];
if (uvwOcclusion.x >= 0)
{
uint uvwID = id * 6;
float3 uvwScaled = saturate(localUVW + 0.5) * (_UdonLightVolumeUvw[uvwID + 1].xyz - _UdonLightVolumeUvw[uvwID].xyz);
return 1.0f - LV_SAMPLE(_UdonLightVolume, uvwOcclusion.xyz + uvwScaled * uvwOcclusion.w);
}
else
{
return 1;
}
}
void LV_PointLightVolumeSH(float3 worldPos, float4 occlusion, inout float3 L0, inout float3 L1r, inout float3 L1g, inout float3 L1b)
{
uint pointCount = min((uint) _UdonPointLightVolumeCount, VRCLV_MAX_LIGHTS_COUNT);
if (pointCount == 0)
return;
uint maxOverdraw = min((uint) _UdonLightVolumeAdditiveMaxOverdraw, VRCLV_MAX_LIGHTS_COUNT);
uint pcount = 0;
[loop] for (uint pid = 0;
pid < pointCount && pcount < maxOverdraw;
pid++)
{
LV_PointLight(pid, worldPos, occlusion, L0, L1r, L1g, L1b, pcount);
}
}
void LV_LightVolumeSH(float3 worldPos, inout float3 L0, inout float3 L1r, inout float3 L1g, inout float3 L1b, out float4 occlusion)
{
occlusion = 1;
float4 mOcclusion = 1;
uint volumesCount = min((uint) _UdonLightVolumeCount, VRCLV_MAX_VOLUMES_COUNT);
if (volumesCount == 0)
{
LV_SampleLightProbe(L0, L1r, L1g, L1b);
return;
}
uint maxOverdraw = min((uint) _UdonLightVolumeAdditiveMaxOverdraw, VRCLV_MAX_VOLUMES_COUNT);
uint additiveCount = min((uint) _UdonLightVolumeAdditiveCount, VRCLV_MAX_VOLUMES_COUNT);
bool lightProbesBlend = _UdonLightVolumeProbesBlend;
uint volumeID_A = -1;
uint volumeID_B = -1;
float3 localUVW   = 0;
float3 localUVW_A = 0;
float3 localUVW_B = 0;
bool isNoA = true;
bool isNoB = true;
uint addVolumesCount = 0;
[loop] for (uint id = 0;
id < volumesCount;
id++)
{
localUVW = LV_LocalFromVolume(id, worldPos);
if (LV_PointLocalAABB(localUVW))
{
if (id < additiveCount)
{
if (addVolumesCount < maxOverdraw)
{
float4 occ;
LV_SampleVolume(id, localUVW, L0, L1r, L1g, L1b, occ);
mOcclusion *= occ;
addVolumesCount++;
}
}
else if (isNoA)
{
volumeID_A = id;
localUVW_A = localUVW;
isNoA = false;
}
else
{
volumeID_B = id;
localUVW_B = localUVW;
isNoB = false;
break;
}
}
}
if (isNoA && lightProbesBlend)
{
LV_SampleLightProbe(L0, L1r, L1g, L1b);
occlusion *= mOcclusion;
return;
}
localUVW_A = isNoA ? localUVW : localUVW_A;
volumeID_A = isNoA ? volumesCount - 1 : volumeID_A;
float3 L0_A  = 0;
float3 L1r_A = 0;
float3 L1g_A = 0;
float3 L1b_A = 0;
float4 occlusion_A = 1;
LV_SampleVolume(volumeID_A, localUVW_A, L0_A, L1r_A, L1g_A, L1b_A, occlusion_A);
float mask = LV_BoundsMask(localUVW_A, _UdonLightVolumeInvLocalEdgeSmooth[volumeID_A]);
if (mask == 1 || isNoA || (_UdonLightVolumeSharpBounds && isNoB))
{
L0  += L0_A;
L1r += L1r_A;
L1g += L1g_A;
L1b += L1b_A;
occlusion = occlusion_A;
occlusion *= mOcclusion;
return;
}
float3 L0_B  = 0;
float3 L1r_B = 0;
float3 L1g_B = 0;
float3 L1b_B = 0;
float4 occlusion_B = 1;
if (isNoB && lightProbesBlend)
{
LV_SampleLightProbe(L0_B, L1r_B, L1g_B, L1b_B);
}
else
{
localUVW_B = isNoB ? localUVW : localUVW_B;
volumeID_B = isNoB ? volumesCount - 1 : volumeID_B;
LV_SampleVolume(volumeID_B, localUVW_B, L0_B, L1r_B, L1g_B, L1b_B, occlusion_B);
}
occlusion = lerp(occlusion_B, occlusion_A, mask);
occlusion *= mOcclusion;
L0  += lerp(L0_B,  L0_A,  mask);
L1r += lerp(L1r_B, L1r_A, mask);
L1g += lerp(L1g_B, L1g_A, mask);
L1b += lerp(L1b_B, L1b_A, mask);
}
void LV_LightVolumeAdditiveSH(float3 worldPos, inout float3 L0, inout float3 L1r, inout float3 L1g, inout float3 L1b, out float4 occlusion)
{
occlusion = 1;
float4 mOcclusion = 1;
uint additiveCount = min((uint) _UdonLightVolumeAdditiveCount, VRCLV_MAX_VOLUMES_COUNT);
if (additiveCount == 0 && (uint) _UdonPointLightVolumeCount == 0)
return;
uint volumesCount = min((uint) _UdonLightVolumeCount, VRCLV_MAX_VOLUMES_COUNT);
uint maxOverdraw = min((uint) _UdonLightVolumeAdditiveMaxOverdraw, VRCLV_MAX_VOLUMES_COUNT);
uint volumeID_A = -1;
uint volumeID_B = -1;
float3 localUVW   = 0;
float3 localUVW_A = 0;
float3 localUVW_B = 0;
bool isNoA = true;
bool isNoB = true;
uint addVolumesCount = 0;
uint count = min(_UdonLightVolumeOcclusionCount == 0 ? additiveCount : volumesCount, VRCLV_MAX_VOLUMES_COUNT);
[loop] for (uint id = 0;
id < count;
id++)
{
localUVW = LV_LocalFromVolume(id, worldPos);
if (LV_PointLocalAABB(localUVW))
{
if (id < additiveCount)
{
if (addVolumesCount < maxOverdraw)
{
float4 occ;
LV_SampleVolume(id, localUVW, L0, L1r, L1g, L1b, occ);
mOcclusion *= occ;
addVolumesCount++;
}
}
else if (isNoA)
{
volumeID_A = id;
localUVW_A = localUVW;
isNoA = false;
}
else
{
volumeID_B = id;
localUVW_B = localUVW;
isNoB = false;
break;
}
}
}
if (isNoA || _UdonLightVolumeOcclusionCount == 0)
{
occlusion *= mOcclusion;
return;
}
localUVW_A = isNoA ? localUVW : localUVW_A;
volumeID_A = isNoA ? volumesCount - 1 : volumeID_A;
occlusion = LV_SampleVolumeOcclusion(volumeID_A, localUVW_A);
float mask = LV_BoundsMask(localUVW_A, _UdonLightVolumeInvLocalEdgeSmooth[volumeID_A]);
if (mask == 1 || (_UdonLightVolumeSharpBounds && isNoB))
{
occlusion *= mOcclusion;
return;
}
if (isNoB) occlusion = lerp(1, occlusion, mask);
else occlusion = lerp(LV_SampleVolumeOcclusion(volumeID_B, localUVW_B), occlusion, mask);
occlusion *= mOcclusion;
}
float3 LightVolumeSpecular(float3 f0, float smoothness, float3 worldNormal, float3 viewDir, float3 L0, float3 L1r, float3 L1g, float3 L1b)
{
float3 specColor = max(float3(dot(reflect(-L1r, worldNormal), viewDir), dot(reflect(-L1g, worldNormal), viewDir), dot(reflect(-L1b, worldNormal), viewDir)), 0);
float3 rDir = normalize(normalize(L1r) + viewDir);
float3 gDir = normalize(normalize(L1g) + viewDir);
float3 bDir = normalize(normalize(L1b) + viewDir);
float rNh = saturate(dot(worldNormal, rDir));
float gNh = saturate(dot(worldNormal, gDir));
float bNh = saturate(dot(worldNormal, bDir));
float roughness = 1 - smoothness * 0.9f;
float roughExp = roughness * roughness;
float rSpec = LV_DistributionGGX(rNh, roughExp);
float gSpec = LV_DistributionGGX(gNh, roughExp);
float bSpec = LV_DistributionGGX(bNh, roughExp);
float3 specs = (rSpec + gSpec + bSpec) * f0;
float3 coloredSpecs = specs * specColor;
float3 a = coloredSpecs + specs * L0;
float3 b = coloredSpecs * 3;
return max(lerp(a, b, smoothness) * 0.5f, 0.0);
}
float3 LightVolumeSpecular(float3 albedo, float smoothness, float metallic, float3 worldNormal, float3 viewDir, float3 L0, float3 L1r, float3 L1g, float3 L1b)
{
float3 specularf0 = lerp(0.04f, albedo, metallic);
return LightVolumeSpecular(specularf0, smoothness, worldNormal, viewDir, L0, L1r, L1g, L1b);
}
float3 LightVolumeSpecularDominant(float3 f0, float smoothness, float3 worldNormal, float3 viewDir, float3 L0, float3 L1r, float3 L1g, float3 L1b)
{
float3 dominantDir = L1r + L1g + L1b;
float3 dir = normalize(normalize(dominantDir) + viewDir);
float nh = saturate(dot(worldNormal, dir));
float roughness = 1 - smoothness * 0.9f;
float roughExp = roughness * roughness;
float spec = LV_DistributionGGX(nh, roughExp);
return max(spec * L0 * f0, 0.0) * 1.5f;
}
float3 LightVolumeSpecularDominant(float3 albedo, float smoothness, float metallic, float3 worldNormal, float3 viewDir, float3 L0, float3 L1r, float3 L1g, float3 L1b)
{
float3 specularf0 = lerp(0.04f, albedo, metallic);
return LightVolumeSpecularDominant(specularf0, smoothness, worldNormal, viewDir, L0, L1r, L1g, L1b);
}
float3 LightVolumeEvaluate(float3 worldNormal, float3 L0, float3 L1r, float3 L1g, float3 L1b)
{
return float3(LV_EvaluateSH(L0.r, L1r, worldNormal), LV_EvaluateSH(L0.g, L1g, worldNormal), LV_EvaluateSH(L0.b, L1b, worldNormal));
}
void LightVolumeSH(float3 worldPos, out float3 L0, out float3 L1r, out float3 L1g, out float3 L1b, float3 worldPosOffset = 0)
{
L0 = 0;
L1r = 0;
L1g = 0;
L1b = 0;
if (_UdonLightVolumeEnabled == 0)
{
LV_SampleLightProbeDering(L0, L1r, L1g, L1b);
}
else
{
float4 occlusion = 1;
LV_LightVolumeSH(worldPos + worldPosOffset, L0, L1r, L1g, L1b, occlusion);
LV_PointLightVolumeSH(worldPos, occlusion, L0, L1r, L1g, L1b);
}
}
void LightVolumeAdditiveSH(float3 worldPos, out float3 L0, out float3 L1r, out float3 L1g, out float3 L1b, float3 worldPosOffset = 0)
{
L0 = 0;
L1r = 0;
L1g = 0;
L1b = 0;
if (_UdonLightVolumeEnabled != 0)
{
float4 occlusion = 1;
LV_LightVolumeAdditiveSH(worldPos + worldPosOffset, L0, L1r, L1g, L1b, occlusion);
LV_PointLightVolumeSH(worldPos, occlusion, L0, L1r, L1g, L1b);
}
}
float3 LightVolumeSH_L0(float3 worldPos, float3 worldPosOffset = 0)
{
if (_UdonLightVolumeEnabled == 0)
{
return float3(unity_SHAr.w, unity_SHAg.w, unity_SHAb.w);
}
else
{
float3 L0 = 0;
float4 occlusion = 1;
float3 unused_L1;
LV_LightVolumeSH(worldPos + worldPosOffset, L0, unused_L1, unused_L1, unused_L1, occlusion);
LV_PointLightVolumeSH(worldPos, occlusion, L0, unused_L1, unused_L1, unused_L1);
return L0;
}
}
float3 LightVolumeAdditiveSH_L0(float3 worldPos, float3 worldPosOffset = 0)
{
if (_UdonLightVolumeEnabled == 0)
{
return 0;
}
else
{
float3 L0 = 0;
float4 occlusion = 1;
float3 unused_L1;
LV_LightVolumeAdditiveSH(worldPos + worldPosOffset, L0, unused_L1, unused_L1, unused_L1, occlusion);
LV_PointLightVolumeSH(worldPos, occlusion, L0, unused_L1, unused_L1, unused_L1);
return L0;
}
}
float LightVolumesEnabled()
{
return _UdonLightVolumeEnabled;
}
float LightVolumesVersion()
{
return _UdonLightVolumeVersion == 0 ? _UdonLightVolumeEnabled : _UdonLightVolumeVersion;
}
#endif
SamplerState sampler_linear_clamp;
SamplerState sampler_linear_repeat;
SamplerState sampler_trilinear_clamp;
SamplerState sampler_trilinear_repeat;
SamplerState sampler_point_clamp;
SamplerState sampler_point_repeat;
#define DielectricSpec float4(0.04, 0.04, 0.04, 1.0 - 0.04)
#define HALF_PI float(1.5707964)
#define PI float(3.14159265359)
#define TWO_PI float(6.28318530718)
#define PI_OVER_2 1.5707963f
#define PI_OVER_4 0.785398f
#define EPSILON 0.000001f
#define POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex, samplertex, coord, dx, dy) tex.SampleGrad(sampler##samplertex, coord, dx, dy)
#define POI2D_SAMPLE_TEX2D_SAMPLERGRADD(tex, samp, uv, pan, dx, dy) tex.SampleGrad(samp, POI_PAN_UV(uv, pan), dx, dy)
#define POI_PAN_UV(uv, pan) (uv + _Time.x * pan)
#define POI2D_SAMPLER_PAN(tex, texSampler, uv, pan) (UNITY_SAMPLE_TEX2D_SAMPLER(tex, texSampler, POI_PAN_UV(uv, pan)))
#define POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy) (POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex, texSampler, POI_PAN_UV(uv, pan), dx, dy))
#define POI2D_SAMPLER(tex, texSampler, uv) (UNITY_SAMPLE_TEX2D_SAMPLER(tex, texSampler, uv))
#define POI_SAMPLE_1D_X(tex, samp, uv) tex.Sample(samp, float2(uv, 0.5))
#define POI2D_SAMPLER_GRAD(tex, texSampler, uv, dx, dy) (POI2D_SAMPLE_TEX2D_SAMPLERGRAD(tex, texSampler, uv, dx, dy))
#define POI2D_SAMPLER_GRADD(tex, texSampler, uv, dx, dy) tex.SampleGrad(texSampler, uv, dx, dy)
#define POI2D_PAN(tex, uv, pan) (tex2D(tex, POI_PAN_UV(uv, pan)))
#define POI2D(tex, uv) (tex2D(tex, uv))
#define POI_SAMPLE_TEX2D(tex, uv) (UNITY_SAMPLE_TEX2D(tex, uv))
#define POI_SAMPLE_TEX2D_PAN(tex, uv, pan) (UNITY_SAMPLE_TEX2D(tex, POI_PAN_UV(uv, pan)))
#define POI_SAMPLE_CUBE_LOD(tex, sampler, coord, lod) tex.SampleLevel(sampler, coord, lod)
#if defined(UNITY_STEREO_INSTANCING_ENABLED) || defined(UNITY_STEREO_MULTIVIEW_ENABLED)
#define POI_SAMPLE_SCREEN(tex, samp, uv)          tex.Sample(samp, float3(uv, unity_StereoEyeIndex))
#else
#define POI_SAMPLE_SCREEN(tex, samp, uv)          tex.Sample(samp, uv)
#endif
#define POI_SAFE_RGB0 float4(mainTexture.rgb * .0001, 0)
#define POI_SAFE_RGB1 float4(mainTexture.rgb * .0001, 1)
#define POI_SAFE_RGBA mainTexture
#if defined(UNITY_COMPILER_HLSL)
#define PoiInitStruct(type, name) name = (type)0;
#else
#define PoiInitStruct(type, name)
#endif
#define POI_ERROR(poiMesh, gridSize) lerp(float3(1, 0, 1), float3(0, 0, 0), fmod(floor((poiMesh.worldPos.x) * gridSize) + floor((poiMesh.worldPos.y) * gridSize) + floor((poiMesh.worldPos.z) * gridSize), 2) == 0)
#define POI_NAN (asfloat(-1))
#define POI_MODE_OPAQUE 0
#define POI_MODE_CUTOUT 1
#define POI_MODE_FADE 2
#define POI_MODE_TRANSPARENT 3
#define POI_MODE_ADDITIVE 4
#define POI_MODE_SOFTADDITIVE 5
#define POI_MODE_MULTIPLICATIVE 6
#define POI_MODE_2XMULTIPLICATIVE 7
#define POI_MODE_TRANSCLIPPING 9
#ifndef UNITY_SPECCUBE_LOD_STEPS
#define UNITY_SPECCUBE_LOD_STEPS (6)
#endif
#ifndef UNITY_LIGHTING_COMMON_INCLUDED
#define UNITY_LIGHTING_COMMON_INCLUDED
fixed4 _LightColor0;
fixed4 _SpecColor;
struct UnityLight
{
half3 color;
half3 dir;
half ndotl;
}
;
struct UnityIndirect
{
half3 diffuse;
half3 specular;
}
;
struct UnityGI
{
UnityLight light;
UnityIndirect indirect;
}
;
struct UnityGIInput
{
UnityLight light;
float3 worldPos;
half3 worldViewDir;
half atten;
half3 ambient;
#if defined(UNITY_SPECCUBE_BLENDING) || defined(UNITY_SPECCUBE_BOX_PROJECTION) || defined(UNITY_ENABLE_REFLECTION_BUFFERS)
float4 boxMin[2];
#endif
#ifdef UNITY_SPECCUBE_BOX_PROJECTION
float4 boxMax[2];
float4 probePosition[2];
#endif
float4 probeHDR[2];
}
;
#endif
float _GrabMode;
struct Unity_GlossyEnvironmentData
{
half roughness;
half3 reflUVW;
}
;
#ifndef _STOCHASTICMODE_NONE
static float _StochasticDeliotHeitzDensity = 1;
#endif
#if defined(PROP_LIGHTINGAOMAPS)
Texture2D _LightingAOMaps;
#endif
static float4 _LightingAOMaps_ST = float4(1, 1, 0, 0);
static float2 _LightingAOMapsPan = float4(0, 0, 0, 0);
static float _LightingAOMapsUV = 0;
static float _LightDataAOStrengthR = 1;
static float _LightDataAOStrengthG = 0;
static float _LightDataAOStrengthB = 0;
static float _LightDataAOStrengthA = 0;
static float _LightDataAOGlobalMaskR = 0;
static float _LightDataAOGlobalMaskBlendTypeR = 2;
#if defined(PROP_LIGHTINGDETAILSHADOWMAPS)
Texture2D _LightingDetailShadowMaps;
#endif
static float4 _LightingDetailShadowMaps_ST = float4(1, 1, 0, 0);
static float2 _LightingDetailShadowMapsPan = float4(0, 0, 0, 0);
static float _LightingDetailShadowMapsUV = 0;
static float _LightingDetailShadowStrengthR = 1;
static float _LightingDetailShadowStrengthG = 0;
static float _LightingDetailShadowStrengthB = 0;
static float _LightingDetailShadowStrengthA = 0;
static float _LightingAddDetailShadowStrengthR = 1;
static float _LightingAddDetailShadowStrengthG = 0;
static float _LightingAddDetailShadowStrengthB = 0;
static float _LightingAddDetailShadowStrengthA = 0;
static float _LightDataDetailShadowGlobalMaskR = 0;
static float _LightDataDetailShadowGlobalMaskBlendTypeR = 2;
#if defined(PROP_LIGHTINGSHADOWMASKS)
Texture2D _LightingShadowMasks;
#endif
static float4 _LightingShadowMasks_ST = float4(1, 1, 0, 0);
static float2 _LightingShadowMasksPan = float4(0, 0, 0, 0);
static float _LightingShadowMasksUV = 0;
static float _LightingShadowMaskStrengthR = 1;
static float _LightingShadowMaskStrengthG = 0;
static float _LightingShadowMaskStrengthB = 0;
static float _LightingShadowMaskStrengthA = 0;
static float _LightDataShadowMaskGlobalMaskR = 0;
static float _LightDataShadowMaskGlobalMaskBlendTypeR = 2;
static float _Unlit_Intensity = 1;
static float _LightingColorMode = 0;
static float _LightingMapMode = 0;
#if defined(PROP_LIGHTDATASDFMAP)
Texture2D _LightDataSDFMap;
static float4 _LightDataSDFMap_ST = float4(1, 1, 0, 0);
static float2 _LightDataSDFMapPan = float4(0, 0, 0, 0);
static float _LightDataSDFMapUV = 0;
static float _LightDataSDFMapLOD = 0;
static float _LightDataSDFBlendY = 1;
#endif
static float _LightingDirectionMode = 0;
static float3 _LightngForcedDirection = float4(0, 0, 0, 1);
static float _LightingViewDirOffsetPitch = 0;
static float _LightingViewDirOffsetYaw = 0;
static float _LightingIndirectUsesNormals = 0;
static float _LightingCapEnabled = 1;
static float _LightingForceColorEnabled = 0;
static float3 _LightingForcedColor = float4(1, 1, 1, 1);
static float _LightingForcedColorThemeIndex = 0;
static float _LightingCastedShadows = 0;
static float _LightingAdditiveEnable = 1;
static float _LightingAdditiveLimited = 1;
static float _LightingAdditiveCastedShadows = 1;
static float _LightingAdditivePassthrough = 0.5;
static float _DisableDirectionalInAdd = 1;
static float _LightingVertexLightingEnabled = 1;
static float _LightingMirrorVertexLightingEnabled = 1;
static float _LightDataDebugEnabled = 0;
static float _LightingDebugVisualize = 0;
uint _UdonForceSceneLighting;
static float _ColorThemeIndex = 0;
#ifdef UNITY_STEREO_INSTANCING_ENABLED
#define STEREO_UV(uv) float3(uv, unity_StereoEyeIndex)
Texture2DArray<float> _CameraDepthTexture;
#else
#define STEREO_UV(uv) uv
Texture2D<float> _CameraDepthTexture;
#endif
float SampleScreenDepth(float2 uv)
{
uv.y = _ProjectionParams.x * 0.5 + 0.5 - uv.y * _ProjectionParams.x;
return _CameraDepthTexture.SampleLevel(sampler_point_clamp, STEREO_UV(uv), 0);
}
bool DepthTextureExists()
{
#ifdef UNITY_STEREO_INSTANCING_ENABLED
float3 dTexDim;
_CameraDepthTexture.GetDimensions(dTexDim.x, dTexDim.y, dTexDim.z);
#else
float2 dTexDim;
_CameraDepthTexture.GetDimensions(dTexDim.x, dTexDim.y);
#endif
return dTexDim.x > 16;
}
static float _MainPixelMode = 0;
static float4 _MainTex_ST = float4(1, 1, 0, 0);
static float2 _MainTexPan = float4(0, 0, 0, 0);
static float _MainTexUV = 0;
static float _MainTexStochastic = 0;
static float _MainIgnoreTexAlpha = 0;
static float2 _BumpMapPan = float4(0, 0, 0, 0);
static float _BumpMapUV = 0;
static float _BumpMapStochastic = 0;
static float2 _AlphaMaskPan = float4(0, 0, 0, 0);
static float _AlphaMaskUV = 0;
static float _AlphaMaskInvert = 0;
static float _AlphaMaskBlendStrength = 1;
static float _AlphaMaskValue = 0;
static float _MainColorAdjustToggle = 1;
// Skipped 1 lines | #if defined(PROP_MAINCOLORADJUSTTEXTURE) || !defined(OPTIMIZER_ENABLED)
static float4 _MainColorAdjustTexture_ST = float4(1, 1, 0, 0);
static float2 _MainColorAdjustTexturePan = float4(0, 0, 0, 0);
static float _MainColorAdjustTextureUV = 0;
static float _MainHueShiftColorSpace = 0;
static float _MainHueShiftSelectOrShift = 1;
static float _MainHueShiftReplace = 1;
static float _MainHueShiftSpeed = 0;
static float _MainBrightness = 0;
static float _MainGamma = 1;
static float _MainHueALCTEnabled = 0;
static float _MainALHueShiftBand = 0;
static float _MainALHueShiftCTIndex = 0;
static float _MainHueALMotionSpeed = 1;
static float _MainHueGlobalMask = 0;
static float _MainHueGlobalMaskBlendType = 2;
static float _MainSaturationGlobalMask = 0;
static float _MainSaturationGlobalMaskBlendType = 2;
static float _MainBrightnessGlobalMask = 0;
static float _MainBrightnessGlobalMaskBlendType = 2;
static float _MainGammaGlobalMask = 0;
static float _MainGammaGlobalMaskBlendType = 2;
#if defined(PROP_MAINGRADATIONTEX)
Texture2D _MainGradationTex;
#endif
static float _ColorGradingToggle = 0;
static float _MainGradationStrength = 0;
static float _AlphaMod = 0;
float _AlphaPremultiply;
float _AlphaBoostFA;
static float _AlphaGlobalMask = 0;
static float _AlphaGlobalMaskBlendType = 2;
static float _IgnoreFog = 0;
static float _RenderingReduceClipDistance = 0;
static int _FlipBackfaceNormals = 1;
static float _AddBlendOp = 4;
static float4 _GlobalThemeColor0 = float4(1, 1, 1, 1);
static float4 _GlobalThemeColor1 = float4(1, 1, 1, 1);
static float4 _GlobalThemeColor2 = float4(1, 1, 1, 1);
static float4 _GlobalThemeColor3 = float4(1, 1, 1, 1);
static float _GlobalThemeHue0 = 0;
static float _GlobalThemeHue1 = 0;
static float _GlobalThemeHue2 = 0;
static float _GlobalThemeHue3 = 0;
static float _GlobalThemeHueSpeed0 = 0;
static float _GlobalThemeHueSpeed1 = 0;
static float _GlobalThemeHueSpeed2 = 0;
static float _GlobalThemeHueSpeed3 = 0;
static float _GlobalThemeSaturation0 = 0;
static float _GlobalThemeSaturation1 = 0;
static float _GlobalThemeSaturation2 = 0;
static float _GlobalThemeSaturation3 = 0;
static float _GlobalThemeValue0 = 0;
static float _GlobalThemeValue1 = 0;
static float _GlobalThemeValue2 = 0;
static float _GlobalThemeValue3 = 0;
int _GlobalMaskVertexColorLinearSpace;
static float _StereoEnabled = 0;
static float _PolarUV = 0;
static float2 _PolarCenter = float4(0.5, 0.5, 0, 0);
static float _PolarRadialScale = 1;
static float _PolarLengthScale = 1;
static float _PolarSpiralPower = 0;
static float _PanoUseBothEyes = 1;
static float _UVModWorldPos0 = 0;
static float _UVModWorldPos1 = 2;
static float _UVModLocalPos0 = 0;
static float _UVModLocalPos1 = 1;
static float _ShadowStrength = 1;
static float _LightingIgnoreAmbientColor = 1;
static float3 _LightingShadowColor = float4(1, 1, 1, 1);
static float _ShadingRampedLightMapApplyGlobalMaskIndex = 0;
static float _ShadingRampedLightMapApplyGlobalMaskBlendType = 2;
static float _ShadingRampedLightMapInverseApplyGlobalMaskIndex = 0;
static float _ShadingRampedLightMapInverseApplyGlobalMaskBlendType = 2;
static float _ForceFlatRampedLightmap = 1;
static float _LightingAdditiveType = 3;
static float _LightingAdditiveGradientStart = 0;
static float _LightingAdditiveGradientEnd = 0.5;
float _LightingAdditiveDetailStrength;
#if defined(PROP_DECALMASK)
static float4 _DecalMask_ST = float4(1, 1, 0, 0);
static float2 _DecalMaskPan = float4(0, 0, 0, 0);
static float _DecalMaskUV = 0;
#endif
static float _DecalTPSDepthMaskEnabled = 0;
static float _Decal0TPSMaskStrength = 1;
static float _Decal1TPSMaskStrength = 1;
static float _Decal2TPSMaskStrength = 1;
static float _Decal3TPSMaskStrength = 1;
sampler2D _Udon_VideoTex;
float4 _Udon_VideoTex_TexelSize;
#ifdef POI_AUDIOLINK
static half _AudioLinkDecal0ScaleBand = 0;
static float4 _AudioLinkDecal0Scale = float4(0, 0, 0, 0);
static half _AudioLinkDecal0RotationBand = 0;
static float2 _AudioLinkDecal0Rotation = float4(0, 0, 0, 0);
static half _AudioLinkDecal0AlphaBand = 0;
static float2 _AudioLinkDecal0Alpha = float4(0, 0, 0, 0);
static half _AudioLinkDecal0EmissionBand = 0;
static float2 _AudioLinkDecal0Emission = float4(0, 0, 0, 0);
static float _DecalRotationCTALBand0 = 0;
static float _DecalRotationCTALSpeed0 = 0;
static float _DecalRotationCTALType0 = 0;
static float _AudioLinkDecalCC0 = 0;
static float _AudioLinkDecal0SideBand = 0;
static float4 _AudioLinkDecal0SideMin = float4(0, 0, 0, 0);
static float4 _AudioLinkDecal0SideMax = float4(0, 0, 0, 0);
static float2 _AudioLinkDecal0ChannelSeparation = float4(0, 0, 0, 0);
static float _AudioLinkDecal0ChannelSeparationBand = 0;
#endif
static float _Decal0VideoFitToScale = 1;
static float _Decal0VideoAspectFix = 0;
static float _Decal0VideoEmissionStrength = 0;
static float _Decal0VideoEnabled = 0;
static float _Decal0UseDecalAlpha = 0;
static float _Decal0OnlyVideo = 0;
static float _Decal0FaceMask = 0;
static float _Decal0MaskChannel = 0;
static float _Decal0GlobalMask = 0;
static float _Decal0GlobalMaskBlendType = 2;
static float _Decal0ApplyGlobalMaskIndex = 0;
static float _Decal0ApplyGlobalMaskBlendType = 0;
static float4 _DecalTexture_ST = float4(1, 1, 0, 0);
static float2 _DecalTexturePan = float4(0, 0, 0, 0);
static float _DecalTextureUV = 0;
static float _DecalColorThemeIndex = 0;
static float _DecalTiled = 0;
static float _DecalMirroredUVMode = 0;
static float _DecalSymmetryMode = 0;
static float _DecalBlendType = 0;
static half _DecalRotation = 0;
static half3 _DecalScale = float4(1, 1, 1, 0);
static float4 _DecalSideOffset = float4(0, 0, 0, 0);
static half2 _DecalPosition = float4(0.5, 0.5, 0, 0);
static half _DecalRotationSpeed = 0;
static float _DecalEmissionStrength = 0;
static float _DecalOverrideAlpha = 0;
static float _DecalHueShiftColorSpace = 0;
static float _DecalHueShiftSelectOrShift = 1;
static float _DecalHueShiftEnabled = 0;
static float _DecalHueShift = 0;
static float _DecalHueShiftSpeed = 0;
static float _Decal0Depth = 0;
static float _Decal0HueAngleStrength = 0;
static float _Decal0ChannelSeparationEnable = 0;
static float _Decal0ChannelSeparation = 0;
static float _Decal0ChannelSeparationPremultiply = 0;
static float _Decal0ChannelSeparationHue = 0;
static float _Decal0ChannelSeparationVertical = 0;
static float _Decal0ChannelSeparationAngleStrength = 0;
static float _Decal0OverrideAlphaMode = 0;
Texture2D _Matcap;
static float4 _Matcap_ST = float4(1, 1, 0, 0);
static float4 _Matcap_TexelSize = float4(1.0 / 256, 1.0 / 256, 256, 256);
static float2 _MatcapPan = float4(0, 0, 0, 0);
float _MatcapUV;
// Skipped 5 lines | #if defined(PROP_MATCAPMASK) || !defined(OPTIMIZER_ENABLED)
static float _Matcap0CircleMaskEnabled = 0;
static float _Matcap0CircleMaskBorder = 0.45;
static float _Matcap0CircleMaskBlur = 0.1;
float _Matcap0LightVsReflection;
static float _MatcapUVToBlend = 1;
static float4 _MatCapBlendUV1 = float4(0, 0, 0, 0);
static float _MatcapUVMode = 1;
static float _MatcapMaskInvert = 0;
static float _MatcapMaskGlobalMask = 0;
static float _MatcapMaskGlobalMaskBlendType = 2;
static float _MatcapBorder = 0.5;
static float _MatcapRotation = 0;
static float _MatcapSmoothness = 1;
static float _MatcapMaskSmoothnessChannel = 3;
static float _MatcapMaskSmoothnessApply = 0;
static float4 _MatcapColor = float4(1, 1, 1, 1);
static float _MatcapBaseColorMix = 0;
static float _MatcapLightColorMix = 0;
static float _MatcapColorThemeIndex = 0;
static float _MatcapIntensity = 1;
static float _MatcapReplace = 0;
static float _MatcapAdd = 0;
static float _MatcapAddToLight = 0;
static float _MatcapMixed = 0;
static float _MatcapScreen = 0;
static float _MatcapAlphaOverride = 0;
static float _MatcapEnable = 1;
static float _MatcapLightMask = 0;
static float _MatcapEmissionStrength = 0;
static float _MatcapNormal = 1;
static float _MatcapHueShiftEnabled = 0;
static float _MatcapHueShiftColorSpace = 0;
static float _MatcapHueSelectOrShift = 1;
static float _MatcapHueShiftSpeed = 0;
static float _MatcapHueShift = 0;
static int _MatcapApplyToAlphaEnabled = 0;
static int _MatcapApplyToAlphaSourceBlend = 0;
static int _MatcapApplyToAlphaBlendType = 0;
static float _MatcapApplyToAlphaBlending = 1;
static float _MatcapTPSDepthEnabled = 0;
static float _MatcapTPSMaskStrength = 1;
static float _Matcap0ALEnabled = 0;
static float _Matcap0ALAlphaAddBand = 0;
static float4 _Matcap0ALAlphaAdd = float4(0, 0, 0, 0);
static float _Matcap0ALEmissionAddBand = 0;
static float4 _Matcap0ALEmissionAdd = float4(0, 0, 0, 0);
static float _Matcap0ALIntensityAddBand = 0;
static float4 _Matcap0ALIntensityAdd = float4(0, 0, 0, 0);
static float _Matcap0ALChronoPanType = 0;
static float _Matcap0ALChronoPanBand = 0;
static float _Matcap0ALChronoPanSpeed = 0;
struct MatcapAudioLinkData
{
float matcapALEnabled;
float matcapALAlphaAddBand;
float4 matcapALAlphaAdd;
float matcapALEmissionAddBand;
float4 matcapALEmissionAdd;
float matcapALIntensityAddBand;
float4 matcapALIntensityAdd;
float matcapALChronoPanType;
float matcapALChronoPanBand;
float matcapALChronoPanSpeed;
}
;
TextureCube _CubeMap;
static float3 _CubeMapRotation = float4(0, 0, 0, 0);
static float3 _CubeMapRotationPan = float4(0, 0, 0, 0);
static float4 _CubeMapMask_ST = float4(1, 1, 0, 0);
static float2 _CubeMapMaskPan = float4(0, 0, 0, 0);
static float _CubeMapMaskUV = 0;
static float _CubeMapMaskChannel = 0;
static float _CubeMapUVMode = 1;
static float _CubeMapWorldNormalsStrength = 1;
static float _CubeMapMaskGlobalMask = 0;
static float _CubeMapMaskGlobalMaskBlendType = 2;
static float _CubeMapColorThemeIndex = 0;
static float _CubeMapIntensity = 1;
static float _CubemapBlendType = 0;
float _CubeMapEnable;
static float _CubeMapLightMask = 0;
static float _CubeMapEmissionStrength = 0;
static float _CubeMapNormal = 1;
static float _CubeMapHueShiftEnabled = 1;
static float _CubeMapHueShiftSpeed = 0;
static float _CubeMapHueShiftColorSpace = 0;
static float _CubeMapHueSelectOrShift = 1;
static float _CubeMapSaturation = 1;
static float _CubeMapBrightness = 0;
static float _CubeMapContrast = 1;
static float _CubeMapSmoothness = 1;
static float _Is_NormalMapToRimLight = 1;
static float4 _RimLightColor = float4(0, 0, 0, 1);
static float _RimLightColorThemeIndex = 0;
static float _RimLightingInvert = 0;
static float _RimWidth = 1;
static float _RimStrength = 0;
static float _RimBaseColorMix = 0;
static float _EnableRimLighting = 1;
float _RimWidthNoiseStrength;
static float4 _RimShadowAlpha = float4(0, 0, 0, 1);
static float _RimShadowWidth = 0;
static float _RimPoiBlendMode = 2;
static float _RimShadowToggle = 0;
static float _RimPower = 1;
static float _RimShadowMaskStrength = 1;
static float _RimShadowMaskRampType = 0;
static float _RimShadowMaskInvert = 0;
static float _RimBrightness = 1;
// Skipped 1 lines | #if defined(PROP_RIMTEX) || !defined(OPTIMIZER_ENABLED)
static float4 _RimTex_ST = float4(1, 1, 0, 0);
static float2 _RimTexPan = float4(0, 0, 0, 0);
static float _RimTexUV = 0;
// Skipped 1 lines | #if defined(PROP_RIMMASK) || !defined(OPTIMIZER_ENABLED)
static float4 _RimMask_ST = float4(1, 1, 0, 0);
static float2 _RimMaskPan = float4(0, 0, 0, 0);
static float _RimMaskUV = 0;
static float _RimMaskChannel = 0;
static float _RimMaskInvert = 0;
static float _RimBiasIntensity = 0;
static int _RimApplyAlpha = 0;
static float _RimApplyAlphaBlend = 1;
#ifdef POI_AUDIOLINK
static half _AudioLinkRimWidthBand = 0;
static float2 _AudioLinkRimWidthAdd = float4(0, 0, 0, 0);
static half _AudioLinkRimEmissionBand = 0;
static float2 _AudioLinkRimEmissionAdd = float4(0, 0, 0, 0);
static half _AudioLinkRimBrightnessBand = 0;
static float2 _AudioLinkRimBrightnessAdd = float4(0, 0, 0, 0);
#endif
static float _RimGlobalMask = 0;
static float _RimGlobalMaskBlendType = 2;
static float _RimApplyGlobalMaskIndex = 0;
static float _RimApplyGlobalMaskBlendType = 2;
static float _RimHueShiftEnabled = 0;
static float _RimHueShiftColorSpace = 0;
static float _RimHueSelectOrShift = 1;
static float _RimHueShiftSpeed = 0;
static float _RimHueShift = 0;
// Skipped 2 lines | #if defined(PROP_MOCHIEMETALLICMAPS) || !defined(OPTIMIZER_ENABLED)
static float4 _MochieMetallicMaps_ST = float4(1, 1, 0, 0);
static float2 _MochieMetallicMapsPan = float4(0, 0, 0, 0);
static float _MochieMetallicMapsUV = 0;
static float _MochieMetallicMapsStochastic = 0;
static float _MochieMetallicMapInvert = 0;
static float _MochieRoughnessMapInvert = 0;
static float _MochieReflectionMaskInvert = 0;
static float _MochieSpecularMaskInvert = 0;
static float _MochieMetallicMapsMetallicChannel = 0;
static float _MochieMetallicMapsRoughnessChannel = 1;
static float _MochieMetallicMapsReflectionMaskChannel = 2;
static float _MochieMetallicMapsSpecularMaskChannel = 3;
static float _PBRNormalSelect = 1;
static float _MochieReflectionTintThemeIndex = 0;
static float _MochieSpecularTintThemeIndex = 0;
static float _MochieReflectionStrength = 0;
static float _MochieSpecularStrength = 1;
static float4 _MochieSpecularTint = float4(1, 1, 1, 1);
static float4 _MochieReflectionTint = float4(1, 1, 1, 1);
static float _MochieLitFallback = 1;
static float _IgnoreCastedShadows = 0;
static float _PBRSplitMaskSample = 0;
static float _PBRSplitMaskStochastic = 0;
static float4 _PBRMaskScaleTiling = float4(1, 1, 0, 0);
static float _MochieMetallicMasksUV = 0;
static float4 _MochieMetallicMasksPan = float4(0, 0, 0, 0);
static float _Specular2ndLayer = 0;
static float _MochieSpecularStrength2 = 1;
static float _MochieRoughnessMultiplier2 = 1;
static float _RefSpecFresnelStrength = 0.5;
static float _SFExposureOcclusion = 0;
TextureCube _MochieReflCube;
float4 _MochieReflCube_HDR;
static float _MochieForceFallback = 0;
static float _MochieGSAAEnabled = 1;
static float _PoiGSAAVariance = 0.15;
static float _PoiGSAAThreshold = 0.1;
static float _BRDFTPSReflectionMaskStrength = 1;
static float _BRDFTPSSpecularMaskStrength = 1;
static float _BRDFTPSDepthEnabled = 0;
static float _MochieMetallicGlobalMask = 0;
static float _MochieMetallicGlobalMaskBlendType = 2;
static float _MochieSmoothnessGlobalMask = 0;
static float _MochieSmoothnessGlobalMaskBlendType = 2;
static float _MochieReflectionStrengthGlobalMask = 0;
static float _MochieReflectionStrengthGlobalMaskBlendType = 2;
static float _MochieSpecularStrengthGlobalMask = 0;
static float _MochieSpecularStrengthGlobalMaskBlendType = 2;
static float _PPLightingMultiplier = 1;
static float _PPLightingAddition = 0;
static float _PPEmissionMultiplier = 1;
static float _PPFinalColorMultiplier = 1;
static float _FXProximityColor = 1;
static float _FXProximityColorType = 1;
static float3 _FXProximityColorMinColor = float4(0, 0, 0, 1);
static float3 _FXProximityColorMaxColor = float4(1, 1, 1, 1);
static float _FXProximityColorMinColorThemeIndex = 0;
static float _FXProximityColorMaxColorThemeIndex = 0;
static float _FXProximityColorMinDistance = 0;
static float _FXProximityColorMaxDistance = 0.15;
static float _FXProximityColorBackFace = 0;
static float _UzumoreEnabled = 1;
static float _UzumoreAmount = 0.1;
static float _UzumoreBias = 0.001;
// Skipped 1 lines | #if defined(PROP_UZUMOREMASK) || !defined(OPTIMIZER_ENABLED)
static float _UzumoreMaskUV = 3;
static float4 _SSAOHSV = float4(0, 0, 0, 0);
static float _SSAOBias = 0.003;
static float _SSAOEnabled = 1;
static float _SSAORadius = 0.002;
static float _SSAOQuality = 2.4;
static float _SSAOBlendType = 2;
static float _SSAOColorThemeIndex = 0;
static float _SSAOCenterImportance = 1;
static float4 _SSAOMaxDistanceFalloff = float4(0.01, 0.1, 1, 1);
static float4 _SSAOColor = float4(0, 0, 0, 1);
static float _SSAOUseSurfaceColor = 0;
static float _SSAOHideByRampedLightMap = 0;
static float _SSAORandomScale = 0;
static float _SSAOCone = 0;
static float _SSAOUseNormals = 0;
// Skipped 4 lines | #if defined(PROP_SSAOCOLORMAP) || !defined(OPTIMIZER_ENABLED)
// Skipped 5 lines | #if defined(PROP_SSAOMASK) || !defined(OPTIMIZER_ENABLED)
static float _SSAOAlphaFade = 1;
static float _SSAOFalloffStart = 6;
static float _SSAOFalloffEnd = 8;
static float _SSAOGlobalMaskIndex = 0;
static float _SSAOGlobalMaskBlendType = 2;
static float _SSAOApplyGlobalMaskIndex = 0;
static float _SSAOApplyGlobalMaskBlendType = 0;
struct appdata
{
float4 vertex : POSITION;
float3 normal : NORMAL;
float4 tangent : TANGENT;
float4 color : COLOR;
//float4 uv0 : TEXCOORD0;
float2 uv1 : TEXCOORD1;
float2 uv2 : TEXCOORD2;
float2 uv3 : TEXCOORD3;
uint vertexId : SV_VertexID;
UNITY_VERTEX_INPUT_INSTANCE_ID
float4 uv0 : TEXCOORD0;
}
;
struct tessellatedAppData
{
float4 vertex : POSITION;
float3 normal : NORMAL;
float4 tangent : TANGENT;
float4 color : COLOR;
float2 uv0 : TEXCOORD0;
float2 uv1 : TEXCOORD1;
float2 uv2 : TEXCOORD2;
float2 uv3 : TEXCOORD3;
uint vertexId : TEXCOORD4;
UNITY_VERTEX_INPUT_INSTANCE_ID
}
;
struct VertexOut
{
float4 pos : SV_POSITION;
float4 uv[2] : TEXCOORD0;
float3 normal : TEXCOORD2;
float4 tangent : TEXCOORD3;
float4 worldPos : TEXCOORD4;
float4 localPos : TEXCOORD5;
float4 vertexColor : TEXCOORD6;
float4 lightmapUV : TEXCOORD7;
float worldDir : TEXCOORD8;
float2 fogData: TEXCOORD10;
UNITY_SHADOW_COORDS(12) UNITY_VERTEX_INPUT_INSTANCE_ID UNITY_VERTEX_OUTPUT_STEREO
}
;
struct PoiMesh
{
float3 normals[2];
float3 objNormal;
float3 tangentSpaceNormal;
float3 binormal[2];
float3 tangent[2];
float3 worldPos;
float3 localPos;
float3 objectPosition;
float isFrontFace;
float4 vertexColor;
float4 lightmapUV;
float2 uv[10];
float2 parallaxUV;
float2 dx;
float2 dy;
uint isRightHand;
}
;
struct PoiCam
{
float3 viewDir;
float3 forwardDir;
float3 worldPos;
float distanceToVert;
float4 clipPos;
float4 screenSpacePosition;
float3 reflectionDir;
float3 vertexReflectionDir;
float3 tangentViewDir;
float4 posScreenSpace;
float2 posScreenPixels;
float2 screenUV;
float vDotN;
float4 worldDirection;
}
;
struct PoiMods
{
float4 Mask;
float audioLink[5];
float audioLinkAvailable;
float audioLinkVersion;
float4 audioLinkTexture;
float2 detailMask;
float2 backFaceDetailIntensity;
float globalEmission;
float4 globalColorTheme[12];
float globalMask[16];
float ALTime[8];
}
;
struct PoiLight
{
float3 direction;
float nDotVCentered;
float attenuation;
float attenuationStrength;
float3 directColor;
float3 indirectColor;
float occlusion;
float shadowMask;
float detailShadow;
float3 halfDir;
float lightMap;
float lightMapNoAttenuation;
float3 rampedLightMap;
float vertexNDotL;
float nDotL;
float nDotV;
float vertexNDotV;
float nDotH;
float vertexNDotH;
float lDotv;
float lDotH;
float nDotLSaturated;
float nDotLNormalized;
#ifdef POI_PASS_ADD
float additiveShadow;
#endif
float3 finalLighting;
float3 finalLightAdd;
float3 LTCGISpecular;
float3 LTCGIDiffuse;
float directLuminance;
float indirectLuminance;
float finalLuminance;
#if defined(VERTEXLIGHT_ON)
float4 vDotNL;
float4 vertexVDotNL;
float3 vColor[4];
float4 vCorrectedDotNL;
float4 vAttenuation;
float4 vSaturatedDotNL;
float3 vPosition[4];
float3 vDirection[4];
float3 vFinalLighting;
float3 vHalfDir[4];
half4 vDotNH;
half4 vertexVDotNH;
half4 vDotLH;
#endif
}
;
struct PoiVertexLights
{
float3 direction;
float3 color;
float attenuation;
}
;
struct PoiFragData
{
float smoothness;
float smoothness2;
float metallic;
float specularMask;
float reflectionMask;
float3 baseColor;
float3 finalColor;
float alpha;
float3 emission;
float toggleVertexLights;
}
;
float4 poiTransformClipSpacetoScreenSpaceFrag(float4 clipPos)
{
float4 positionSS = float4(clipPos.xyz * clipPos.w, clipPos.w);
positionSS.xy = positionSS.xy / _ScreenParams.xy;
return positionSS;
}
static float4 PoiSHAr = 0;
static float4 PoiSHAg = 0;
static float4 PoiSHAb = 0;
static float4 PoiSHBr = 0;
static float4 PoiSHBg = 0;
static float4 PoiSHBb = 0;
static float4 PoiSHC  = 0;
half3 PoiSHEval_L0L1(half4 normal)
{
half3 x;
x.r = dot(PoiSHAr, normal);
x.g = dot(PoiSHAg, normal);
x.b = dot(PoiSHAb, normal);
return x;
}
half3 PoiSHEval_L2(half4 normal)
{
half3 x1;
half3 x2;
half4 vB = normal.xyzz * normal.yzzx;
x1.r = dot(PoiSHBr, vB);
x1.g = dot(PoiSHBg, vB);
x1.b = dot(PoiSHBb, vB);
half  vC = normal.x*normal.x - normal.y*normal.y;
x2    = PoiSHC.rgb * vC;
return x1 + x2;
}
half3 PoiShadeSH9 (half4 normal)
{
half3 res = PoiSHEval_L0L1(normal);
res += PoiSHEval_L2(normal);
// Skipped 1 lines | #ifdef UNITY_COLORSPACE_GAMMA
return res;
}
inline half4 Pow5(half4 x)
{
return x * x * x * x * x;
}
inline half3 FresnelLerp(half3 F0, half3 F90, half cosA)
{
half t = Pow5(1 - cosA);
return lerp(F0, F90, t);
}
inline half3 FresnelTerm(half3 F0, half cosA)
{
half t = Pow5(1 - cosA);
return F0 + (1 - F0) * t;
}
half perceptualRoughnessToMipmapLevel(half perceptualRoughness)
{
return perceptualRoughness * UNITY_SPECCUBE_LOD_STEPS;
}
half3 Unity_GlossyEnvironment(UNITY_ARGS_TEXCUBE(tex), half4 hdr, Unity_GlossyEnvironmentData glossIn)
{
half perceptualRoughness = glossIn.roughness  ;
// Expected defined at 0, got 0
#if 0
float m = PerceptualRoughnessToRoughness(perceptualRoughness);
const float fEps = 1.192092896e-07F;
float n = (2.0 / max(fEps, m * m)) - 2.0;
n /= 4;
perceptualRoughness = pow(2 / (n + 2), 0.25);
#else
perceptualRoughness = perceptualRoughness * (1.7 - 0.7 * perceptualRoughness);
#endif
half mip = perceptualRoughnessToMipmapLevel(perceptualRoughness);
half3 R = glossIn.reflUVW;
half4 rgbm = UNITY_SAMPLE_TEXCUBE_LOD(tex, R, mip);
return DecodeHDR(rgbm, hdr);
}
half3 UnpackScaleNormalDXT5nm(half4 packednormal, half bumpScale)
{
half3 normal;
normal.xy = (packednormal.wy * 2 - 1);
// Expected defined at 1, got SHADER_TAR
// Expected defined at 1, got SHADER_TAR
#if (SHADER_TARGET >= 30)
normal.xy *= bumpScale;
#endif
normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));
return normal;
}
half3 LerpWhiteTo(half3 b, half t)
{
half oneMinusT = 1 - t;
return half3(oneMinusT, oneMinusT, oneMinusT) + b * t;
}
inline float GGXTerm(float NdotH, float roughness)
{
float a2 = roughness * roughness;
float d = (NdotH * a2 - NdotH) * NdotH + 1.0f;
return UNITY_INV_PI * a2 / (d * d + 1e-7f);
}
Unity_GlossyEnvironmentData UnityGlossyEnvironmentSetup(half Smoothness, half3 worldViewDir, half3 Normal, half3 fresnel0)
{
Unity_GlossyEnvironmentData g;
g.roughness  = 1 - Smoothness;
g.reflUVW = reflect(-worldViewDir, Normal);
return g;
}
half3 UnpackScaleNormalRGorAG(half4 packednormal, half bumpScale)
{
#if defined(UNITY_NO_DXT5nm)
half3 normal = packednormal.xyz * 2 - 1;
// Expected defined at 1, got SHADER_TAR
// Expected defined at 1, got SHADER_TAR
#if (SHADER_TARGET >= 30)
normal.xy *= bumpScale;
#endif
return normal;
#elif defined(UNITY_ASTC_NORMALMAP_ENCODING)
half3 normal;
normal.xy = (packednormal.wy * 2 - 1);
normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));
normal.xy *= bumpScale;
return normal;
#else
packednormal.x *= packednormal.w;
half3 normal;
normal.xy = (packednormal.xy * 2 - 1);
// Expected defined at 1, got SHADER_TAR
// Expected defined at 1, got SHADER_TAR
#if (SHADER_TARGET >= 30)
normal.xy *= bumpScale;
#endif
normal.z = sqrt(1.0 - saturate(dot(normal.xy, normal.xy)));
return normal;
#endif
}
half3 UnpackScaleNormal(half4 packednormal, half bumpScale)
{
return UnpackScaleNormalRGorAG(packednormal, bumpScale);
}
half3 BlendNormals(half3 n1, half3 n2)
{
return normalize(half3(n1.xy + n2.xy, n1.z * n2.z));
}
inline float2 Pow4(float2 x)
{
return x * x * x * x;
}
inline float3 Unity_SafeNormalize(float3 inVec)
{
float dp3 = max(0.001f, dot(inVec, inVec));
return inVec * rsqrt(dp3);
}
inline float3 BoxProjectedCubemapDirection(float3 worldRefl, float3 worldPos, float4 cubemapCenter, float4 boxMin, float4 boxMax)
{
if (cubemapCenter.w > 0.0)
{
float3 nrdir = normalize(worldRefl);
// Expected defined at 0, got 1
#if 1
float3 rbmax = (boxMax.xyz - worldPos) / nrdir;
float3 rbmin = (boxMin.xyz - worldPos) / nrdir;
float3 rbminmax = (nrdir > 0.0f) ? rbmax : rbmin;
#else
float3 rbmax = (boxMax.xyz - worldPos);
float3 rbmin = (boxMin.xyz - worldPos);
float3 select = step(float3(0, 0, 0), nrdir);
float3 rbminmax = lerp(rbmax, rbmin, select);
rbminmax /= nrdir;
#endif
float fa = min(min(rbminmax.x, rbminmax.y), rbminmax.z);
worldPos -= cubemapCenter.xyz;
worldRefl = worldPos + nrdir * fa;
}
return worldRefl;
}
inline half3 UnityGI_IndirectSpecular(UnityGIInput data, half occlusion, Unity_GlossyEnvironmentData glossIn)
{
half3 specular;
#ifdef UNITY_SPECCUBE_BOX_PROJECTION
half3 originalReflUVW = glossIn.reflUVW;
glossIn.reflUVW = BoxProjectedCubemapDirection(originalReflUVW, data.worldPos, data.probePosition[0], data.boxMin[0], data.boxMax[0]);
#endif
specular = unity_IndirectSpecColor.rgb;
// Skipped 19 lines
return specular * occlusion;
}
inline half3 UnityGI_IndirectSpecular(UnityGIInput data, half occlusion, half3 normalWorld, Unity_GlossyEnvironmentData glossIn)
{
return UnityGI_IndirectSpecular(data, occlusion, glossIn);
}
#ifndef glsl_mod
#define glsl_mod(x, y) (((x) - (y) * floor((x) / (y))))
#endif
uniform float random_uniform_float_only_used_to_stop_compiler_warnings = 0.0f;
float2 poiUV(float2 uv, float4 tex_st)
{
return uv * tex_st.xy + tex_st.zw;
}
float2 vertexUV(in VertexOut o, int index)
{
switch(index)
{
case 0:
return o.uv[0].xy;
case 1:
return o.uv[0].zw;
case 2:
return o.uv[1].xy;
case 3:
return o.uv[1].zw;
default:
return o.uv[0].xy;
}
}
float2 vertexUV(in appdata v, int index)
{
switch(index)
{
case 0:
return v.uv0.xy;
case 1:
return v.uv1.xy;
case 2:
return v.uv2.xy;
case 3:
return v.uv3.xy;
default:
return v.uv0.xy;
}
}
float calculateluminance(float3 color)
{
return color.r * 0.299 + color.g * 0.587 + color.b * 0.114;
}
float dotToDegrees(float dot)
{
dot = clamp(dot, -1.0, 1.0);
return degrees(acos(dot));
}
float dotToDegrees(float3 a, float3 b)
{
return dotToDegrees(dot(normalize(a), normalize(b)));
}
float _VRChatCameraMode;
float _VRChatMirrorMode;
float VRCCameraMode()
{
return _VRChatCameraMode;
}
float VRCMirrorMode()
{
return _VRChatMirrorMode;
}
bool IsInMirror()
{
return unity_CameraProjection[2][0] != 0.f || unity_CameraProjection[2][1] != 0.f;
}
bool IsOrthographicCamera()
{
return unity_OrthoParams.w == 1 || UNITY_MATRIX_P[3][3] == 1;
}
float shEvaluateDiffuseL1Geomerics_local(float L0, float3 L1, float3 n)
{
float R0 = max(0, L0);
float3 R1 = 0.5f * L1;
float lenR1 = length(R1);
float q = dot(normalize(R1), n) * 0.5 + 0.5;
q = saturate(q);
float p = 1.0f + 2.0f * lenR1 / R0;
float a = (1.0f - lenR1 / R0) / (1.0f + lenR1 / R0);
return R0 * (a + (1.0f - a) * (p + 1.0f) * pow(q, p));
}
half3 BetterSH9(half4 normal)
{
float3 indirect;
float3 L0 = float3(PoiSHAr.w, PoiSHAg.w, PoiSHAb.w) + float3(PoiSHBr.z, PoiSHBg.z, PoiSHBb.z) / 3.0;
indirect.r = shEvaluateDiffuseL1Geomerics_local(L0.r, PoiSHAr.xyz, normal.xyz);
indirect.g = shEvaluateDiffuseL1Geomerics_local(L0.g, PoiSHAg.xyz, normal.xyz);
indirect.b = shEvaluateDiffuseL1Geomerics_local(L0.b, PoiSHAb.xyz, normal.xyz);
indirect = max(0, indirect);
indirect += SHEvalLinearL2(normal);
return indirect;
}
float3 getCameraForward()
{
// Expected defined at 0, got UNITY_SING
#if UNITY_SINGLE_PASS_STEREO
float3 p1 = mul(unity_StereoCameraToWorld[0], float4(0, 0, 1, 1));
float3 p2 = mul(unity_StereoCameraToWorld[0], float4(0, 0, 0, 1));
#else
float3 p1 = mul(unity_CameraToWorld, float4(0, 0, 1, 1)).xyz;
float3 p2 = mul(unity_CameraToWorld, float4(0, 0, 0, 1)).xyz;
#endif
return normalize(p2 - p1);
}
half3 GetSHLength()
{
half3 x;
half3 x1;
x.r = length(PoiSHAr);
x.g = length(PoiSHAg);
x.b = length(PoiSHAb);
x1.r = length(PoiSHBr);
x1.g = length(PoiSHBg);
x1.b = length(PoiSHBb);
return x + x1;
}
float3 BoxProjection(float3 direction, float3 position, float4 cubemapPosition, float3 boxMin, float3 boxMax)
{
// Expected defined at 0, got UNITY_SPEC
#if UNITY_SPECCUBE_BOX_PROJECTION
if (cubemapPosition.w > 0)
{
float3 factors = ((direction > 0 ? boxMax : boxMin) - position) / direction;
float scalar = min(min(factors.x, factors.y), factors.z);
direction = direction * scalar + (position - cubemapPosition.xyz);
}
#endif
return direction;
}
float poiMax(float2 i)
{
return max(i.x, i.y);
}
float poiMax(float3 i)
{
return max(max(i.x, i.y), i.z);
}
float poiMax(float4 i)
{
return max(max(max(i.x, i.y), i.z), i.w);
}
float3 calculateNormal(
in float3 baseNormal,
in PoiMesh poiMesh,
in Texture2D normalTexture,
in float4 normal_ST,
in float2 normalPan,
in float normalUV,
in float normalIntensity
)
{
float3 normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(normalTexture, _MainTex, poiUV(poiMesh.uv[normalUV], normal_ST), normalPan), normalIntensity);
return normalize( normal.x * poiMesh.tangent[0] + normal.y * poiMesh.binormal[0] + normal.z * baseNormal );
}
float3 calculateNormal(
in float3 baseNormal,
in PoiMesh poiMesh,
in _MainTex_Wrapper normalTexture,
in float4 normal_ST,
in float2 normalPan,
in float normalUV,
in float normalIntensity
)
{
float3 normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(normalTexture, _MainTex, poiUV(poiMesh.uv[normalUV], normal_ST), normalPan), normalIntensity);
return normalize( normal.x * poiMesh.tangent[0] + normal.y * poiMesh.binormal[0] + normal.z * baseNormal );
}
float3 calculateNormal(
in float3 baseNormal,
in PoiMesh poiMesh,
in _BumpMap_Wrapper normalTexture,
in float4 normal_ST,
in float2 normalPan,
in float normalUV,
in float normalIntensity
)
{
float3 normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(normalTexture, _MainTex, poiUV(poiMesh.uv[normalUV], normal_ST), normalPan), normalIntensity);
return normalize( normal.x * poiMesh.tangent[0] + normal.y * poiMesh.binormal[0] + normal.z * baseNormal );
}
float3 calculateNormal(
in float3 baseNormal,
in PoiMesh poiMesh,
in _AlphaMask_Wrapper normalTexture,
in float4 normal_ST,
in float2 normalPan,
in float normalUV,
in float normalIntensity
)
{
float3 normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(normalTexture, _MainTex, poiUV(poiMesh.uv[normalUV], normal_ST), normalPan), normalIntensity);
return normalize( normal.x * poiMesh.tangent[0] + normal.y * poiMesh.binormal[0] + normal.z * baseNormal );
}
float3 calculateNormal(
in float3 baseNormal,
in PoiMesh poiMesh,
in _DecalMask_Wrapper normalTexture,
in float4 normal_ST,
in float2 normalPan,
in float normalUV,
in float normalIntensity
)
{
float3 normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(normalTexture, _MainTex, poiUV(poiMesh.uv[normalUV], normal_ST), normalPan), normalIntensity);
return normalize( normal.x * poiMesh.tangent[0] + normal.y * poiMesh.binormal[0] + normal.z * baseNormal );
}
float3 calculateNormal(
in float3 baseNormal,
in PoiMesh poiMesh,
in _DecalTexture_Wrapper normalTexture,
in float4 normal_ST,
in float2 normalPan,
in float normalUV,
in float normalIntensity
)
{
float3 normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(normalTexture, _MainTex, poiUV(poiMesh.uv[normalUV], normal_ST), normalPan), normalIntensity);
return normalize( normal.x * poiMesh.tangent[0] + normal.y * poiMesh.binormal[0] + normal.z * baseNormal );
}
float3 calculateNormal(
in float3 baseNormal,
in PoiMesh poiMesh,
in _Matcap0NormalMap_Wrapper normalTexture,
in float4 normal_ST,
in float2 normalPan,
in float normalUV,
in float normalIntensity
)
{
float3 normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(normalTexture, _MainTex, poiUV(poiMesh.uv[normalUV], normal_ST), normalPan), normalIntensity);
return normalize( normal.x * poiMesh.tangent[0] + normal.y * poiMesh.binormal[0] + normal.z * baseNormal );
}
float3 calculateNormal(
in float3 baseNormal,
in PoiMesh poiMesh,
in _CubeMapMask_Wrapper normalTexture,
in float4 normal_ST,
in float2 normalPan,
in float normalUV,
in float normalIntensity
)
{
float3 normal = UnpackScaleNormal(POI2D_SAMPLER_PAN(normalTexture, _MainTex, poiUV(poiMesh.uv[normalUV], normal_ST), normalPan), normalIntensity);
return normalize( normal.x * poiMesh.tangent[0] + normal.y * poiMesh.binormal[0] + normal.z * baseNormal );
}
float remap(float x, float minOld, float maxOld, float minNew = 0, float maxNew = 1)
{
return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
}
float2 remap(float2 x, float2 minOld, float2 maxOld, float2 minNew = 0, float2 maxNew = 1)
{
return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
}
float3 remap(float3 x, float3 minOld, float3 maxOld, float3 minNew = 0, float3 maxNew = 1)
{
return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
}
float4 remap(float4 x, float4 minOld, float4 maxOld, float4 minNew = 0, float4 maxNew = 1)
{
return minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld);
}
float remapClamped(float minOld, float maxOld, float x, float minNew = 0, float maxNew = 1)
{
return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
}
float2 remapClamped(float2 minOld, float2 maxOld, float2 x, float2 minNew, float2 maxNew)
{
return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
}
float3 remapClamped(float3 minOld, float3 maxOld, float3 x, float3 minNew, float3 maxNew)
{
return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
}
float4 remapClamped(float4 minOld, float4 maxOld, float4 x, float4 minNew, float4 maxNew)
{
return clamp(minNew + (x - minOld) * (maxNew - minNew) / (maxOld - minOld), minNew, maxNew);
}
float2 calcParallax(in float height, in PoiCam poiCam)
{
return ((height * - 1) + 1) * (poiCam.tangentViewDir.xy / poiCam.tangentViewDir.z);
}
float4 poiBlend(const float sourceFactor, const  float4 sourceColor, const  float destinationFactor, const  float4 destinationColor, const float4 blendFactor)
{
float4 sA = 1 - blendFactor;
const float4 blendData[11] =
{
float4(0.0, 0.0, 0.0, 0.0), float4(1.0, 1.0, 1.0, 1.0), destinationColor, sourceColor, float4(1.0, 1.0, 1.0, 1.0) - destinationColor, sA, float4(1.0, 1.0, 1.0, 1.0) - sourceColor, sA, float4(1.0, 1.0, 1.0, 1.0) - sA, saturate(sourceColor.aaaa), 1 - sA,
}
;
return lerp(blendData[sourceFactor] * sourceColor + blendData[destinationFactor] * destinationColor, sourceColor, sA);
}
float blendColorBurn(float base, float blend)
{
return (blend == 0.0) ? blend : max((1.0 - ((1.0 - base) * rcp(random_uniform_float_only_used_to_stop_compiler_warnings + blend))), 0.0);
}
float3 blendColorBurn(float3 base, float3 blend)
{
return float3(blendColorBurn(base.r, blend.r), blendColorBurn(base.g, blend.g), blendColorBurn(base.b, blend.b));
}
float blendColorDodge(float base, float blend)
{
return (blend == 1.0) ? blend : min(base / (1.0 - blend), 1.0);
}
float3 blendColorDodge(float3 base, float3 blend)
{
return float3(blendColorDodge(base.r, blend.r), blendColorDodge(base.g, blend.g), blendColorDodge(base.b, blend.b));
}
float blendDarken(float base, float blend)
{
return min(blend, base);
}
float3 blendDarken(float3 base, float3 blend)
{
return float3(blendDarken(base.r, blend.r), blendDarken(base.g, blend.g), blendDarken(base.b, blend.b));
}
float blendOverlay(float base, float blend)
{
return base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend));
}
float3 blendOverlay(float3 base, float3 blend)
{
return float3(blendOverlay(base.r, blend.r), blendOverlay(base.g, blend.g), blendOverlay(base.b, blend.b));
}
float blendLighten(float base, float blend)
{
return max(blend, base);
}
float3 blendLighten(float3 base, float3 blend)
{
return float3(blendLighten(base.r, blend.r), blendLighten(base.g, blend.g), blendLighten(base.b, blend.b));
}
float blendLinearDodge(float base, float blend)
{
return min(base + blend, 1.0);
}
float3 blendLinearDodge(float3 base, float3 blend)
{
return base + blend;
}
float blendMultiply(float base, float blend)
{
return base * blend;
}
float3 blendMultiply(float3 base, float3 blend)
{
return base * blend;
}
float blendNormal(float base, float blend)
{
return blend;
}
float3 blendNormal(float3 base, float3 blend)
{
return blend;
}
float blendScreen(float base, float blend)
{
return 1.0 - ((1.0 - base) * (1.0 - blend));
}
float3 blendScreen(float3 base, float3 blend)
{
return float3(blendScreen(base.r, blend.r), blendScreen(base.g, blend.g), blendScreen(base.b, blend.b));
}
float blendSubtract(float base, float blend)
{
return max(base - blend, 0.0);
}
float3 blendSubtract(float3 base, float3 blend)
{
return max(base - blend, 0.0);
}
float blendMixed(float base, float blend)
{
return base + base * blend;
}
float3 blendMixed(float3 base, float3 blend)
{
return base + base * blend;
}
float3 customBlend(float3 base, float3 blend, float blendType, float alpha = 1)
{
float3 output = base;
switch(blendType)
{
case 0: output = lerp(base, blend, alpha);
break;
case 1: output = lerp(base, blendDarken(base, blend), alpha);
break;
case 2: output = base * lerp(1, blend, alpha);
break;
case 5: output = lerp(base, blendLighten(base, blend), alpha);
break;
case 6: output = lerp(base, blendScreen(base, blend), alpha);
break;
case 7: output = blendSubtract(base, blend * alpha);
break;
case 8: output = lerp(base, blendLinearDodge(base, blend), alpha);
break;
case 9: output = lerp(base, blendOverlay(base, blend), alpha);
break;
case 20: output = lerp(base, blendMixed(base, blend), alpha);
break;
default: output = 0;
break;
}
return output;
}
float3 customBlend(float base, float blend, float blendType, float alpha = 1)
{
float3 output = base;
switch(blendType)
{
case 0: output = lerp(base, blend, alpha);
break;
case 2: output = base * lerp(1, blend, alpha);
break;
case 5: output = lerp(base, blendLighten(base, blend), alpha);
break;
case 6: output = lerp(base, blendScreen(base, blend), alpha);
break;
case 7: output = blendSubtract(base, blend * alpha);
break;
case 8: output = lerp(base, blendLinearDodge(base, blend), alpha);
break;
case 9: output = lerp(base, blendOverlay(base, blend), alpha);
break;
case 20: output = lerp(base, blendMixed(base, blend), alpha);
break;
default: output = 0;
break;
}
return output;
}
#define REPLACE 0
#define SUBSTRACT 1
#define MULTIPLY 2
#define DIVIDE 3
#define MIN 4
#define MAX 5
#define AVERAGE 6
#define ADD 7
float maskBlend(float baseMask, float blendMask, float blendType)
{
float output = 0;
switch(blendType)
{
case REPLACE: output = blendMask;
break;
case SUBSTRACT: output = baseMask - blendMask;
break;
case MULTIPLY: output = baseMask * blendMask;
break;
case DIVIDE: output = baseMask / blendMask;
break;
case MIN: output = min(baseMask, blendMask);
break;
case MAX: output = max(baseMask, blendMask);
break;
case AVERAGE: output = (baseMask + blendMask) * 0.5;
break;
case ADD: output = baseMask + blendMask;
break;
}
return saturate(output);
}
float globalMaskBlend(float baseMask, float globalMaskIndex, float blendType, PoiMods poiMods)
{
if (globalMaskIndex == 0)
{
return baseMask;
}
else
{
return maskBlend(baseMask, poiMods.globalMask[globalMaskIndex - 1], blendType);
}
}
inline float poiRand(float2 co)
{
float3 p3 = frac(float3(co.xyx) * 0.1031);
p3 += dot(p3, p3.yzx + 33.33);
return frac((p3.x + p3.y) * p3.z);
}
inline float4 poiRand4(float2 seed)
{
float3 p3 = frac(float3(seed.xyx) * 0.1031);
p3 += dot(p3, p3.yzx + 33.33);
float2 a = frac((p3.xx + p3.yz) * p3.zy);
float2 s2 = seed + 37.0;
float3 q3 = frac(float3(s2.xyx) * 0.1031);
q3 += dot(q3, q3.yzx + 33.33);
float2 b = frac((q3.xx + q3.yz) * q3.zy);
return float4(a, b);
}
inline float2 poiRand2(float seed)
{
float2 x = float2(seed, seed * 1.3);
float3 p3 = frac(float3(x.xyx) * 0.1031);
p3 += dot(p3, p3.yzx + 33.33);
return frac((p3.xx + p3.yz) * p3.zy);
}
inline float2 poiRand2(float2 seed)
{
float3 p3 = frac(float3(seed.xyx) * 0.1031);
p3 += dot(p3, p3.yzx + 33.33);
return frac((p3.xx + p3.yz) * p3.zy);
}
inline float poiRand3(float seed)
{
float p = frac(seed * 0.1031);
p *= p + 33.33;
p *= p + p;
return frac(p);
}
inline float3 poiRand3(float2 seed)
{
float3 p3 = frac(float3(seed.xyx) * 0.1031);
p3 += dot(p3, p3.yzx + 33.33);
return frac((p3.xxy + p3.yzz) * p3.zyx);
}
inline float3 poiRand3(float3 seed)
{
float3 p3 = frac(seed * 0.1031);
p3 += dot(p3, p3.zyx + 31.32);
return frac((p3.xxy + p3.yzz) * p3.zyx);
}
inline float3 poiRand3Range(float2 Seed, float Range)
{
float3 r = poiRand3(Seed);
return (r * 2.0 - 1.0) * Range;
}
float3 randomFloat3WiggleRange(float2 Seed, float Range, float wiggleSpeed, float timeOffset)
{
float3 rando = (float3( frac(sin(dot(Seed.xy, float2(12.9898, 78.233))) * 43758.5453), frac(sin(dot(Seed.yx, float2(12.9898, 78.233))) * 43758.5453), frac(sin(dot(float2(Seed.x * Seed.y, Seed.y + Seed.x), float2(12.9898, 78.233))) * 43758.5453) ) * 2 - 1);
float speed = 1 + wiggleSpeed;
return float3(sin(((_Time.x + timeOffset) + rando.x * PI) * speed), sin(((_Time.x + timeOffset) + rando.y * PI) * speed), sin(((_Time.x + timeOffset) + rando.z * PI) * speed)) * Range;
}
static const float3 HCYwts = float3(0.299, 0.587, 0.114);
static const float HCLgamma = 3;
static const float HCLy0 = 100;
static const float HCLmaxL = 0.530454533953517;
static const float3 wref = float3(1.0, 1.0, 1.0);
#define TAU 6.28318531
float3 HUEtoRGB(in float H)
{
float R = abs(H * 6 - 3) - 1;
float G = 2 - abs(H * 6 - 2);
float B = 2 - abs(H * 6 - 4);
return saturate(float3(R, G, B));
}
float3 RGBtoHCV(in float3 RGB)
{
float4 P = (RGB.g < RGB.b) ? float4(RGB.bg, -1.0, 2.0 / 3.0) : float4(RGB.gb, 0.0, -1.0 / 3.0);
float4 Q = (RGB.r < P.x) ? float4(P.xyw, RGB.r) : float4(RGB.r, P.yzx);
float C = Q.x - min(Q.w, Q.y);
float H = abs((Q.w - Q.y) / (6 * C + EPSILON) + Q.z);
return float3(H, C, Q.x);
}
float3 RGBtoHSV(float3 c)
{
float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));
float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
float3 HSVtoRGB(float3 c)
{
float4 K = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
float3 p = abs(frac(c.xxx + K.xyz) * 6.0 - K.www);
return c.z * lerp(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
}
void DecomposeHDRColor(in float3 linearColorHDR, out float3 baseLinearColor, out float exposure)
{
float maxColorComponent = max(linearColorHDR.r, max(linearColorHDR.g, linearColorHDR.b));
bool isSDR = maxColorComponent <= 1.0;
float scaleFactor = isSDR ? 1.0 : (1.0 / maxColorComponent);
exposure = isSDR ? 0.0 : log(maxColorComponent) * 1.44269504089;
baseLinearColor = scaleFactor * linearColorHDR;
}
float3 ApplyHDRExposure(float3 linearColor, float exposure)
{
return linearColor * pow(2, exposure);
}
float3 ModifyViaHSV(float3 color, float h, float s, float v)
{
float3 colorHSV = RGBtoHSV(color);
colorHSV.x = frac(colorHSV.x + h);
colorHSV.y = saturate(colorHSV.y + s);
colorHSV.z = saturate(colorHSV.z + v);
return HSVtoRGB(colorHSV);
}
float3 ModifyViaHSV(float3 color, float3 HSVMod)
{
return ModifyViaHSV(color, HSVMod.x, HSVMod.y, HSVMod.z);
}
float4x4 brightnessMatrix(float brightness)
{
return float4x4( 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, brightness, brightness, brightness, 1 );
}
float4x4 contrastMatrix(float contrast)
{
float t = (1.0 - contrast) / 2.0;
return float4x4( contrast, 0, 0, 0, 0, contrast, 0, 0, 0, 0, contrast, 0, t, t, t, 1 );
}
float4x4 saturationMatrix(float saturation)
{
float3 luminance = float3(0.3086, 0.6094, 0.0820);
float oneMinusSat = 1.0 - saturation;
float3 red = luminance.x * oneMinusSat;
red += float3(saturation, 0, 0);
float3 green = luminance.y * oneMinusSat;
green += float3(0, saturation, 0);
float3 blue = luminance.z * oneMinusSat;
blue += float3(0, 0, saturation);
return float4x4( red, 0, green, 0, blue, 0, 0, 0, 0, 1 );
}
float4 PoiColorBCS(float4 color, float brightness, float contrast, float saturation)
{
return mul(color, mul(brightnessMatrix(brightness), mul(contrastMatrix(contrast), saturationMatrix(saturation))));
}
float3 PoiColorBCS(float3 color, float brightness, float contrast, float saturation)
{
return mul(float4(color, 1), mul(brightnessMatrix(brightness), mul(contrastMatrix(contrast), saturationMatrix(saturation)))).rgb;
}
float3 linear_srgb_to_oklab(float3 c)
{
float l = 0.4122214708 * c.x + 0.5363325363 * c.y + 0.0514459929 * c.z;
float m = 0.2119034982 * c.x + 0.6806995451 * c.y + 0.1073969566 * c.z;
float s = 0.0883024619 * c.x + 0.2817188376 * c.y + 0.6299787005 * c.z;
float l_ = pow(l, 1.0 / 3.0);
float m_ = pow(m, 1.0 / 3.0);
float s_ = pow(s, 1.0 / 3.0);
return float3( 0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_, 1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_, 0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_ );
}
float3 oklab_to_linear_srgb(float3 c)
{
float l_ = c.x + 0.3963377774 * c.y + 0.2158037573 * c.z;
float m_ = c.x - 0.1055613458 * c.y - 0.0638541728 * c.z;
float s_ = c.x - 0.0894841775 * c.y - 1.2914855480 * c.z;
float l = l_ * l_ * l_;
float m = m_ * m_ * m_;
float s = s_ * s_ * s_;
return float3( + 4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s, - 1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s, - 0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s );
}
float3 hueShiftOKLab(float3 color, float shift, float selectOrShift)
{
float3 oklab = linear_srgb_to_oklab(color);
float chroma = length(oklab.yz);
if (chroma < 1e-5)
{
return color;
}
float hue = atan2(oklab.z, oklab.y);
hue = shift * TWO_PI + hue * selectOrShift;
oklab.y = cos(hue) * chroma;
oklab.z = sin(hue) * chroma;
return oklab_to_linear_srgb(oklab);
}
float3 hueShiftHSV(float3 color, float hueOffset, float selectOrShift)
{
float3 hsvCol = RGBtoHSV(color);
hsvCol.x = hsvCol.x * selectOrShift + hueOffset;
return HSVtoRGB(hsvCol);
}
float3 hueShift(float3 color, float shift, float ColorSpace, float selectOrShift)
{
switch(ColorSpace)
{
case 0.0:
return hueShiftOKLab(color, shift, selectOrShift);
case 1.0:
return hueShiftHSV(color, shift, selectOrShift);
default:
return float3(1.0, 0.0, 0.0);
}
}
float4 hueShift(float4 color, float shift, float ColorSpace, float selectOrShift)
{
return float4(hueShift(color.rgb, shift, ColorSpace, selectOrShift), color.a);
}
float4x4 poiRotationMatrixFromAngles(float x, float y, float z)
{
float angleX = radians(x);
float c = cos(angleX);
float s = sin(angleX);
float4x4 rotateXMatrix = float4x4(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
float angleY = radians(y);
c = cos(angleY);
s = sin(angleY);
float4x4 rotateYMatrix = float4x4(c, 0, s, 0, 0, 1, 0, 0, - s, 0, c, 0, 0, 0, 0, 1);
float angleZ = radians(z);
c = cos(angleZ);
s = sin(angleZ);
float4x4 rotateZMatrix = float4x4(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
return mul(mul(rotateXMatrix, rotateYMatrix), rotateZMatrix);
}
float4x4 poiRotationMatrixFromAngles(float3 angles)
{
float angleX = radians(angles.x);
float c = cos(angleX);
float s = sin(angleX);
float4x4 rotateXMatrix = float4x4(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
float angleY = radians(angles.y);
c = cos(angleY);
s = sin(angleY);
float4x4 rotateYMatrix = float4x4(c, 0, s, 0, 0, 1, 0, 0, - s, 0, c, 0, 0, 0, 0, 1);
float angleZ = radians(angles.z);
c = cos(angleZ);
s = sin(angleZ);
float4x4 rotateZMatrix = float4x4(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
return mul(mul(rotateXMatrix, rotateYMatrix), rotateZMatrix);
}
float3 _VRChatMirrorCameraPos;
float3 getCameraPosition()
{
#ifdef USING_STEREO_MATRICES
return unity_StereoWorldSpaceCameraPos[0] * .5 + unity_StereoWorldSpaceCameraPos[1] * .5;
#endif
return _VRChatMirrorMode == 1 ? _VRChatMirrorCameraPos : _WorldSpaceCameraPos;
}
#ifdef POI_AUDIOLINK
inline int poiALBandPass(int bandIdx)
{
bandIdx = clamp(bandIdx, 0, 3);
return bandIdx == 0 ? ALPASS_AUDIOBASS : bandIdx == 1 ? ALPASS_AUDIOLOWMIDS : bandIdx == 2 ? ALPASS_AUDIOHIGHMIDS : ALPASS_AUDIOTREBLE;
}
#endif
float2 calcPixelScreenUVs(half4 grabPos)
{
half2 uv = grabPos.xy / (grabPos.w + 0.0000000001);
// Expected defined at 0, got UNITY_SING
#if UNITY_SINGLE_PASS_STEREO
uv.xy *= half2(_ScreenParams.x * 2, _ScreenParams.y);
#else
uv.xy *= _ScreenParams.xy;
#endif
return uv;
}
float CalcMipLevel(float2 texture_coord)
{
float2 dx = ddx(texture_coord);
float2 dy = ddy(texture_coord);
float delta_max_sqr = max(dot(dx, dx), dot(dy, dy));
return 0.5 * log2(delta_max_sqr);
}
float inverseLerp(float A, float B, float T)
{
return (T - A) / (B - A);
}
float inverseLerp2(float2 a, float2 b, float2 value)
{
float2 AB = b - a;
float2 AV = value - a;
return dot(AV, AB) / dot(AB, AB);
}
float inverseLerp3(float3 a, float3 b, float3 value)
{
float3 AB = b - a;
float3 AV = value - a;
return dot(AV, AB) / dot(AB, AB);
}
float inverseLerp4(float4 a, float4 b, float4 value)
{
float4 AB = b - a;
float4 AV = value - a;
return dot(AV, AB) / dot(AB, AB);
}
float4 QuaternionFromMatrix( float m00, float m01, float m02, float m10, float m11, float m12, float m20, float m21, float m22)
{
float4 q;
float trace = m00 + m11 + m22;
if (trace > 0)
{
float s = sqrt(trace + 1) * 2;
q.w = 0.25 * s;
q.x = (m21 - m12) / s;
q.y = (m02 - m20) / s;
q.z = (m10 - m01) / s;
}
else if (m00 > m11 && m00 > m22)
{
float s = sqrt(1 + m00 - m11 - m22) * 2;
q.w = (m21 - m12) / s;
q.x = 0.25 * s;
q.y = (m01 + m10) / s;
q.z = (m02 + m20) / s;
}
else if (m11 > m22)
{
float s = sqrt(1 + m11 - m00 - m22) * 2;
q.w = (m02 - m20) / s;
q.x = (m01 + m10) / s;
q.y = 0.25 * s;
q.z = (m12 + m21) / s;
}
else
{
float s = sqrt(1 + m22 - m00 - m11) * 2;
q.w = (m10 - m01) / s;
q.x = (m02 + m20) / s;
q.y = (m12 + m21) / s;
q.z = 0.25 * s;
}
return q;
}
float4 MulQuat(float4 a, float4 b)
{
return float4( a.w * b.x + a.x * b.w + a.y * b.z - a.z * b.y, a.w * b.y - a.x * b.z + a.y * b.w + a.z * b.x, a.w * b.z + a.x * b.y - a.y * b.x + a.z * b.w, a.w * b.w - a.x * b.x - a.y * b.y - a.z * b.z );
}
float4 QuaternionFromBasis(float3 sx, float3 sy, float3 sz)
{
return QuaternionFromMatrix( sx.x, sy.x, sz.x, sx.y, sy.y, sz.y, sx.z, sy.z, sz.z );
}
float4 BuildQuatFromForwardUp(float3 forward, float3 up)
{
float3 f = normalize(forward);
float3 u = normalize(up);
float3 x = normalize(cross(u, f));
float3 y = cross(f, x);
return QuaternionFromBasis(x, y, f);
}
float3 QuaternionToEuler(float4 q)
{
float3 euler;
float sinr_cosp = 2 * (q.w * q.z + q.x * q.y);
float cosr_cosp = 1 - 2 * (q.z * q.z + q.x * q.x);
euler.z = atan2(sinr_cosp, cosr_cosp) * 57.2958;
float sinp = 2 * (q.w * q.x - q.y * q.z);
if (abs(sinp) >= 1) euler.x = (sinp >= 0 ? 1 : - 1) * 90;
else euler.x = asin(sinp) * 57.2958;
float siny_cosp = 2 * (q.w * q.y + q.z * q.x);
float cosy_cosp = 1 - 2 * (q.x * q.x + q.y * q.y);
euler.y = atan2(siny_cosp, cosy_cosp) * 57.2958;
return euler;
}
float4 EulerToQuaternion(float3 euler)
{
float3 eulerRad = euler * 0.0174533;
float cx = cos(eulerRad.x * 0.5);
float sx = sin(eulerRad.x * 0.5);
float cy = cos(eulerRad.y * 0.5);
float sy = sin(eulerRad.y * 0.5);
float cz = cos(eulerRad.z * 0.5);
float sz = sin(eulerRad.z * 0.5);
float4 q;
q.w = cx * cy * cz + sx * sy * sz;
q.x = sx * cy * cz - cx * sy * sz;
q.y = cx * sy * cz + sx * cy * sz;
q.z = cx * cy * sz - sx * sy * cz;
return q;
}
float4 quaternion_conjugate(float4 v)
{
return float4( v.x, -v.yzw );
}
float4 quaternion_mul(float4 v1, float4 v2)
{
float4 result1 = (v1.x * v2 + v1 * v2.x);
float4 result2 = float4( - dot(v1.yzw, v2.yzw), cross(v1.yzw, v2.yzw) );
return float4(result1 + result2);
}
float4 get_quaternion_from_angle(float3 axis, float angle)
{
float sn = sin(angle * 0.5);
float cs = cos(angle * 0.5);
return float4(axis * sn, cs);
}
float4 quaternion_from_vector(float3 inVec)
{
return float4(0.0, inVec);
}
float degree_to_radius(float degree)
{
return ( degree / 180.0 * PI );
}
float3 rotate_with_quaternion(float3 inVec, float3 rotation)
{
float4 qx = get_quaternion_from_angle(float3(1, 0, 0), radians(rotation.x));
float4 qy = get_quaternion_from_angle(float3(0, 1, 0), radians(rotation.y));
float4 qz = get_quaternion_from_angle(float3(0, 0, 1), radians(rotation.z));
#define MUL3(A, B, C) quaternion_mul(quaternion_mul((A), (B)), (C))
float4 quaternion = normalize(MUL3(qx, qy, qz));
float4 conjugate = quaternion_conjugate(quaternion);
float4 inVecQ = quaternion_from_vector(inVec);
float3 rotated = ( MUL3(quaternion, inVecQ, conjugate) ).yzw;
return rotated;
}
float3 RotateByQuaternion(float4 q, float3 v)
{
float3 u = q.xyz;
float s = q.w;
return 2.0 * dot(u, v) * u + (s * s - dot(u, u)) * v + 2.0 * s * cross(u, v);
}
float4 SlerpQuaternion(float4 qa, float4 qb, float t)
{
float cosHalfTheta = dot(qa, qb);
if (cosHalfTheta < 0.0)
{
qb = -qb;
cosHalfTheta = -cosHalfTheta;
}
if (cosHalfTheta > 0.9995)
{
float4 qr = normalize(qa * (1 - t) + qb * t);
return qr;
}
float halfTheta = acos(cosHalfTheta);
float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);
float a = sin((1 - t) * halfTheta) / sinHalfTheta;
float b = sin(t * halfTheta) / sinHalfTheta;
return qa * a + qb * b;
}
float4 transform(float4 input, float4 pos, float4 rotation, float4 scale)
{
input.rgb *= (scale.xyz * scale.w);
input = float4(rotate_with_quaternion(input.xyz, rotation.xyz * rotation.w) + (pos.xyz * pos.w), input.w);
return input;
}
float2 RotateUV(float2 _uv, float _radian, float2 _piv, float _time)
{
float RotateUV_ang = _radian;
float RotateUV_cos = cos(_time * RotateUV_ang);
float RotateUV_sin = sin(_time * RotateUV_ang);
return (mul(_uv - _piv, float2x2(RotateUV_cos, -RotateUV_sin, RotateUV_sin, RotateUV_cos)) + _piv);
}
float3 RotateAroundAxis(float3 original, float3 axis, float radian)
{
float s = sin(radian);
float c = cos(radian);
float one_minus_c = 1.0 - c;
axis = normalize(axis);
float3x3 rot_mat =
{
one_minus_c * axis.x * axis.x + c, one_minus_c * axis.x * axis.y - axis.z * s, one_minus_c * axis.z * axis.x + axis.y * s, one_minus_c * axis.x * axis.y + axis.z * s, one_minus_c * axis.y * axis.y + c, one_minus_c * axis.y * axis.z - axis.x * s, one_minus_c * axis.z * axis.x - axis.y * s, one_minus_c * axis.y * axis.z + axis.x * s, one_minus_c * axis.z * axis.z + c
}
;
return mul(rot_mat, original);
}
float3 poiThemeColor(in PoiMods poiMods, in float3 srcColor, in float themeIndex)
{
float3 outputColor = srcColor;
if (themeIndex != 0)
{
themeIndex = max(themeIndex - 1, 0);
if (themeIndex <= 3)
{
outputColor = poiMods.globalColorTheme[themeIndex];
}
else
{
#ifdef POI_AUDIOLINK
if (poiMods.audioLinkAvailable)
{
outputColor = poiMods.globalColorTheme[themeIndex];
}
#endif
}
}
return outputColor;
}
float3 lilToneCorrection(float3 c, float4 hsvg)
{
c = pow(abs(c), hsvg.w);
float4 p = (c.b > c.g) ? float4(c.bg, -1.0, 2.0 / 3.0) : float4(c.gb, 0.0, -1.0 / 3.0);
float4 q = (p.x > c.r) ? float4(p.xyw, c.r) : float4(c.r, p.yzx);
float d = q.x - min(q.w, q.y);
float e = 1.0e-10;
float3 hsv = float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
hsv = float3(hsv.x + hsvg.x, saturate(hsv.y * hsvg.y), saturate(hsv.z * hsvg.z));
return hsv.z - hsv.z * hsv.y + hsv.z * hsv.y * saturate(abs(frac(hsv.x + float3(1.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 1.0);
}
float3 lilBlendColor(float3 dstCol, float3 srcCol, float3 srcA, int blendMode)
{
float3 ad = dstCol + srcCol;
float3 mu = dstCol * srcCol;
float3 outCol = float3(0, 0, 0);
if (blendMode == 0) outCol = srcCol;
if (blendMode == 1) outCol = ad;
if (blendMode == 2) outCol = max(ad - mu, dstCol);
if (blendMode == 3) outCol = mu;
return lerp(dstCol, outCol, srcA);
}
float lilIsIn0to1(float f)
{
float value = 0.5 - abs(f - 0.5);
return saturate(value / clamp(fwidth(value), 0.0001, 1.0));
}
float lilIsIn0to1(float f, float nv)
{
float value = 0.5 - abs(f - 0.5);
return saturate(value / clamp(fwidth(value), 0.0001, nv));
}
float poiEdgeLinearNoSaturate(float value, float border)
{
return (value - border) / clamp(fwidth(value), 0.0001, 1.0);
}
float3 poiEdgeLinearNoSaturate(float value, float3 border)
{
return float3( (value - border.x) / clamp(fwidth(value), 0.0001, 1.0), (value - border.y) / clamp(fwidth(value), 0.0001, 1.0), (value - border.z) / clamp(fwidth(value), 0.0001, 1.0) );
}
float poiEdgeLinearNoSaturate(float value, float border, float blur)
{
float borderMin = saturate(border - blur * 0.5);
float borderMax = saturate(border + blur * 0.5);
return (value - borderMin) / max(saturate(borderMax - borderMin + fwidth(value)), .0001);
}
float poiEdgeLinearNoSaturate(float value, float border, float blur, float borderRange)
{
float borderMin = saturate(border - blur * 0.5 - borderRange);
float borderMax = saturate(border + blur * 0.5);
return (value - borderMin) / max(saturate(borderMax - borderMin + fwidth(value)), .0001);
}
float poiEdgeNonLinearNoSaturate(float value, float border)
{
float fwidthValue = fwidth(value);
return smoothstep(border - fwidthValue, border + fwidthValue, value);
}
float poiEdgeNonLinearNoSaturate(float value, float border, float blur)
{
float fwidthValue = fwidth(value);
float borderMin = saturate(border - blur * 0.5);
float borderMax = saturate(border + blur * 0.5);
return smoothstep(borderMin - fwidthValue, borderMax + fwidthValue, value);
}
float poiEdgeNonLinearNoSaturate(float value, float border, float blur, float borderRange)
{
float fwidthValue = fwidth(value);
float borderMin = saturate(border - blur * 0.5 - borderRange);
float borderMax = saturate(border + blur * 0.5);
return smoothstep(borderMin - fwidthValue, borderMax + fwidthValue, value);
}
float poiEdgeNonLinear(float value, float border)
{
return saturate(poiEdgeNonLinearNoSaturate(value, border));
}
float poiEdgeNonLinear(float value, float border, float blur)
{
return saturate(poiEdgeNonLinearNoSaturate(value, border, blur));
}
float poiEdgeNonLinear(float value, float border, float blur, float borderRange)
{
return saturate(poiEdgeNonLinearNoSaturate(value, border, blur, borderRange));
}
float poiEdgeLinear(float value, float border)
{
return saturate(poiEdgeLinearNoSaturate(value, border));
}
float poiEdgeLinear(float value, float border, float blur)
{
return saturate(poiEdgeLinearNoSaturate(value, border, blur));
}
float poiEdgeLinear(float value, float border, float blur, float borderRange)
{
return saturate(poiEdgeLinearNoSaturate(value, border, blur, borderRange));
}
float3 OpenLitLinearToSRGB(float3 col)
{
return LinearToGammaSpace(col);
}
float3 OpenLitSRGBToLinear(float3 col)
{
return GammaToLinearSpace(col);
}
float OpenLitLuminance(float3 rgb)
{
// Skipped 1 lines | #if defined(UNITY_COLORSPACE_GAMMA)
return dot(rgb, float3(0.0396819152, 0.458021790, 0.00609653955));
}
float3 AdjustLitLuminance(float3 rgb, float targetLuminance)
{
float currentLuminance;
// Skipped 1 lines | #if defined(UNITY_COLORSPACE_GAMMA)
currentLuminance = dot(rgb, float3(0.0396819152, 0.458021790, 0.00609653955));
float luminanceRatio = targetLuminance / currentLuminance;
return rgb * luminanceRatio;
}
float3 ClampLuminance(float3 rgb, float minLuminance, float maxLuminance)
{
float currentLuminance = dot(rgb, float3(0.299, 0.587, 0.114));
float minRatio = (currentLuminance != 0) ? minLuminance / currentLuminance : 1.0;
float maxRatio = (currentLuminance != 0) ? maxLuminance / currentLuminance : 1.0;
float luminanceRatio = clamp(min(maxRatio, max(minRatio, 1.0)), 0.0, 1.0);
return lerp(rgb, rgb * luminanceRatio, luminanceRatio < 1.0);
}
float3 MaxLuminance(float3 rgb, float maxLuminance)
{
float currentLuminance = dot(rgb, float3(0.299, 0.587, 0.114));
float luminanceRatio = (currentLuminance != 0) ? maxLuminance / max(currentLuminance, 0.00001) : 1.0;
return lerp(rgb, rgb * luminanceRatio, currentLuminance > maxLuminance);
}
float OpenLitGray(float3 rgb)
{
return dot(rgb, float3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0));
}
void OpenLitShadeSH9ToonDouble(float3 lightDirection, out float3 shMax, out float3 shMin)
{
float3 N = lightDirection * 0.666666;
float4 vB = N.xyzz * N.yzzx;
float3 res = float3(PoiSHAr.w, PoiSHAg.w, PoiSHAb.w);
res.r += dot(PoiSHBr, vB);
res.g += dot(PoiSHBg, vB);
res.b += dot(PoiSHBb, vB);
res += PoiSHC.rgb * (N.x * N.x - N.y * N.y);
float3 l1;
l1.r = dot(PoiSHAr.rgb, N);
l1.g = dot(PoiSHAg.rgb, N);
l1.b = dot(PoiSHAb.rgb, N);
shMax = res + l1;
shMin = res - l1;
// Skipped 2 lines | #if defined(UNITY_COLORSPACE_GAMMA)
// Skipped 2 lines
}
float3 OpenLitComputeCustomLightDirection(float4 lightDirectionOverride)
{
float3 customDir = length(lightDirectionOverride.xyz) * normalize(mul((float3x3)unity_ObjectToWorld, lightDirectionOverride.xyz));
return lightDirectionOverride.w ? customDir : lightDirectionOverride.xyz;
}
float3 OpenLitLightingDirectionForSH9()
{
float3 mainDir = _WorldSpaceLightPos0.xyz * OpenLitLuminance(_LightColor0.rgb);
float3 sh9Dir = PoiSHAr.xyz * 0.333333 + PoiSHAg.xyz * 0.333333 + PoiSHAb.xyz * 0.333333;
float3 sh9DirAbs = float3(sh9Dir.x, abs(sh9Dir.y), sh9Dir.z);
// Skipped 2 lines
float3 lightDirectionForSH9 = sh9Dir + mainDir;
lightDirectionForSH9 = dot(lightDirectionForSH9, lightDirectionForSH9) < 0.000001 ? 0 : normalize(lightDirectionForSH9);
return lightDirectionForSH9;
}
float3 OpenLitLightingDirection(float4 lightDirectionOverride)
{
float3 mainDir = _WorldSpaceLightPos0.xyz * OpenLitLuminance(_LightColor0.rgb);
// Expected defined at 25, got UNITY_SHOU
#if !defined(LIGHTMAP_ON) && UNITY_SHOULD_SAMPLE_SH
float3 sh9Dir = PoiSHAr.xyz * 0.333333 + PoiSHAg.xyz * 0.333333 + PoiSHAb.xyz * 0.333333;
float3 sh9DirAbs = float3(sh9Dir.x, abs(sh9Dir.y), sh9Dir.z);
#else
float3 sh9Dir = 0;
float3 sh9DirAbs = 0;
#endif
float3 customDir = OpenLitComputeCustomLightDirection(lightDirectionOverride);
return normalize(sh9DirAbs + mainDir + customDir);
}
float3 OpenLitLightingDirection()
{
float4 customDir = float4(0.001, 0.002, 0.001, 0.0);
return OpenLitLightingDirection(customDir);
}
inline float4 CalculateFrustumCorrection()
{
float x1 = -UNITY_MATRIX_P._31 / (UNITY_MATRIX_P._11 * UNITY_MATRIX_P._34);
float x2 = -UNITY_MATRIX_P._32 / (UNITY_MATRIX_P._22 * UNITY_MATRIX_P._34);
return float4(x1, x2, 0, UNITY_MATRIX_P._33 / UNITY_MATRIX_P._34 + x1 * UNITY_MATRIX_P._13 + x2 * UNITY_MATRIX_P._23);
}
inline float CorrectedLinearEyeDepth(float z, float correctionFactor)
{
return 1.f / (z / UNITY_MATRIX_P._34 + correctionFactor);
}
float evalRamp4(float time, float4 ramp)
{
return lerp(ramp.x, ramp.y, smoothstep(ramp.z, ramp.w, time));
}
float2 sharpSample(float4 texelSize, float2 p)
{
p = p * texelSize.zw;
float2 c = max(0.0, fwidth(p));
p = floor(p) + saturate(frac(p) / c);
p = (p - 0.5) * texelSize.xy;
return p;
}
void applyToGlobalMask(inout PoiMods poiMods, int index, int blendType, float val)
{
float valBlended = saturate(maskBlend(poiMods.globalMask[index], val, blendType));
switch(index)
{
case 0: poiMods.globalMask[0] = valBlended;
break;
case 1: poiMods.globalMask[1] = valBlended;
break;
case 2: poiMods.globalMask[2] = valBlended;
break;
case 3: poiMods.globalMask[3] = valBlended;
break;
case 4: poiMods.globalMask[4] = valBlended;
break;
case 5: poiMods.globalMask[5] = valBlended;
break;
case 6: poiMods.globalMask[6] = valBlended;
break;
case 7: poiMods.globalMask[7] = valBlended;
break;
case 8: poiMods.globalMask[8] = valBlended;
break;
case 9: poiMods.globalMask[9] = valBlended;
break;
case 10: poiMods.globalMask[10] = valBlended;
break;
case 11: poiMods.globalMask[11] = valBlended;
break;
case 12: poiMods.globalMask[12] = valBlended;
break;
case 13: poiMods.globalMask[13] = valBlended;
break;
case 14: poiMods.globalMask[14] = valBlended;
break;
case 15: poiMods.globalMask[15] = valBlended;
break;
}
}
void assignValueToVectorFromIndex(inout float4 vec, int index, float value)
{
switch(index)
{
case 0: vec[0] = value;
break;
case 1: vec[1] = value;
break;
case 2: vec[2] = value;
break;
case 3: vec[3] = value;
break;
}
}
float3 mod289(float3 x)
{
return x - floor(x * (1.0 / 289.0)) * 289.0;
}
float2 mod289(float2 x)
{
return x - floor(x * (1.0 / 289.0)) * 289.0;
}
float3 permute(float3 x)
{
return mod289(((x * 34.0) + 1.0) * x);
}
float snoise(float2 v)
{
const float4 C = float4(0.211324865405187, 0.366025403784439, - 0.577350269189626, 0.024390243902439);
float2 i = floor(v + dot(v, C.yy));
float2 x0 = v - i + dot(i, C.xx);
float2 i1;
i1 = (x0.x > x0.y) ? float2(1.0, 0.0) : float2(0.0, 1.0);
float4 x12 = x0.xyxy + C.xxzz;
x12.xy -= i1;
i = mod289(i);
float3 p = permute(permute(i.y + float3(0.0, i1.y, 1.0)) + i.x + float3(0.0, i1.x, 1.0));
float3 m = max(0.5 - float3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);
m = m * m ;
m = m * m ;
float3 x = 2.0 * frac(p * C.www) - 1.0;
float3 h = abs(x) - 0.5;
float3 ox = floor(x + 0.5);
float3 a0 = x - ox;
m *= 1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h);
float3 g;
g.x = a0.x * x0.x + h.x * x0.y;
g.yz = a0.yz * x12.xz + h.yz * x12.yw;
return 130.0 * dot(m, g);
}
float poiInvertToggle(in float value, in float toggle)
{
return (toggle == 0 ? value : 1 - value);
}
float3 PoiBlendNormal(float3 dstNormal, float3 srcNormal)
{
return float3(dstNormal.xy + srcNormal.xy, dstNormal.z * srcNormal.z);
}
float3 lilTransformDirOStoWS(float3 directionOS, bool doNormalize)
{
if (doNormalize)
return normalize(mul((float3x3)unity_ObjectToWorld, directionOS));
else
return mul((float3x3)unity_ObjectToWorld, directionOS);
}
float2 poiGetWidthAndHeight(
Texture2D tex
)
{
uint width, height;
tex.GetDimensions(width, height);
return float2(width, height);
}
float2 poiGetWidthAndHeight(
_MainTex_Wrapper tex
)
{
uint width, height;
tex.GetDimensions(width, height);
return float2(width, height);
}
float2 poiGetWidthAndHeight(
_BumpMap_Wrapper tex
)
{
uint width, height;
tex.GetDimensions(width, height);
return float2(width, height);
}
float2 poiGetWidthAndHeight(
_AlphaMask_Wrapper tex
)
{
uint width, height;
tex.GetDimensions(width, height);
return float2(width, height);
}
float2 poiGetWidthAndHeight(
_DecalMask_Wrapper tex
)
{
uint width, height;
tex.GetDimensions(width, height);
return float2(width, height);
}
float2 poiGetWidthAndHeight(
_DecalTexture_Wrapper tex
)
{
uint width, height;
tex.GetDimensions(width, height);
return float2(width, height);
}
float2 poiGetWidthAndHeight(
_Matcap0NormalMap_Wrapper tex
)
{
uint width, height;
tex.GetDimensions(width, height);
return float2(width, height);
}
float2 poiGetWidthAndHeight(
_CubeMapMask_Wrapper tex
)
{
uint width, height;
tex.GetDimensions(width, height);
return float2(width, height);
}
float2 poiGetWidthAndHeight(Texture2DArray tex)
{
uint width;
uint height;
uint element;
tex.GetDimensions(width, height, element);
return float2(width, height);
}
bool SceneHasReflections()
{
float width;
float height;
unity_SpecCube0.GetDimensions(width, height);
return !(width * height < 2);
}
void applyUnityFog(inout float3 col, float2 fogData)
{
float fogFactor = 1.0;
float depth = UNITY_Z_0_FAR_FROM_CLIPSPACE(fogData.x);
if (unity_FogParams.z != unity_FogParams.w)
{
fogFactor = depth * unity_FogParams.z + unity_FogParams.w;
}
else if (fogData.y)
{
float exponent_val = unity_FogParams.x * depth;
fogFactor = exp2(-exponent_val * exponent_val);
}
else if (unity_FogParams.y != 0.0f)
{
float exponent = unity_FogParams.y * depth;
fogFactor = exp2(-exponent);
}
fixed3 appliedFogColor = unity_FogColor.rgb;
// Skipped 1 lines | #if defined(UNITY_PASS_FORWARDADD)
col.rgb = lerp(appliedFogColor, col.rgb, saturate(fogFactor));
}
void applyReducedRenderClipDistance(inout VertexOut o)
{
if (o.pos.w < _ProjectionParams.y * 1.01 && o.pos.w > 0)
{
#if defined(UNITY_REVERSED_Z)
o.pos.z = o.pos.z * 0.0001 + o.pos.w * 0.999;
#else
o.pos.z = o.pos.z * 0.0001 - o.pos.w * 0.999;
#endif
}
}
inline float sdPlane(float3 p, float3 n, float h)
{
return dot(p, normalize(n)) + h;
}
float3 calcIntrudePos(float3 pos, float3 normalOS, float2 uv)
{
float3 wnormal = UnityObjectToWorldNormal(normalOS);
float3 wpos = mul(unity_ObjectToWorld, float4(pos, 1.0)).xyz;
float3 camDir = -UNITY_MATRIX_V._m20_m21_m22;
float3 camPos = _WorldSpaceCameraPos;
float near = _ProjectionParams.y;
// Skipped 1 lines | #if defined(PROP_UZUMOREMASK) || !defined(OPTIMIZER_ENABLED)
float uzumoreMask = 1;
float maxAmount = 0.1 * uzumoreMask;
float maxBias = 0.001;
float d = sdPlane(wpos - camPos, -camDir, (near + maxBias));
float intrudeAmount = clamp(d, 0, maxAmount);
if (intrudeAmount > 0.0f && dot(camDir, wnormal) < - 0.2)
{
float biasRate = min(1.0f, intrudeAmount / max(maxAmount, 0.00001));
float bias = maxBias * biasRate;
float3 extrude = (intrudeAmount - bias) * camDir;
return mul(unity_WorldToObject, float4(wpos + extrude, 1.0)).xyz;
}
return pos;
}
struct vertexOutputWrapper
{
uint WKVRCOptimizer_MeshMaterialID : WKVRCOptimizer_MeshMaterialID;
VertexOut returnWrappedStruct;
};
struct vertexInputWrapper
{
appdata v;
};
vertexOutputWrapper WKVRCOptimizer_vertexWithWrapper(vertexInputWrapper WKVRCOptimizer_vertexInput)
{
appdata v = WKVRCOptimizer_vertexInput.v;
WKVRCOptimizer_MeshID = ((uint)v.uv0.z >> 12) - 0;
WKVRCOptimizer_MaterialID = 0xFFF & (uint)v.uv0.z;
vertexOutputWrapper WKVRCOptimizer_vertexOutput = (vertexOutputWrapper)0;
WKVRCOptimizer_vertexOutput.WKVRCOptimizer_MeshMaterialID = WKVRCOptimizer_MaterialID | (WKVRCOptimizer_MeshID << 16);
VertexOut returnWrappedStruct = (VertexOut)0;
if (WKVRCOptimizer_Zero)
{
float WKVRCOptimizer_val = WKVRCOptimizer_Color_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex37.x * WKVRCOptimizer_Color_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex35.x * WKVRCOptimizer_Color_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex33.x * WKVRCOptimizer_Color_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex31.x * WKVRCOptimizer_Color_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex29.x * WKVRCOptimizer_Color_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex27.x * WKVRCOptimizer_Color_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex25.x * WKVRCOptimizer_Color_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex23.x * WKVRCOptimizer_Color_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex21.x * WKVRCOptimizer_Color_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex19.x * WKVRCOptimizer_Color_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex17.x * WKVRCOptimizer_Color_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex15.x * WKVRCOptimizer_Color_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex13.x * WKVRCOptimizer_Color_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex11.x * WKVRCOptimizer_Color_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex9.x * WKVRCOptimizer_Color_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex7.x * WKVRCOptimizer_Color_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex5.x * WKVRCOptimizer_Color_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex3.x * WKVRCOptimizer_Color_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex1.x * WKVRCOptimizer_Color_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex38.x * WKVRCOptimizer_Saturation_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex36.x * WKVRCOptimizer_Saturation_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex34.x * WKVRCOptimizer_Saturation_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex32.x * WKVRCOptimizer_Saturation_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex30.x * WKVRCOptimizer_Saturation_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex28.x * WKVRCOptimizer_Saturation_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex26.x * WKVRCOptimizer_Saturation_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex24.x * WKVRCOptimizer_Saturation_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex22.x * WKVRCOptimizer_Saturation_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex20.x * WKVRCOptimizer_Saturation_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex18.x * WKVRCOptimizer_Saturation_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex16.x * WKVRCOptimizer_Saturation_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex14.x * WKVRCOptimizer_Saturation_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex12.x * WKVRCOptimizer_Saturation_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex10.x * WKVRCOptimizer_Saturation_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex8.x * WKVRCOptimizer_Saturation_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex6.x * WKVRCOptimizer_Saturation_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex4.x * WKVRCOptimizer_Saturation_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex2.x * WKVRCOptimizer_Saturation_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex0.x * WKVRCOptimizer_MainHueShift_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex37.x * WKVRCOptimizer_MainHueShift_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex35.x * WKVRCOptimizer_MainHueShift_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex33.x * WKVRCOptimizer_MainHueShift_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex31.x * WKVRCOptimizer_MainHueShift_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex29.x * WKVRCOptimizer_MainHueShift_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex27.x * WKVRCOptimizer_MainHueShift_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex25.x * WKVRCOptimizer_MainHueShift_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex23.x * WKVRCOptimizer_MainHueShift_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex21.x * WKVRCOptimizer_MainHueShift_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex19.x * WKVRCOptimizer_MainHueShift_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex17.x * WKVRCOptimizer_MainHueShift_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex15.x * WKVRCOptimizer_MainHueShift_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex13.x * WKVRCOptimizer_MainHueShift_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex11.x * WKVRCOptimizer_MainHueShift_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex9.x * WKVRCOptimizer_MainHueShift_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex7.x * WKVRCOptimizer_MainHueShift_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex5.x * WKVRCOptimizer_MainHueShift_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex3.x * WKVRCOptimizer_MainHueShift_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex1.x * WKVRCOptimizer_MainHueShift_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex38.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex36.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex34.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex32.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex30.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex28.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex26.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex24.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex22.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex20.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex18.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex16.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex14.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex12.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex10.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex8.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex6.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex4.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex2.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex0.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex37.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex35.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex33.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex31.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex29.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex27.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex25.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex23.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex21.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex19.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex17.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex15.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex13.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex11.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex9.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex7.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex5.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex3.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex1.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex38.x * WKVRCOptimizer_CubeMapColor_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex36.x * WKVRCOptimizer_CubeMapColor_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex34.x * WKVRCOptimizer_CubeMapColor_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex32.x * WKVRCOptimizer_CubeMapColor_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex30.x * WKVRCOptimizer_CubeMapColor_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex28.x * WKVRCOptimizer_CubeMapColor_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex26.x * WKVRCOptimizer_CubeMapColor_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex24.x * WKVRCOptimizer_CubeMapColor_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex22.x * WKVRCOptimizer_CubeMapColor_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex20.x * WKVRCOptimizer_CubeMapColor_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex18.x * WKVRCOptimizer_CubeMapColor_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex16.x * WKVRCOptimizer_CubeMapColor_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex14.x * WKVRCOptimizer_CubeMapColor_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex12.x * WKVRCOptimizer_CubeMapColor_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex10.x * WKVRCOptimizer_CubeMapColor_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex8.x * WKVRCOptimizer_CubeMapColor_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex6.x * WKVRCOptimizer_CubeMapColor_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex4.x * WKVRCOptimizer_CubeMapColor_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex2.x * WKVRCOptimizer_CubeMapColor_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex0.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex37.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex35.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex33.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex31.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex29.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex27.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex25.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex23.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex21.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex19.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex17.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex15.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex13.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex11.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex9.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex7.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex5.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex3.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex1.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex38.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex36.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex34.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex32.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex30.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex28.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex26.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex24.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex22.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex20.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex18.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex16.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex14.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex12.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex10.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex8.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex6.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex4.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex2.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex0.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex37.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex35.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex33.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex31.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex29.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex27.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex25.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex23.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex21.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex19.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex17.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex15.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex13.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex11.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex9.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex7.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex5.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex3.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex1.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex38.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex36.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex34.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex32.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex30.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex28.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex26.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex24.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex22.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex20.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex18.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex16.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex14.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex12.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex10.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex8.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex6.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex4.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex2.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex0.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex37.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex35.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex33.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex31.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex29.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex27.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex25.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex23.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex21.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex19.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex17.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex15.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex13.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex11.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex9.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex7.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex5.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex3.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex1.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex38.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex36.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex34.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex32.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex30.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex28.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex26.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex24.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex22.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex20.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex18.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex16.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex14.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex12.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex10.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex8.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex6.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex4.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex2.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex0.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex37.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex35.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex33.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex31.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex29.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex27.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex25.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex23.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex21.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex19.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex17.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex15.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex13.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex11.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex9.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex7.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex5.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex3.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex1.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex38.x * WKVRCOptimizer_LightingCap_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex36.x * WKVRCOptimizer_LightingCap_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex34.x * WKVRCOptimizer_LightingCap_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex32.x * WKVRCOptimizer_LightingCap_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex30.x * WKVRCOptimizer_LightingCap_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex28.x * WKVRCOptimizer_LightingCap_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex26.x * WKVRCOptimizer_LightingCap_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex24.x * WKVRCOptimizer_LightingCap_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex22.x * WKVRCOptimizer_LightingCap_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex20.x * WKVRCOptimizer_LightingCap_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex18.x * WKVRCOptimizer_LightingCap_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex16.x * WKVRCOptimizer_LightingCap_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex14.x * WKVRCOptimizer_LightingCap_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex12.x * WKVRCOptimizer_LightingCap_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex10.x * WKVRCOptimizer_LightingCap_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex8.x * WKVRCOptimizer_LightingCap_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex6.x * WKVRCOptimizer_LightingCap_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex4.x * WKVRCOptimizer_LightingCap_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex2.x * WKVRCOptimizer_LightingCap_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex0.x * _IsActiveMesh38;
WKVRCOptimizer_val += _IsActiveMesh37 * _IsActiveMesh36;
WKVRCOptimizer_val += _IsActiveMesh35 * _IsActiveMesh34;
WKVRCOptimizer_val += _IsActiveMesh33 * _IsActiveMesh32;
WKVRCOptimizer_val += _IsActiveMesh31 * _IsActiveMesh30;
WKVRCOptimizer_val += _IsActiveMesh29 * _IsActiveMesh28;
WKVRCOptimizer_val += _IsActiveMesh27 * _IsActiveMesh26;
WKVRCOptimizer_val += _IsActiveMesh25 * _IsActiveMesh24;
WKVRCOptimizer_val += _IsActiveMesh23 * _IsActiveMesh22;
WKVRCOptimizer_val += _IsActiveMesh21 * _IsActiveMesh20;
WKVRCOptimizer_val += _IsActiveMesh19 * _IsActiveMesh18;
WKVRCOptimizer_val += _IsActiveMesh17 * _IsActiveMesh16;
WKVRCOptimizer_val += _IsActiveMesh15 * _IsActiveMesh14;
WKVRCOptimizer_val += _IsActiveMesh13 * _IsActiveMesh12;
WKVRCOptimizer_val += _IsActiveMesh11 * _IsActiveMesh10;
WKVRCOptimizer_val += _IsActiveMesh9 * _IsActiveMesh8;
WKVRCOptimizer_val += _IsActiveMesh7 * _IsActiveMesh6;
WKVRCOptimizer_val += _IsActiveMesh5 * _IsActiveMesh4;
WKVRCOptimizer_val += _IsActiveMesh3 * _IsActiveMesh2;
WKVRCOptimizer_val += _IsActiveMesh1 * _IsActiveMesh0;
WKVRCOptimizer_val += WKVRCOptimizerAnimatedVectors[WKVRCOptimizer_MeshID].x * WKVRCOptimizerAnimatedScalars[WKVRCOptimizer_MeshID];
if (WKVRCOptimizer_val) return WKVRCOptimizer_vertexOutput;
}
if (0.5 > WKVRCOptimizerAnimatedScalars[WKVRCOptimizer_MeshID]) return WKVRCOptimizer_vertexOutput;
shader_is_using_thry_editor = WKVRCOptimizer_MaterialID == 32 ? 69 : 0;
_Mode = WKVRCOptimizerArray_Mode[WKVRCOptimizer_MaterialID];
m_mainCategory = WKVRCOptimizer_MaterialID == 5 ? 0 : 1;
_Color = WKVRCOptimizerArray_Color[WKVRCOptimizer_MaterialID];
shouldSample_MainTex = WKVRCOptimizerArrayshouldSample_MainTex[WKVRCOptimizer_MaterialID];
_MainTex_TexelSize = WKVRCOptimizerArray_MainTex_TexelSize[WKVRCOptimizer_MaterialID];
shouldSample_BumpMap = WKVRCOptimizerArrayshouldSample_BumpMap[WKVRCOptimizer_MaterialID];
_BumpMap_TexelSize = WKVRCOptimizerArray_BumpMap_TexelSize[WKVRCOptimizer_MaterialID];
_BumpMap_ST = WKVRCOptimizerArray_BumpMap_ST[WKVRCOptimizer_MaterialID];
_BumpScale = WKVRCOptimizerArray_BumpScale[WKVRCOptimizer_MaterialID];
shouldSample_AlphaMask = WKVRCOptimizerArrayshouldSample_AlphaMask[WKVRCOptimizer_MaterialID];
_AlphaMask_TexelSize = WKVRCOptimizerArray_AlphaMask_TexelSize[WKVRCOptimizer_MaterialID];
_AlphaMask_ST = WKVRCOptimizer_MaterialID == 31 ? float4(1, 0.6, 0, 0) : float4(1, 1, 0, 0);
_MainAlphaMaskMode = WKVRCOptimizerArray_MainAlphaMaskMode[WKVRCOptimizer_MaterialID];
_Cutoff = WKVRCOptimizerArray_Cutoff[WKVRCOptimizer_MaterialID];
_Saturation = WKVRCOptimizerArray_Saturation[WKVRCOptimizer_MaterialID];
_MainHueShiftToggle = ((1u << WKVRCOptimizer_MaterialID) & 1038106611) != 0 ? 0 : 1;
_AlphaForceOpaque = WKVRCOptimizerArray_AlphaForceOpaque[WKVRCOptimizer_MaterialID];
m_start_DecalSection = WKVRCOptimizer_MaterialID == 3 ? 0 : 1;
shouldSample_DecalMask = WKVRCOptimizer_MaterialID == 2 ? true : false;
_DecalMask_TexelSize = WKVRCOptimizer_MaterialID == 2 ? float4(1.0 / 2048, 1.0 / 2048, 2048, 2048) : float4(1.0 / 4, 1.0 / 4, 4, 4);
_DecalColor = WKVRCOptimizerArray_DecalColor[WKVRCOptimizer_MaterialID];
shouldSample_DecalTexture = ((1u << WKVRCOptimizer_MaterialID) & 61390) != 0 ? true : false;
_DecalTexture_TexelSize = ((1u << WKVRCOptimizer_MaterialID) & 61390) != 0 ? float4(1.0 / 1024, 1.0 / 1024, 1024, 1024) : float4(1.0 / 4, 1.0 / 4, 4, 4);
m_start_PoiShading = WKVRCOptimizerArraym_start_PoiShading[WKVRCOptimizer_MaterialID];
s_start_ShadingAddPass = WKVRCOptimizer_MaterialID == 32 ? 1 : 0;
m_start_matcap = ((1u << WKVRCOptimizer_MaterialID) & 1073627135) != 0 ? 1 : 0;
_MatcapMultiply = WKVRCOptimizer_MaterialID == 6 ? 0.18 : 0.406;
shouldSample_Matcap0NormalMap = WKVRCOptimizer_MaterialID == 5 ? true : false;
_Matcap0NormalMap_TexelSize = WKVRCOptimizer_MaterialID == 5 ? float4(1.0 / 1024, 1.0 / 1024, 1024, 1024) : float4(1.0 / 4, 1.0 / 4, 4, 4);
_CubeMapColor = WKVRCOptimizerArray_CubeMapColor[WKVRCOptimizer_MaterialID];
_CubeMapBlendAmount = WKVRCOptimizer_MaterialID == 10 ? 0.155 : 1;
shouldSample_CubeMapMask = WKVRCOptimizer_MaterialID == 2 ? false : true;
_CubeMapMask_TexelSize = WKVRCOptimizer_MaterialID == 2 ? float4(1.0 / 4, 1.0 / 4, 4, 4) : float4(1.0 / 1024, 1.0 / 1024, 1024, 1024);
_CubeMapMaskInvert = ((1u << WKVRCOptimizer_MaterialID) & 3007) != 0 ? 0 : 1;
m_start_rimLight1Options = WKVRCOptimizer_MaterialID == 15 ? 0 : 1;
_RimBlendStrength = WKVRCOptimizer_MaterialID == 7 ? 0.149 : 0.226;
_RimSharpness = WKVRCOptimizer_MaterialID == 5 ? 0.799 : 0.25;
m_start_brdf = WKVRCOptimizer_MaterialID == 27 ? 0 : 1;
_MochieMetallicMultiplier = WKVRCOptimizer_MaterialID == 4 ? 1 : 0;
_MochieRoughnessMultiplier = WKVRCOptimizerArray_MochieRoughnessMultiplier[WKVRCOptimizer_MaterialID];
m_start_poiSSAO = WKVRCOptimizer_MaterialID == 5 ? 0 : 1;
m_specialFXCategory = WKVRCOptimizer_MaterialID == 5 ? 0 : 1;
m_vertexCategory = WKVRCOptimizerArraym_vertexCategory[WKVRCOptimizer_MaterialID];
m_start_PoiGlobalCategory = WKVRCOptimizer_MaterialID == 31 ? 1 : 0;
m_start_PoiPostProcessingCategory = WKVRCOptimizer_MaterialID == 32 ? 1 : 0;
m_start_PPAnimations = WKVRCOptimizer_MaterialID == 32 ? 1 : 0;
m_renderingCategory = WKVRCOptimizerArraym_renderingCategory[WKVRCOptimizer_MaterialID];
_Cull = WKVRCOptimizer_MaterialID == 5 ? 2 : 0;
_ZWrite = WKVRCOptimizerArray_ZWrite[WKVRCOptimizer_MaterialID];
_RenderingEarlyZEnabled = WKVRCOptimizerArray_RenderingEarlyZEnabled[WKVRCOptimizer_MaterialID];
_SrcBlend = WKVRCOptimizerArray_SrcBlend[WKVRCOptimizer_MaterialID];
_DstBlend = WKVRCOptimizerArray_DstBlend[WKVRCOptimizer_MaterialID];
_AddSrcBlend = WKVRCOptimizerArray_AddSrcBlend[WKVRCOptimizer_MaterialID];
_BlendOpAlpha = WKVRCOptimizerArray_BlendOpAlpha[WKVRCOptimizer_MaterialID];
_DstBlendAlpha = WKVRCOptimizerArray_DstBlendAlpha[WKVRCOptimizer_MaterialID];
_LightingCap = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[39 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _LightingCap : WKVRCOptimizerAnimatedScalars[39 + WKVRCOptimizer_MeshID];
_LightingAdditiveLimit = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[78 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _LightingAdditiveLimit : WKVRCOptimizerAnimatedScalars[78 + WKVRCOptimizer_MeshID];
_LightingMinLightBrightness = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[117 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _LightingMinLightBrightness : WKVRCOptimizerAnimatedScalars[117 + WKVRCOptimizer_MeshID];
_LightingMonochromatic = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[156 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _LightingMonochromatic : WKVRCOptimizerAnimatedScalars[156 + WKVRCOptimizer_MeshID];
_LightingAdditiveMonochromatic = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[195 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _LightingAdditiveMonochromatic : WKVRCOptimizerAnimatedScalars[195 + WKVRCOptimizer_MeshID];
_SSAOIntensity = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[234 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _SSAOIntensity : WKVRCOptimizerAnimatedScalars[234 + WKVRCOptimizer_MeshID];
_LightingEnableLightVolumes = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[273 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _LightingEnableLightVolumes : WKVRCOptimizerAnimatedScalars[273 + WKVRCOptimizer_MeshID];
_SSAOAnimationToggle = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[312 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _SSAOAnimationToggle : WKVRCOptimizerAnimatedScalars[312 + WKVRCOptimizer_MeshID];
_CubeMapColor = isnan(asfloat(asuint(WKVRCOptimizerAnimatedVectors[0 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _CubeMapColor : WKVRCOptimizerAnimatedVectors[0 + WKVRCOptimizer_MeshID];
_CubeMapHueShift = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[351 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _CubeMapHueShift : WKVRCOptimizerAnimatedScalars[351 + WKVRCOptimizer_MeshID];
_DecalBlendAlpha = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[390 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _DecalBlendAlpha : WKVRCOptimizerAnimatedScalars[390 + WKVRCOptimizer_MeshID];
_MainHueShift = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[429 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _MainHueShift : WKVRCOptimizerAnimatedScalars[429 + WKVRCOptimizer_MeshID];
_Saturation = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[468 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _Saturation : WKVRCOptimizerAnimatedScalars[468 + WKVRCOptimizer_MeshID];
_Color = isnan(asfloat(asuint(WKVRCOptimizerAnimatedVectors[39 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _Color : WKVRCOptimizerAnimatedVectors[39 + WKVRCOptimizer_MeshID];
UNITY_SETUP_INSTANCE_ID(v);
VertexOut o;
PoiInitStruct(VertexOut, o);
UNITY_TRANSFER_INSTANCE_ID(v, o);
#ifdef POI_TESSELLATED
UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v);
#endif
UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
#ifdef POI_AUDIOLINK
float vertexAudioLink[5];
vertexAudioLink[0] = 0.0 == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 0))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - 0.0) * 15.95, 0))[0];
vertexAudioLink[1] = 0.0 == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 1))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - 0.0) * 15.95, 1))[0];
vertexAudioLink[2] = 0.0 == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 2))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - 0.0) * 15.95, 2))[0];
vertexAudioLink[3] = 0.0 == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 3))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - 0.0) * 15.95, 3))[0];
vertexAudioLink[4] = AudioLinkData(ALPASS_GENERALVU + float2(8, 0))[0];
#endif
if (1.0)
{
v.vertex.xyz = calcIntrudePos(v.vertex.xyz, v.normal, vertexUV(v, 3.0));
}
o.normal = UnityObjectToWorldNormal(v.normal);
o.tangent.xyz = UnityObjectToWorldDir(v.tangent);
o.tangent.w = v.tangent.w;
o.vertexColor = v.color;
o.uv[0] = float4(v.uv0.xy.xy, v.uv1.xy);
o.uv[1] = float4(v.uv2.xy, v.uv3.xy);
// Skipped 1 lines | #if defined(LIGHTMAP_ON)
// Skipped 1 lines | #ifdef DYNAMICLIGHTMAP_ON
o.localPos = v.vertex;
o.worldPos = mul(unity_ObjectToWorld, o.localPos);
float3 localOffset = float3(0, 0, 0);
float3 worldOffset = float3(0, 0, 0);
o.localPos.rgb += localOffset;
o.worldPos.rgb += worldOffset;
o.pos = UnityObjectToClipPos(o.localPos);
o.fogData.x = o.pos.z;
#ifdef FOG_EXP2
o.fogData.y = 1;
#else
o.fogData.y = 0;
#endif
#ifndef FORWARD_META_PASS
UNITY_TRANSFER_SHADOW(o, o.uv[0].xy);
// Skipped 2 lines
#endif
o.worldDir = dot(o.pos, CalculateFrustumCorrection());
if (0.0)
{
applyReducedRenderClipDistance(o);
}
#ifdef POI_PASS_META
o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST);
#endif
#ifdef POI_PASS_LILFUR
#endif
{
returnWrappedStruct = o;
WKVRCOptimizer_vertexOutput.returnWrappedStruct = returnWrappedStruct;
return WKVRCOptimizer_vertexOutput;
}
}
VertexOut vert(appdata v)
{
UNITY_SETUP_INSTANCE_ID(v);
VertexOut o;
PoiInitStruct(VertexOut, o);
UNITY_TRANSFER_INSTANCE_ID(v, o);
#ifdef POI_TESSELLATED
UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(v);
#endif
UNITY_INITIALIZE_VERTEX_OUTPUT_STEREO(o);
#ifdef POI_AUDIOLINK
float vertexAudioLink[5];
vertexAudioLink[0] = 0.0 == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 0))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - 0.0) * 15.95, 0))[0];
vertexAudioLink[1] = 0.0 == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 1))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - 0.0) * 15.95, 1))[0];
vertexAudioLink[2] = 0.0 == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 2))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - 0.0) * 15.95, 2))[0];
vertexAudioLink[3] = 0.0 == 0 ? AudioLinkData(ALPASS_AUDIOLINK + float2(0, 3))[0] : AudioLinkData(ALPASS_FILTEREDAUDIOLINK + float2((1 - 0.0) * 15.95, 3))[0];
vertexAudioLink[4] = AudioLinkData(ALPASS_GENERALVU + float2(8, 0))[0];
#endif
if (1.0)
{
v.vertex.xyz = calcIntrudePos(v.vertex.xyz, v.normal, vertexUV(v, 3.0));
}
o.normal = UnityObjectToWorldNormal(v.normal);
o.tangent.xyz = UnityObjectToWorldDir(v.tangent);
o.tangent.w = v.tangent.w;
o.vertexColor = v.color;
o.uv[0] = float4(v.uv0.xy.xy, v.uv1.xy);
o.uv[1] = float4(v.uv2.xy, v.uv3.xy);
// Skipped 1 lines | #if defined(LIGHTMAP_ON)
// Skipped 1 lines | #ifdef DYNAMICLIGHTMAP_ON
o.localPos = v.vertex;
o.worldPos = mul(unity_ObjectToWorld, o.localPos);
float3 localOffset = float3(0, 0, 0);
float3 worldOffset = float3(0, 0, 0);
o.localPos.rgb += localOffset;
o.worldPos.rgb += worldOffset;
o.pos = UnityObjectToClipPos(o.localPos);
o.fogData.x = o.pos.z;
#ifdef FOG_EXP2
o.fogData.y = 1;
#else
o.fogData.y = 0;
#endif
#ifndef FORWARD_META_PASS
UNITY_TRANSFER_SHADOW(o, o.uv[0].xy);
// Skipped 2 lines
#endif
o.worldDir = dot(o.pos, CalculateFrustumCorrection());
if (0.0)
{
applyReducedRenderClipDistance(o);
}
#ifdef POI_PASS_META
o.pos = UnityMetaVertexPosition(v.vertex, v.uv1.xy, v.uv2.xy, unity_LightmapST, unity_DynamicLightmapST);
#endif
#ifdef POI_PASS_LILFUR
#endif
return o;
}
#define POI2D_SAMPLER_STOCHASTIC(tex, texSampler, uv, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, uv) : POI2D_SAMPLER(tex, texSampler, uv))
#define POI2D_SAMPLER_PAN_STOCHASTIC(tex, texSampler, uv, pan, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan)) : POI2D_SAMPLER_PAN(tex, texSampler, uv, pan))
#define POI2D_SAMPLER_PANGRAD_STOCHASTIC(tex, texSampler, uv, pan, dx, dy, useStochastic) (useStochastic ? DeliotHeitzSampleTexture(tex, sampler##texSampler, POI_PAN_UV(uv, pan), dx, dy) : POI2D_SAMPLER_PANGRAD(tex, texSampler, uv, pan, dx, dy))
#if !defined(_STOCHASTICMODE_NONE)
float2 StochasticHash2D2D(float2 s)
{
return frac(sin(glsl_mod(float2(dot(s, float2(127.1, 311.7)), dot(s, float2(269.5, 183.3))), 3.14159)) * 43758.5453);
}
#endif
float3x3 DeliotHeitzStochasticUVBW(float2 uv)
{
const float2x2 stochasticSkewedGrid = float2x2(1.0, -0.57735027, 0.0, 1.15470054);
float2 skewUV = mul(stochasticSkewedGrid, uv * 3.4641 * 1.0);
float2 vxID = floor(skewUV);
float3 bary = float3(frac(skewUV), 0);
bary.z = 1.0 - bary.x - bary.y;
float3x3 pos = float3x3( float3(vxID, bary.z), float3(vxID + float2(0, 1), bary.y), float3(vxID + float2(1, 0), bary.x) );
float3x3 neg = float3x3( float3(vxID + float2(1, 1), -bary.z), float3(vxID + float2(1, 0), 1.0 - bary.y), float3(vxID + float2(0, 1), 1.0 - bary.x) );
return (bary.z > 0) ? pos : neg;
}
float4 DeliotHeitzSampleTexture(
Texture2D tex,
SamplerState texSampler,
float2 uv,
float2 dx,
float2 dy
)
{
float3x3 UVBW = DeliotHeitzStochasticUVBW(uv);
return mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[0].xy), dx, dy), UVBW[0].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[1].xy), dx, dy), UVBW[1].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[2].xy), dx, dy), UVBW[2].z) ;
}
float4 DeliotHeitzSampleTexture(
_MainTex_Wrapper tex,
SamplerState texSampler,
float2 uv,
float2 dx,
float2 dy
)
{
float3x3 UVBW = DeliotHeitzStochasticUVBW(uv);
return mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[0].xy), dx, dy), UVBW[0].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[1].xy), dx, dy), UVBW[1].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[2].xy), dx, dy), UVBW[2].z) ;
}
float4 DeliotHeitzSampleTexture(
_BumpMap_Wrapper tex,
SamplerState texSampler,
float2 uv,
float2 dx,
float2 dy
)
{
float3x3 UVBW = DeliotHeitzStochasticUVBW(uv);
return mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[0].xy), dx, dy), UVBW[0].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[1].xy), dx, dy), UVBW[1].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[2].xy), dx, dy), UVBW[2].z) ;
}
float4 DeliotHeitzSampleTexture(
_AlphaMask_Wrapper tex,
SamplerState texSampler,
float2 uv,
float2 dx,
float2 dy
)
{
float3x3 UVBW = DeliotHeitzStochasticUVBW(uv);
return mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[0].xy), dx, dy), UVBW[0].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[1].xy), dx, dy), UVBW[1].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[2].xy), dx, dy), UVBW[2].z) ;
}
float4 DeliotHeitzSampleTexture(
_DecalMask_Wrapper tex,
SamplerState texSampler,
float2 uv,
float2 dx,
float2 dy
)
{
float3x3 UVBW = DeliotHeitzStochasticUVBW(uv);
return mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[0].xy), dx, dy), UVBW[0].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[1].xy), dx, dy), UVBW[1].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[2].xy), dx, dy), UVBW[2].z) ;
}
float4 DeliotHeitzSampleTexture(
_DecalTexture_Wrapper tex,
SamplerState texSampler,
float2 uv,
float2 dx,
float2 dy
)
{
float3x3 UVBW = DeliotHeitzStochasticUVBW(uv);
return mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[0].xy), dx, dy), UVBW[0].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[1].xy), dx, dy), UVBW[1].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[2].xy), dx, dy), UVBW[2].z) ;
}
float4 DeliotHeitzSampleTexture(
_Matcap0NormalMap_Wrapper tex,
SamplerState texSampler,
float2 uv,
float2 dx,
float2 dy
)
{
float3x3 UVBW = DeliotHeitzStochasticUVBW(uv);
return mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[0].xy), dx, dy), UVBW[0].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[1].xy), dx, dy), UVBW[1].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[2].xy), dx, dy), UVBW[2].z) ;
}
float4 DeliotHeitzSampleTexture(
_CubeMapMask_Wrapper tex,
SamplerState texSampler,
float2 uv,
float2 dx,
float2 dy
)
{
float3x3 UVBW = DeliotHeitzStochasticUVBW(uv);
return mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[0].xy), dx, dy), UVBW[0].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[1].xy), dx, dy), UVBW[1].z) + mul(tex.SampleGrad(texSampler, uv + StochasticHash2D2D(UVBW[2].xy), dx, dy), UVBW[2].z) ;
}
float4 DeliotHeitzSampleTexture(
Texture2D tex,
SamplerState texSampler,
float2 uv
)
{
float2 dx = ddx(uv), dy = ddy(uv);
return DeliotHeitzSampleTexture(tex, texSampler, uv, dx, dy);
}
float4 DeliotHeitzSampleTexture(
_MainTex_Wrapper tex,
SamplerState texSampler,
float2 uv
)
{
float2 dx = ddx(uv), dy = ddy(uv);
return DeliotHeitzSampleTexture(tex, texSampler, uv, dx, dy);
}
float4 DeliotHeitzSampleTexture(
_BumpMap_Wrapper tex,
SamplerState texSampler,
float2 uv
)
{
float2 dx = ddx(uv), dy = ddy(uv);
return DeliotHeitzSampleTexture(tex, texSampler, uv, dx, dy);
}
float4 DeliotHeitzSampleTexture(
_AlphaMask_Wrapper tex,
SamplerState texSampler,
float2 uv
)
{
float2 dx = ddx(uv), dy = ddy(uv);
return DeliotHeitzSampleTexture(tex, texSampler, uv, dx, dy);
}
float4 DeliotHeitzSampleTexture(
_DecalMask_Wrapper tex,
SamplerState texSampler,
float2 uv
)
{
float2 dx = ddx(uv), dy = ddy(uv);
return DeliotHeitzSampleTexture(tex, texSampler, uv, dx, dy);
}
float4 DeliotHeitzSampleTexture(
_DecalTexture_Wrapper tex,
SamplerState texSampler,
float2 uv
)
{
float2 dx = ddx(uv), dy = ddy(uv);
return DeliotHeitzSampleTexture(tex, texSampler, uv, dx, dy);
}
float4 DeliotHeitzSampleTexture(
_Matcap0NormalMap_Wrapper tex,
SamplerState texSampler,
float2 uv
)
{
float2 dx = ddx(uv), dy = ddy(uv);
return DeliotHeitzSampleTexture(tex, texSampler, uv, dx, dy);
}
float4 DeliotHeitzSampleTexture(
_CubeMapMask_Wrapper tex,
SamplerState texSampler,
float2 uv
)
{
float2 dx = ddx(uv), dy = ddy(uv);
return DeliotHeitzSampleTexture(tex, texSampler, uv, dx, dy);
}
void applyAlphaOptions(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiMods poiMods)
{
poiFragData.alpha = saturate(poiFragData.alpha + 0.0);
if (0.0 > 0)
{
poiFragData.alpha = maskBlend(poiFragData.alpha, poiMods.globalMask[0.0 - 1], 2.0);
}
}
void calculateGlobalThemes(inout PoiMods poiMods)
{
float4 themeColorExposures = 0;
float4 themeColor0, themeColor1, themeColor2, themeColor3 = 0;
DecomposeHDRColor(float4(1,1,1,1).rgb, themeColor0.rgb, themeColorExposures.x);
DecomposeHDRColor(float4(1,1,1,1).rgb, themeColor1.rgb, themeColorExposures.y);
DecomposeHDRColor(float4(1,1,1,1).rgb, themeColor2.rgb, themeColorExposures.z);
DecomposeHDRColor(float4(1,1,1,1).rgb, themeColor3.rgb, themeColorExposures.w);
poiMods.globalColorTheme[0] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor0.rgb, frac(0.0 + 0.0 * _Time.x), 0.0, 0.0), themeColorExposures.x), float4(1,1,1,1).a);
poiMods.globalColorTheme[1] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor1.rgb, frac(0.0 + 0.0 * _Time.x), 0.0, 0.0), themeColorExposures.y), float4(1,1,1,1).a);
poiMods.globalColorTheme[2] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor2.rgb, frac(0.0 + 0.0 * _Time.x), 0.0, 0.0), themeColorExposures.z), float4(1,1,1,1).a);
poiMods.globalColorTheme[3] = float4(ApplyHDRExposure(ModifyViaHSV(themeColor3.rgb, frac(0.0 + 0.0 * _Time.x), 0.0, 0.0), themeColorExposures.w), float4(1,1,1,1).a);
}
void ApplyGlobalMaskModifiers(in PoiMesh poiMesh, inout PoiMods poiMods, in PoiCam poiCam)
{
}
float2 calculatePolarCoordinate(in PoiMesh poiMesh)
{
float2 delta = poiMesh.uv[0.0] - float4(0.5,0.5,0,0);
float radius = length(delta) * 2 * 1.0;
float angle = atan2(delta.x, delta.y);
float phi = angle / (UNITY_PI * 2.0);
float phi_frac = frac(phi);
angle = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
angle *= 1.0;
return float2(radius, angle + distance(poiMesh.uv[0.0], float4(0.5,0.5,0,0)) * 0.0);
}
float2 MonoPanoProjection(float3 coords)
{
float3 normalizedCoords = normalize(coords);
float latitude = acos(normalizedCoords.y);
float longitude = atan2(normalizedCoords.z, normalizedCoords.x);
float phi = longitude / (UNITY_PI * 2.0);
float phi_frac = frac(phi);
longitude = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
longitude *= 2;
float2 sphereCoords = float2(longitude, latitude) * float2(1.0, 1.0 / UNITY_PI);
sphereCoords = float2(1.0, 1.0) - sphereCoords;
return (sphereCoords + float4(0, 1 - unity_StereoEyeIndex, 1, 1.0).xy) * float4(0, 1 - unity_StereoEyeIndex, 1, 1.0).zw;
}
float2 StereoPanoProjection(float3 coords)
{
float3 normalizedCoords = normalize(coords);
float latitude = acos(normalizedCoords.y);
float longitude = atan2(normalizedCoords.z, normalizedCoords.x);
float phi = longitude / (UNITY_PI * 2.0);
float phi_frac = frac(phi);
longitude = fwidth(phi) - 0.0001 < fwidth(phi_frac) ? phi : phi_frac;
longitude *= 2;
float2 sphereCoords = float2(longitude, latitude) * float2(0.5, 1.0 / UNITY_PI);
sphereCoords = float2(0.5, 1.0) - sphereCoords;
return (sphereCoords + float4(0, 1 - unity_StereoEyeIndex, 1, 0.5).xy) * float4(0, 1 - unity_StereoEyeIndex, 1, 0.5).zw;
}
float2 calculateWorldUV(in PoiMesh poiMesh)
{
return float2(0.0 != 3 ? poiMesh.worldPos[ 0.0] : 0.0f, 2.0 != 3 ? poiMesh.worldPos[2.0] : 0.0f);
}
float2 calculatelocalUV(in PoiMesh poiMesh)
{
float localUVs[8];
localUVs[0] = poiMesh.localPos.x;
localUVs[1] = poiMesh.localPos.y;
localUVs[2] = poiMesh.localPos.z;
localUVs[3] = 0;
localUVs[4] = poiMesh.vertexColor.r;
localUVs[5] = poiMesh.vertexColor.g;
localUVs[6] = poiMesh.vertexColor.b;
localUVs[7] = poiMesh.vertexColor.a;
return float2(localUVs[0.0],localUVs[1.0]);
}
float2 calculatePanosphereUV(in PoiMesh poiMesh)
{
float3 viewDirection = normalize(lerp(getCameraPosition().xyz, _WorldSpaceCameraPos.xyz, 1.0) - poiMesh.worldPos.xyz) * - 1;
return lerp(MonoPanoProjection(viewDirection), StereoPanoProjection(viewDirection), 0.0);
}
float GetRemapMinValue(float scale, float offset)
{
return clamp(-offset / scale, -0.01f, 1.01f);
}
float GetRemapMaxValue(float scale, float offset)
{
return clamp((1.0f - offset) / scale, -0.01f, 1.01f);
}
sampler2D_float unity_NHxRoughness;
half3 BRDF3_Direct(half3 diffColor, half3 specColor, half rlPow4, half smoothness)
{
half LUT_RANGE = 16.0;
half specular = tex2D(unity_NHxRoughness, half2(rlPow4, 1 - smoothness)).r * LUT_RANGE;
#if defined(_SPECULARHIGHLIGHTS_OFF)
specular = 0.0;
#endif
return diffColor + specular * specColor;
}
half3 BRDF3_Indirect(half3 diffColor, half3 specColor, UnityIndirect indirect, half grazingTerm, half fresnelTerm)
{
half3 c = indirect.diffuse * diffColor;
c += indirect.specular * lerp(specColor, grazingTerm, fresnelTerm);
return c;
}
half4 POI_BRDF_PBS(half3 diffColor, half3 specColor, half oneMinusReflectivity, half smoothness, float3 normal, float3 viewDir, UnityLight light, UnityIndirect gi)
{
float3 reflDir = reflect(viewDir, normal);
half nl = saturate(dot(normal, light.dir));
half nv = saturate(dot(normal, viewDir));
half2 rlPow4AndFresnelTerm = Pow4(float2(dot(reflDir, light.dir), 1 - nv));
half rlPow4 = rlPow4AndFresnelTerm.x;
half fresnelTerm = rlPow4AndFresnelTerm.y;
half grazingTerm = saturate(smoothness + (1 - oneMinusReflectivity));
half3 color = BRDF3_Direct(diffColor, specColor, rlPow4, smoothness);
color *= light.color * nl;
color += BRDF3_Indirect(diffColor, specColor, gi, grazingTerm, fresnelTerm);
return half4(color, 1);
}
void calculateShading(inout PoiLight poiLight, inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam)
{
float shadowAttenuation = lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
float attenuation = 1;
#if defined(POINT) || defined(SPOT)
shadowAttenuation = lerp(1, poiLight.additiveShadow, poiLight.attenuationStrength);
#endif
#ifdef POI_PASS_ADD
if (3.0 == 3)
{
#if defined(POINT) || defined(SPOT)
#if defined(_LIGHTINGMODE_REALISTIC) || defined(_LIGHTINGMODE_CLOTH) || defined(_LIGHTINGMODE_WRAPPED)
poiLight.rampedLightMap = max(0, poiLight.nDotL);
poiLight.finalLighting = poiLight.directColor * attenuation * max(0, poiLight.nDotL) * poiLight.detailShadow * shadowAttenuation;
return;
#endif
#endif
}
if (3.0 == 0)
{
poiLight.rampedLightMap = max(0, poiLight.nDotL);
poiLight.finalLighting = poiLight.directColor * attenuation * max(0, poiLight.nDotL) * poiLight.detailShadow * shadowAttenuation;
return;
}
if (3.0 == 1)
{
#if defined(POINT_COOKIE) || defined(DIRECTIONAL_COOKIE)
float passthrough = 0;
#else
float passthrough = _LightingAdditivePassthrough;
#endif
float2 ToonAddGradient = float2(0.0, 0.5);
if (ToonAddGradient.x == ToonAddGradient.y) ToonAddGradient.y += 0.0001;
poiLight.rampedLightMap = smoothstep(ToonAddGradient.y, ToonAddGradient.x, 1 - (.5 * poiLight.nDotL + .5));
#if defined(POINT) || defined(SPOT)
poiLight.finalLighting = lerp(poiLight.directColor * max(min(poiLight.additiveShadow, poiLight.detailShadow), passthrough), poiLight.indirectColor, smoothstep(ToonAddGradient.x, ToonAddGradient.y, 1 - (.5 * poiLight.nDotL + .5)));
#else
poiLight.finalLighting = lerp(poiLight.directColor * max(min(poiLight.attenuation, poiLight.detailShadow), passthrough), poiLight.indirectColor, smoothstep(ToonAddGradient.x, ToonAddGradient.y, 1 - (.5 * poiLight.nDotL + .5)));
#endif
return;
}
#endif
float shadowStrength = 1.0 * poiLight.shadowMask;
#ifdef POI_PASS_OUTLINE
shadowStrength = lerp(0, shadowStrength, 0.0);
#endif
poiLight.finalLighting = poiLight.directColor * attenuation * shadowAttenuation;
if (1.0)
{
poiLight.rampedLightMap = smoothstep(0.4, 0.6, poiLight.nDotLNormalized);
}
else
{
poiLight.rampedLightMap = 1;
}
if (poiFragData.toggleVertexLights)
{
#if defined(VERTEXLIGHT_ON)
float3 vertexLighting = float3(0, 0, 0);
for (int index = 0;
index < 4;
index++)
{
float lightingMode = 3.0;
if (lightingMode == 3)
{
#if defined(_LIGHTINGMODE_REALISTIC)
lightingMode = 0;
#else
lightingMode = 1;
#endif
}
if (lightingMode == 0)
{
vertexLighting = max(vertexLighting, poiLight.vColor[index] * poiLight.vSaturatedDotNL[index] * poiLight.detailShadow);
}
if (lightingMode == 1)
{
float2 ToonAddGradient = float2(0.0, 0.5);
if (ToonAddGradient.x == ToonAddGradient.y) ToonAddGradient.y += 0.0001;
vertexLighting = max(vertexLighting, lerp(poiLight.vColor[index], poiLight.vColor[index] * _LightingAdditivePassthrough, smoothstep(ToonAddGradient.x, ToonAddGradient.y, 1 - (.5 * poiLight.vDotNL[index] + .5))) * poiLight.detailShadow);
}
}
float3 mixedLight = poiLight.finalLighting;
poiLight.finalLighting = max(vertexLighting, poiLight.finalLighting);
#endif
}
}
float2 decalUV(float uvNumber, float2 position, half rotation, half rotationSpeed, half2 scale, float4 scaleOffset, float depth, in float symmetryMode, in float mirroredUVMode, in PoiMesh poiMesh, in PoiCam poiCam)
{
scaleOffset = float4(-scaleOffset.x, scaleOffset.y, -scaleOffset.z, scaleOffset.w);
float2 centerOffset = float2((scaleOffset.x + scaleOffset.y) / 2, (scaleOffset.z + scaleOffset.w) / 2);
float2 uv = poiMesh.uv[uvNumber];
if (symmetryMode == 1) uv.x = abs(uv.x - 0.5) + 0.5;
if (symmetryMode == 2 && uv.x < 0.5) uv.x = uv.x + 0.5;
if ((mirroredUVMode == 1 || mirroredUVMode == 4) && poiMesh.isRightHand) uv.x = 1.0 - uv.x;
if (mirroredUVMode == 2 && poiMesh.isRightHand) uv.x = -1.0;
if ((mirroredUVMode == 3 || mirroredUVMode == 4) && !poiMesh.isRightHand) uv.x = -1.0;
uv += calcParallax(depth + 1, poiCam);
float2 decalCenter = position + centerOffset;
float theta = radians(rotation + _Time.z * rotationSpeed);
float cs = cos(theta);
float sn = sin(theta);
uv = float2((uv.x - decalCenter.x) * cs - (uv.y - decalCenter.y) * sn + decalCenter.x, (uv.x - decalCenter.x) * sn + (uv.y - decalCenter.y) * cs + decalCenter.y);
uv = remap(uv, float2(0, 0) - scale / 2 + position + scaleOffset.xz, scale / 2 + position + scaleOffset.yw, float2(0, 0), float2(1, 1));
return uv;
}
inline float3 decalHueShift(float enabled, float3 color, float shift, float shiftSpeed, float colorSpace, float selectOrShift)
{
if (enabled)
{
color = hueShift(color, shift + _Time.x * shiftSpeed, colorSpace, selectOrShift);
}
return color;
}
inline float applyTilingClipping(float enabled, float2 uv)
{
float ret = 1;
if (!enabled)
{
if (uv.x > 1 || uv.y > 1 || uv.x < 0 || uv.y < 0)
{
ret = 0;
}
}
return ret;
}
struct PoiDecal
{
float m_DecalFaceMask;
float m_DecalMaskChannel;
float m_DecalGlobalMask;
float m_DecalGlobalMaskBlendType;
float m_DecalApplyGlobalMaskIndex;
float m_DecalApplyGlobalMaskBlendType;
float4 m_DecalTexture_ST;
float2 m_DecalTexturePan;
float m_DecalTextureUV;
float4 m_DecalColor;
float m_DecalColorThemeIndex;
fixed m_DecalTiled;
float m_DecalBlendType;
half m_DecalRotation;
half3 m_DecalScale;
float4 m_DecalSideOffset;
half2 m_DecalPosition;
half m_DecalRotationSpeed;
float m_DecalEmissionStrength;
float m_DecalBlendAlpha;
float m_DecalAlphaBlendMode;
float m_DecalHueShiftColorSpace;
float m_DecalHueShiftSelectOrShift;
float m_DecalHueShiftEnabled;
float m_DecalHueShift;
float m_DecalHueShiftSpeed;
float m_DecalDepth;
float m_DecalHueAngleStrength;
float m_DecalChannelSeparationEnable;
float m_DecalChannelSeparation;
float m_DecalChannelSeparationPremultiply;
float m_DecalChannelSeparationHue;
float m_DecalChannelSeparationVertical;
float m_DecalChannelSeparationAngleStrength;
float m_DecalOverrideAlphaMode;
float m_DecalOverrideAlpha;
float m_DecalSymmetryMode;
float m_DecalMirroredUVMode;
#if defined(POI_AUDIOLINK)
half m_AudioLinkDecalScaleBand;
float4 m_AudioLinkDecalScale;
half m_AudioLinkDecalRotationBand;
float2 m_AudioLinkDecalRotation;
half m_AudioLinkDecalAlphaBand;
float2 m_AudioLinkDecalAlpha;
half m_AudioLinkDecalEmissionBand;
float2 m_AudioLinkDecalEmission;
float m_DecalRotationCTALBand;
float m_DecalRotationCTALSpeed;
float m_DecalRotationCTALType;
float m_AudioLinkDecalColorChord;
float m_AudioLinkDecalSideBand;
float4 m_AudioLinkDecalSideMin;
float4 m_AudioLinkDecalSideMax;
float2 m_AudioLinkDecalChannelSeparation;
float m_AudioLinkDecalChannelSeparationBand;
#endif
float4 decalColor;
float2 decalScale;
float decalRotation;
float2 uv;
float4 dduv;
float4 sideMod;
float decalChannelOffset;
float4 decalMask;
void Init(in float4 DecalMask)
{
decalMask = DecalMask;
decalScale = m_DecalScale.xy;
}
void InitAudiolink(in PoiMods poiMods)
{
#ifdef POI_AUDIOLINK
if (poiMods.audioLinkAvailable)
{
decalScale += lerp(m_AudioLinkDecalScale.xy, m_AudioLinkDecalScale.zw, poiMods.audioLink[m_AudioLinkDecalScaleBand]);
sideMod += lerp(m_AudioLinkDecalSideMin, m_AudioLinkDecalSideMax, poiMods.audioLink[m_AudioLinkDecalSideBand]);
decalRotation += lerp(m_AudioLinkDecalRotation.x, m_AudioLinkDecalRotation.y, poiMods.audioLink[m_AudioLinkDecalRotationBand]);
decalRotation += AudioLinkGetChronoTime(m_DecalRotationCTALType, m_DecalRotationCTALBand) * m_DecalRotationCTALSpeed * 360;
decalChannelOffset += lerp(m_AudioLinkDecalChannelSeparation[0], m_AudioLinkDecalChannelSeparation[1], poiMods.audioLink[m_AudioLinkDecalChannelSeparationBand]);
}
#endif
}
void SampleDecalNoTexture(in PoiMods poiMods, in PoiLight poiLight, in PoiMesh poiMesh, in PoiCam poiCam)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
decalColor = float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecal(
sampler2D decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecal(
_MainTex_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecal(
_BumpMap_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecal(
_AlphaMask_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecal(
_DecalMask_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecal(
_DecalTexture_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecal(
_Matcap0NormalMap_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecal(
_CubeMapMask_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalNoAlpha(
sampler2D decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor.rgb = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a).rgb;
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalNoAlpha(
_MainTex_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor.rgb = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a).rgb;
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalNoAlpha(
_BumpMap_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor.rgb = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a).rgb;
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalNoAlpha(
_AlphaMask_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor.rgb = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a).rgb;
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalNoAlpha(
_DecalMask_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor.rgb = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a).rgb;
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalNoAlpha(
_DecalTexture_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor.rgb = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a).rgb;
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalNoAlpha(
_Matcap0NormalMap_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor.rgb = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a).rgb;
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalNoAlpha(
_CubeMapMask_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor.rgb = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a).rgb;
decalColor.rgb = decalHueShift(m_DecalHueShiftEnabled, decalColor.rgb, m_DecalHueShift + poiLight.nDotVCentered * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalAlphaOnly(
sampler2D decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalAlphaOnly(
_MainTex_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalAlphaOnly(
_BumpMap_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalAlphaOnly(
_AlphaMask_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalAlphaOnly(
_DecalMask_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalAlphaOnly(
_DecalTexture_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalAlphaOnly(
_Matcap0NormalMap_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalAlphaOnly(
_CubeMapMask_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam,
float2 scaleMultiplier = float2(1, 1)
)
{
uv = decalUV(m_DecalTextureUV, m_DecalPosition, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale * scaleMultiplier, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduv = any(fwidth(uv) > .5) ? 0.001 : float4(ddx(uv) * m_DecalTexture_ST.x, ddy(uv) * m_DecalTexture_ST.y);
decalColor = tex2D(decalTexture, poiUV(uv, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduv.xy, dduv.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * applyTilingClipping(m_DecalTiled, uv);
}
void SampleDecalChannelSeparation(
sampler2D decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam
)
{
decalColor = float4(0, 0, 0, 1);
decalChannelOffset += m_DecalChannelSeparation + m_DecalChannelSeparationAngleStrength * (m_DecalChannelSeparationAngleStrength > 0 ? (1 - poiLight.nDotV) : poiLight.nDotV);
float2 positionOffset = decalChannelOffset * 0.01 * (decalScale.x + decalScale.y) * float2(cos(m_DecalChannelSeparationVertical), sin(m_DecalChannelSeparationVertical));
float2 uvSample0 = decalUV(m_DecalTextureUV, m_DecalPosition + positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float2 uvSample1 = decalUV(m_DecalTextureUV, m_DecalPosition - positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduvSample0 = any(fwidth(uvSample0) > .5) ? 0.001 : float4(ddx(uvSample0) * m_DecalTexture_ST.x, ddy(uvSample0) * m_DecalTexture_ST.y);
float4 dduvSample1 = any(fwidth(uvSample1) > .5) ? 0.001 : float4(ddx(uvSample1) * m_DecalTexture_ST.x, ddy(uvSample1) * m_DecalTexture_ST.y);
float4 sample0 = tex2D(decalTexture, poiUV(uvSample0, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample0.xy, dduvSample0.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
float4 sample1 = tex2D(decalTexture, poiUV(uvSample1, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample1.xy, dduvSample1.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
sample0.rgb = decalHueShift(m_DecalHueShiftEnabled, sample0.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
sample1.rgb = decalHueShift(m_DecalHueShiftEnabled, sample1.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
float3 channelSeparationColor = HUEtoRGB(frac(m_DecalChannelSeparationHue));
if (m_DecalChannelSeparationPremultiply)
{
decalColor.rgb = lerp(sample0 * sample0.a, sample1 * sample1.a, channelSeparationColor);
}
else
{
decalColor.rgb = lerp(sample0, sample1, channelSeparationColor);
}
decalColor.a = 0.5 * (sample0.a + sample1.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * max(applyTilingClipping(m_DecalTiled, uvSample0), applyTilingClipping(m_DecalTiled, uvSample1));
}
void SampleDecalChannelSeparation(
_MainTex_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam
)
{
decalColor = float4(0, 0, 0, 1);
decalChannelOffset += m_DecalChannelSeparation + m_DecalChannelSeparationAngleStrength * (m_DecalChannelSeparationAngleStrength > 0 ? (1 - poiLight.nDotV) : poiLight.nDotV);
float2 positionOffset = decalChannelOffset * 0.01 * (decalScale.x + decalScale.y) * float2(cos(m_DecalChannelSeparationVertical), sin(m_DecalChannelSeparationVertical));
float2 uvSample0 = decalUV(m_DecalTextureUV, m_DecalPosition + positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float2 uvSample1 = decalUV(m_DecalTextureUV, m_DecalPosition - positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduvSample0 = any(fwidth(uvSample0) > .5) ? 0.001 : float4(ddx(uvSample0) * m_DecalTexture_ST.x, ddy(uvSample0) * m_DecalTexture_ST.y);
float4 dduvSample1 = any(fwidth(uvSample1) > .5) ? 0.001 : float4(ddx(uvSample1) * m_DecalTexture_ST.x, ddy(uvSample1) * m_DecalTexture_ST.y);
float4 sample0 = tex2D(decalTexture, poiUV(uvSample0, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample0.xy, dduvSample0.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
float4 sample1 = tex2D(decalTexture, poiUV(uvSample1, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample1.xy, dduvSample1.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
sample0.rgb = decalHueShift(m_DecalHueShiftEnabled, sample0.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
sample1.rgb = decalHueShift(m_DecalHueShiftEnabled, sample1.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
float3 channelSeparationColor = HUEtoRGB(frac(m_DecalChannelSeparationHue));
if (m_DecalChannelSeparationPremultiply)
{
decalColor.rgb = lerp(sample0 * sample0.a, sample1 * sample1.a, channelSeparationColor);
}
else
{
decalColor.rgb = lerp(sample0, sample1, channelSeparationColor);
}
decalColor.a = 0.5 * (sample0.a + sample1.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * max(applyTilingClipping(m_DecalTiled, uvSample0), applyTilingClipping(m_DecalTiled, uvSample1));
}
void SampleDecalChannelSeparation(
_BumpMap_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam
)
{
decalColor = float4(0, 0, 0, 1);
decalChannelOffset += m_DecalChannelSeparation + m_DecalChannelSeparationAngleStrength * (m_DecalChannelSeparationAngleStrength > 0 ? (1 - poiLight.nDotV) : poiLight.nDotV);
float2 positionOffset = decalChannelOffset * 0.01 * (decalScale.x + decalScale.y) * float2(cos(m_DecalChannelSeparationVertical), sin(m_DecalChannelSeparationVertical));
float2 uvSample0 = decalUV(m_DecalTextureUV, m_DecalPosition + positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float2 uvSample1 = decalUV(m_DecalTextureUV, m_DecalPosition - positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduvSample0 = any(fwidth(uvSample0) > .5) ? 0.001 : float4(ddx(uvSample0) * m_DecalTexture_ST.x, ddy(uvSample0) * m_DecalTexture_ST.y);
float4 dduvSample1 = any(fwidth(uvSample1) > .5) ? 0.001 : float4(ddx(uvSample1) * m_DecalTexture_ST.x, ddy(uvSample1) * m_DecalTexture_ST.y);
float4 sample0 = tex2D(decalTexture, poiUV(uvSample0, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample0.xy, dduvSample0.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
float4 sample1 = tex2D(decalTexture, poiUV(uvSample1, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample1.xy, dduvSample1.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
sample0.rgb = decalHueShift(m_DecalHueShiftEnabled, sample0.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
sample1.rgb = decalHueShift(m_DecalHueShiftEnabled, sample1.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
float3 channelSeparationColor = HUEtoRGB(frac(m_DecalChannelSeparationHue));
if (m_DecalChannelSeparationPremultiply)
{
decalColor.rgb = lerp(sample0 * sample0.a, sample1 * sample1.a, channelSeparationColor);
}
else
{
decalColor.rgb = lerp(sample0, sample1, channelSeparationColor);
}
decalColor.a = 0.5 * (sample0.a + sample1.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * max(applyTilingClipping(m_DecalTiled, uvSample0), applyTilingClipping(m_DecalTiled, uvSample1));
}
void SampleDecalChannelSeparation(
_AlphaMask_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam
)
{
decalColor = float4(0, 0, 0, 1);
decalChannelOffset += m_DecalChannelSeparation + m_DecalChannelSeparationAngleStrength * (m_DecalChannelSeparationAngleStrength > 0 ? (1 - poiLight.nDotV) : poiLight.nDotV);
float2 positionOffset = decalChannelOffset * 0.01 * (decalScale.x + decalScale.y) * float2(cos(m_DecalChannelSeparationVertical), sin(m_DecalChannelSeparationVertical));
float2 uvSample0 = decalUV(m_DecalTextureUV, m_DecalPosition + positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float2 uvSample1 = decalUV(m_DecalTextureUV, m_DecalPosition - positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduvSample0 = any(fwidth(uvSample0) > .5) ? 0.001 : float4(ddx(uvSample0) * m_DecalTexture_ST.x, ddy(uvSample0) * m_DecalTexture_ST.y);
float4 dduvSample1 = any(fwidth(uvSample1) > .5) ? 0.001 : float4(ddx(uvSample1) * m_DecalTexture_ST.x, ddy(uvSample1) * m_DecalTexture_ST.y);
float4 sample0 = tex2D(decalTexture, poiUV(uvSample0, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample0.xy, dduvSample0.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
float4 sample1 = tex2D(decalTexture, poiUV(uvSample1, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample1.xy, dduvSample1.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
sample0.rgb = decalHueShift(m_DecalHueShiftEnabled, sample0.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
sample1.rgb = decalHueShift(m_DecalHueShiftEnabled, sample1.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
float3 channelSeparationColor = HUEtoRGB(frac(m_DecalChannelSeparationHue));
if (m_DecalChannelSeparationPremultiply)
{
decalColor.rgb = lerp(sample0 * sample0.a, sample1 * sample1.a, channelSeparationColor);
}
else
{
decalColor.rgb = lerp(sample0, sample1, channelSeparationColor);
}
decalColor.a = 0.5 * (sample0.a + sample1.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * max(applyTilingClipping(m_DecalTiled, uvSample0), applyTilingClipping(m_DecalTiled, uvSample1));
}
void SampleDecalChannelSeparation(
_DecalMask_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam
)
{
decalColor = float4(0, 0, 0, 1);
decalChannelOffset += m_DecalChannelSeparation + m_DecalChannelSeparationAngleStrength * (m_DecalChannelSeparationAngleStrength > 0 ? (1 - poiLight.nDotV) : poiLight.nDotV);
float2 positionOffset = decalChannelOffset * 0.01 * (decalScale.x + decalScale.y) * float2(cos(m_DecalChannelSeparationVertical), sin(m_DecalChannelSeparationVertical));
float2 uvSample0 = decalUV(m_DecalTextureUV, m_DecalPosition + positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float2 uvSample1 = decalUV(m_DecalTextureUV, m_DecalPosition - positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduvSample0 = any(fwidth(uvSample0) > .5) ? 0.001 : float4(ddx(uvSample0) * m_DecalTexture_ST.x, ddy(uvSample0) * m_DecalTexture_ST.y);
float4 dduvSample1 = any(fwidth(uvSample1) > .5) ? 0.001 : float4(ddx(uvSample1) * m_DecalTexture_ST.x, ddy(uvSample1) * m_DecalTexture_ST.y);
float4 sample0 = tex2D(decalTexture, poiUV(uvSample0, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample0.xy, dduvSample0.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
float4 sample1 = tex2D(decalTexture, poiUV(uvSample1, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample1.xy, dduvSample1.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
sample0.rgb = decalHueShift(m_DecalHueShiftEnabled, sample0.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
sample1.rgb = decalHueShift(m_DecalHueShiftEnabled, sample1.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
float3 channelSeparationColor = HUEtoRGB(frac(m_DecalChannelSeparationHue));
if (m_DecalChannelSeparationPremultiply)
{
decalColor.rgb = lerp(sample0 * sample0.a, sample1 * sample1.a, channelSeparationColor);
}
else
{
decalColor.rgb = lerp(sample0, sample1, channelSeparationColor);
}
decalColor.a = 0.5 * (sample0.a + sample1.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * max(applyTilingClipping(m_DecalTiled, uvSample0), applyTilingClipping(m_DecalTiled, uvSample1));
}
void SampleDecalChannelSeparation(
_DecalTexture_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam
)
{
decalColor = float4(0, 0, 0, 1);
decalChannelOffset += m_DecalChannelSeparation + m_DecalChannelSeparationAngleStrength * (m_DecalChannelSeparationAngleStrength > 0 ? (1 - poiLight.nDotV) : poiLight.nDotV);
float2 positionOffset = decalChannelOffset * 0.01 * (decalScale.x + decalScale.y) * float2(cos(m_DecalChannelSeparationVertical), sin(m_DecalChannelSeparationVertical));
float2 uvSample0 = decalUV(m_DecalTextureUV, m_DecalPosition + positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float2 uvSample1 = decalUV(m_DecalTextureUV, m_DecalPosition - positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduvSample0 = any(fwidth(uvSample0) > .5) ? 0.001 : float4(ddx(uvSample0) * m_DecalTexture_ST.x, ddy(uvSample0) * m_DecalTexture_ST.y);
float4 dduvSample1 = any(fwidth(uvSample1) > .5) ? 0.001 : float4(ddx(uvSample1) * m_DecalTexture_ST.x, ddy(uvSample1) * m_DecalTexture_ST.y);
float4 sample0 = tex2D(decalTexture, poiUV(uvSample0, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample0.xy, dduvSample0.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
float4 sample1 = tex2D(decalTexture, poiUV(uvSample1, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample1.xy, dduvSample1.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
sample0.rgb = decalHueShift(m_DecalHueShiftEnabled, sample0.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
sample1.rgb = decalHueShift(m_DecalHueShiftEnabled, sample1.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
float3 channelSeparationColor = HUEtoRGB(frac(m_DecalChannelSeparationHue));
if (m_DecalChannelSeparationPremultiply)
{
decalColor.rgb = lerp(sample0 * sample0.a, sample1 * sample1.a, channelSeparationColor);
}
else
{
decalColor.rgb = lerp(sample0, sample1, channelSeparationColor);
}
decalColor.a = 0.5 * (sample0.a + sample1.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * max(applyTilingClipping(m_DecalTiled, uvSample0), applyTilingClipping(m_DecalTiled, uvSample1));
}
void SampleDecalChannelSeparation(
_Matcap0NormalMap_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam
)
{
decalColor = float4(0, 0, 0, 1);
decalChannelOffset += m_DecalChannelSeparation + m_DecalChannelSeparationAngleStrength * (m_DecalChannelSeparationAngleStrength > 0 ? (1 - poiLight.nDotV) : poiLight.nDotV);
float2 positionOffset = decalChannelOffset * 0.01 * (decalScale.x + decalScale.y) * float2(cos(m_DecalChannelSeparationVertical), sin(m_DecalChannelSeparationVertical));
float2 uvSample0 = decalUV(m_DecalTextureUV, m_DecalPosition + positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float2 uvSample1 = decalUV(m_DecalTextureUV, m_DecalPosition - positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduvSample0 = any(fwidth(uvSample0) > .5) ? 0.001 : float4(ddx(uvSample0) * m_DecalTexture_ST.x, ddy(uvSample0) * m_DecalTexture_ST.y);
float4 dduvSample1 = any(fwidth(uvSample1) > .5) ? 0.001 : float4(ddx(uvSample1) * m_DecalTexture_ST.x, ddy(uvSample1) * m_DecalTexture_ST.y);
float4 sample0 = tex2D(decalTexture, poiUV(uvSample0, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample0.xy, dduvSample0.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
float4 sample1 = tex2D(decalTexture, poiUV(uvSample1, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample1.xy, dduvSample1.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
sample0.rgb = decalHueShift(m_DecalHueShiftEnabled, sample0.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
sample1.rgb = decalHueShift(m_DecalHueShiftEnabled, sample1.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
float3 channelSeparationColor = HUEtoRGB(frac(m_DecalChannelSeparationHue));
if (m_DecalChannelSeparationPremultiply)
{
decalColor.rgb = lerp(sample0 * sample0.a, sample1 * sample1.a, channelSeparationColor);
}
else
{
decalColor.rgb = lerp(sample0, sample1, channelSeparationColor);
}
decalColor.a = 0.5 * (sample0.a + sample1.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * max(applyTilingClipping(m_DecalTiled, uvSample0), applyTilingClipping(m_DecalTiled, uvSample1));
}
void SampleDecalChannelSeparation(
_CubeMapMask_Wrapper decalTexture,
in PoiMods poiMods,
in PoiLight poiLight,
in PoiMesh poiMesh,
in PoiCam poiCam
)
{
decalColor = float4(0, 0, 0, 1);
decalChannelOffset += m_DecalChannelSeparation + m_DecalChannelSeparationAngleStrength * (m_DecalChannelSeparationAngleStrength > 0 ? (1 - poiLight.nDotV) : poiLight.nDotV);
float2 positionOffset = decalChannelOffset * 0.01 * (decalScale.x + decalScale.y) * float2(cos(m_DecalChannelSeparationVertical), sin(m_DecalChannelSeparationVertical));
float2 uvSample0 = decalUV(m_DecalTextureUV, m_DecalPosition + positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float2 uvSample1 = decalUV(m_DecalTextureUV, m_DecalPosition - positionOffset, m_DecalRotation + decalRotation, m_DecalRotationSpeed, decalScale, m_DecalSideOffset +sideMod, m_DecalDepth, m_DecalSymmetryMode, m_DecalMirroredUVMode, poiMesh, poiCam);
float4 dduvSample0 = any(fwidth(uvSample0) > .5) ? 0.001 : float4(ddx(uvSample0) * m_DecalTexture_ST.x, ddy(uvSample0) * m_DecalTexture_ST.y);
float4 dduvSample1 = any(fwidth(uvSample1) > .5) ? 0.001 : float4(ddx(uvSample1) * m_DecalTexture_ST.x, ddy(uvSample1) * m_DecalTexture_ST.y);
float4 sample0 = tex2D(decalTexture, poiUV(uvSample0, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample0.xy, dduvSample0.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
float4 sample1 = tex2D(decalTexture, poiUV(uvSample1, m_DecalTexture_ST) + m_DecalTexturePan * _Time.x, dduvSample1.xy, dduvSample1.zw) * float4(poiThemeColor(poiMods, m_DecalColor.rgb, m_DecalColorThemeIndex), m_DecalColor.a);
sample0.rgb = decalHueShift(m_DecalHueShiftEnabled, sample0.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
sample1.rgb = decalHueShift(m_DecalHueShiftEnabled, sample1.rgb, m_DecalHueShift + poiLight.nDotV * m_DecalHueAngleStrength, m_DecalHueShiftSpeed, m_DecalHueShiftColorSpace, m_DecalHueShiftSelectOrShift);
float3 channelSeparationColor = HUEtoRGB(frac(m_DecalChannelSeparationHue));
if (m_DecalChannelSeparationPremultiply)
{
decalColor.rgb = lerp(sample0 * sample0.a, sample1 * sample1.a, channelSeparationColor);
}
else
{
decalColor.rgb = lerp(sample0, sample1, channelSeparationColor);
}
decalColor.a = 0.5 * (sample0.a + sample1.a);
decalColor.a *= decalMask[m_DecalMaskChannel] * max(applyTilingClipping(m_DecalTiled, uvSample0), applyTilingClipping(m_DecalTiled, uvSample1));
}
void Apply(inout float alphaOverride, inout float decalAlpha, inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, inout PoiMods poiMods, in PoiLight poiLight)
{
if (m_DecalGlobalMask > 0)
{
decalColor.a = maskBlend(decalColor.a, poiMods.globalMask[m_DecalGlobalMask - 1], m_DecalGlobalMaskBlendType);
}
if (m_DecalMirroredUVMode == 2 && poiMesh.isRightHand) decalColor.a = 0;
if ((m_DecalMirroredUVMode == 3 || m_DecalMirroredUVMode == 4) && !poiMesh.isRightHand) decalColor.a = 0;
float audioLinkDecalAlpha = 0;
float audioLinkDecalEmission = 0;
#ifdef POI_AUDIOLINK
audioLinkDecalEmission = lerp(m_AudioLinkDecalEmission.x, m_AudioLinkDecalEmission.y, poiMods.audioLink[m_AudioLinkDecalEmissionBand]) * poiMods.audioLinkAvailable;
if (m_AudioLinkDecalColorChord)
{
if (poiMods.audioLinkAvailable)
{
decalColor.rgb *= AudioLinkLerp(ALPASS_CCSTRIP + float2(uv.x * AUDIOLINK_WIDTH, 0)).rgb;
}
else
{
decalAlpha = 0;
}
}
audioLinkDecalAlpha = lerp(m_AudioLinkDecalAlpha.x, m_AudioLinkDecalAlpha.y, poiMods.audioLink[m_AudioLinkDecalAlphaBand]) * poiMods.audioLinkAvailable;
#endif
if (m_DecalFaceMask > 0)
{
if (m_DecalFaceMask == 1 && !poiMesh.isFrontFace)
{
decalColor.a *= 0;
}
else if (m_DecalFaceMask == 2 && poiMesh.isFrontFace)
{
decalColor.a *= 0;
}
}
float decalAlphaMixed = decalColor.a * saturate(m_DecalBlendAlpha + audioLinkDecalAlpha);
if (m_DecalOverrideAlpha)
{
float finalAlpha = decalAlphaMixed;
float maskWeight = decalMask[m_DecalMaskChannel];
if (m_DecalGlobalMask > 0)
{
maskWeight = maskBlend(maskWeight, poiMods.globalMask[m_DecalGlobalMask - 1], m_DecalGlobalMaskBlendType);
}
bool applyMask = (m_DecalOverrideAlphaMode == 2 || m_DecalOverrideAlphaMode == 3);
bool checkBounds = (m_DecalOverrideAlphaMode == 1 || m_DecalOverrideAlphaMode == 3) && !m_DecalTiled;
if (!checkBounds || (uv.x > 0 && uv.x < 1 && uv.y > 0 && uv.y < 1))
{
float weight = applyMask ? maskWeight : 1.0;
if (m_DecalOverrideAlpha == 1) poiFragData.alpha = lerp(poiFragData.alpha, finalAlpha, weight);
if (m_DecalOverrideAlpha == 2) poiFragData.alpha = lerp(poiFragData.alpha, saturate(poiFragData.alpha * finalAlpha), weight);
if (m_DecalOverrideAlpha == 3) poiFragData.alpha = lerp(poiFragData.alpha, saturate(poiFragData.alpha + finalAlpha), weight);
if (m_DecalOverrideAlpha == 4) poiFragData.alpha = lerp(poiFragData.alpha, saturate(poiFragData.alpha - finalAlpha), weight);
if (m_DecalOverrideAlpha == 5) poiFragData.alpha = lerp(poiFragData.alpha, min(poiFragData.alpha, finalAlpha), weight);
if (m_DecalOverrideAlpha == 6) poiFragData.alpha = lerp(poiFragData.alpha, max(poiFragData.alpha, finalAlpha), weight);
}
}
if (m_DecalApplyGlobalMaskIndex > 0)
{
applyToGlobalMask(poiMods, m_DecalApplyGlobalMaskIndex - 1, m_DecalApplyGlobalMaskBlendType, decalAlphaMixed);
}
poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, customBlend(poiFragData.baseColor.rgb, decalColor.rgb, m_DecalBlendType), decalAlphaMixed);
poiFragData.emission += decalColor.rgb * decalColor.a * max(m_DecalEmissionStrength + audioLinkDecalEmission, 0);
}
float2 GetVideoAspectRatio(float2 videoDimensions, float CorrectionType, float fitToScale)
{
float2 AspectRatioMultiplier = float2(1, 1);
if (fitToScale)
{
float2 decalScale = m_DecalScale.xy + float2(m_DecalSideOffset.x + m_DecalSideOffset.y, m_DecalSideOffset.z + m_DecalSideOffset.w);
if (decalScale.x > decalScale.y)
{
videoDimensions.xy *= float2((decalScale.y / decalScale.x), 1);
}
else
{
videoDimensions.xy *= float2(1, (decalScale.x / decalScale.y));
}
}
if (CorrectionType != 2)
{
if (CorrectionType == 0)
{
if (videoDimensions.x > videoDimensions.y)
{
AspectRatioMultiplier = float2(1, videoDimensions.y / videoDimensions.x);
}
else
{
AspectRatioMultiplier = float2(videoDimensions.x / videoDimensions.y, 1);
}
}
else if (CorrectionType == 1)
{
if (videoDimensions.x > videoDimensions.y)
{
AspectRatioMultiplier = float2(1 / (videoDimensions.y / videoDimensions.x), 1);
}
else
{
AspectRatioMultiplier = float2(1, 1 / (videoDimensions.x / videoDimensions.y));
}
}
}
return AspectRatioMultiplier;
}
}
;
void applyDecals(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, inout PoiMods poiMods, in PoiLight poiLight)
{
float udonVideoTexAvailable = 0;
float2 udonVideoAspectRatio = 1;
if (_Udon_VideoTex_TexelSize.z > 16)
{
udonVideoTexAvailable = 1;
}
float decalAlpha = 1;
float alphaOverride = 0;
#if defined(PROP_DECALMASK)
float4 decalMask = POI2D_SAMPLER_PAN(_DecalMask, _MainTex, poiUV(poiMesh.uv[0.0], float4(1,1,0,0)), float4(0,0,0,0));
#else
float4 decalMask = 1;
#endif
#ifdef TPS_Penetrator
if (0.0)
{
decalMask.r = lerp(0, decalMask.r * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), 1.0);
decalMask.g = lerp(0, decalMask.g * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), 1.0);
decalMask.b = lerp(0, decalMask.b * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), 1.0);
decalMask.a = lerp(0, decalMask.a * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), 1.0);
}
#endif
float4 decalColor = 1;
float2 uv = 0;
PoiDecal Decal0;
PoiInitStruct(PoiDecal, Decal0) Decal0.m_DecalFaceMask = 0.0;
Decal0.m_DecalMaskChannel = 0.0;
Decal0.m_DecalGlobalMask = 0.0;
Decal0.m_DecalGlobalMaskBlendType = 2.0;
Decal0.m_DecalApplyGlobalMaskIndex = 0.0;
Decal0.m_DecalApplyGlobalMaskBlendType = 0.0;
Decal0.m_DecalTexture_ST = float4(1,1,0,0);
Decal0.m_DecalTexturePan = float4(0,0,0,0);
Decal0.m_DecalTextureUV = 0.0;
Decal0.m_DecalColor = float4(1,1,1,1);
Decal0.m_DecalColorThemeIndex = 0.0;
Decal0.m_DecalTiled = 0.0;
Decal0.m_DecalBlendType = 0.0;
Decal0.m_DecalRotation = 0.0;
Decal0.m_DecalScale = float4(1,1,1,0);
Decal0.m_DecalSideOffset = float4(0,0,0,0);
Decal0.m_DecalPosition = float4(0.5,0.5,0,0);
Decal0.m_DecalRotationSpeed = 0.0;
Decal0.m_DecalEmissionStrength = 0.0;
Decal0.m_DecalBlendAlpha = _DecalBlendAlpha;
Decal0.m_DecalOverrideAlpha = 0.0;
Decal0.m_DecalHueShiftEnabled = 0.0;
Decal0.m_DecalHueShiftColorSpace = 0.0;
Decal0.m_DecalHueShiftSelectOrShift = 1.0;
Decal0.m_DecalHueShift = 0.0;
Decal0.m_DecalHueShiftSpeed = 0.0;
Decal0.m_DecalDepth = 0.0;
Decal0.m_DecalHueAngleStrength = 0.0;
Decal0.m_DecalChannelSeparationEnable = 0.0;
Decal0.m_DecalChannelSeparation = 0.0;
Decal0.m_DecalChannelSeparationPremultiply = 0.0;
Decal0.m_DecalChannelSeparationHue = 0.0;
Decal0.m_DecalChannelSeparationVertical = 0.0;
Decal0.m_DecalChannelSeparationAngleStrength = 0.0;
Decal0.m_DecalOverrideAlphaMode = 0.0;
Decal0.m_DecalMirroredUVMode = 0.0;
Decal0.m_DecalSymmetryMode = 0.0;
Decal0.Init(decalMask);
#if defined(POI_AUDIOLINK)
Decal0.m_AudioLinkDecalScaleBand = 0.0;
Decal0.m_AudioLinkDecalScale = float4(0,0,0,0);
Decal0.m_AudioLinkDecalRotationBand = 0.0;
Decal0.m_AudioLinkDecalRotation = float4(0,0,0,0);
Decal0.m_AudioLinkDecalAlphaBand = 0.0;
Decal0.m_AudioLinkDecalAlpha = float4(0,0,0,0);
Decal0.m_AudioLinkDecalEmissionBand = 0.0;
Decal0.m_AudioLinkDecalEmission = float4(0,0,0,0);
Decal0.m_DecalRotationCTALBand = 0.0;
Decal0.m_DecalRotationCTALSpeed = 0.0;
Decal0.m_DecalRotationCTALType = 0.0;
Decal0.m_AudioLinkDecalColorChord = 0.0;
Decal0.m_AudioLinkDecalSideBand = 0.0;
Decal0.m_AudioLinkDecalSideMin = float4(0,0,0,0);
Decal0.m_AudioLinkDecalSideMax = float4(0,0,0,0);
Decal0.m_AudioLinkDecalChannelSeparation = float4(0,0,0,0);
Decal0.m_AudioLinkDecalChannelSeparationBand = 0.0;
Decal0.InitAudiolink(poiMods);
#endif
if (!0.0)
{
if (!0.0)
{
Decal0.SampleDecal(_DecalTexture, poiMods, poiLight, poiMesh, poiCam);
}
// Skipped 1 lines
Decal0.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
}
else
{
udonVideoAspectRatio = Decal0.GetVideoAspectRatio(_Udon_VideoTex_TexelSize.zw, 0.0, 1.0);
if (0.0)
{
if (udonVideoTexAvailable)
{
Decal0.m_DecalEmissionStrength += 0.0;
if (0.0)
{
Decal0.SampleDecal(_DecalTexture, poiMods, poiLight, poiMesh, poiCam);
Decal0.SampleDecalNoAlpha(_Udon_VideoTex, poiMods, poiLight, poiMesh, poiCam, udonVideoAspectRatio);
}
else
{
Decal0.SampleDecal(_Udon_VideoTex, poiMods, poiLight, poiMesh, poiCam, udonVideoAspectRatio);
}
Decal0.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
}
}
else
{
Decal0.SampleDecal(_DecalTexture, poiMods, poiLight, poiMesh, poiCam);
if (udonVideoTexAvailable)
{
Decal0.m_DecalEmissionStrength += 0.0;
if (0.0)
{
Decal0.SampleDecalNoAlpha(_Udon_VideoTex, poiMods, poiLight, poiMesh, poiCam, udonVideoAspectRatio);
}
else
{
Decal0.SampleDecal(_Udon_VideoTex, poiMods, poiLight, poiMesh, poiCam, udonVideoAspectRatio);
}
}
Decal0.Apply(alphaOverride, decalAlpha, poiFragData, poiMesh, poiCam, poiMods, poiLight);
}
}
}
void blendMatcap(inout PoiLight poiLight, inout PoiFragData poiFragData, in PoiMods poiMods, float add, float lightAdd, float multiply, float replace, float mixed, float screen, float4 matcapColor, float matcapMask, float emissionStrength, float matcapLightMask, uint globalMaskIndex, float globalMaskBlendType, in MatcapAudioLinkData matcapALD)
{
if (matcapLightMask)
{
matcapMask *= lerp(1, poiLight.rampedLightMap, matcapLightMask);
}
if (globalMaskIndex > 0)
{
matcapMask = maskBlend(matcapMask, poiMods.globalMask[globalMaskIndex - 1], globalMaskBlendType);
}
#ifdef POI_AUDIOLINK
if (matcapALD.matcapALEnabled > 0)
{
matcapColor.a = saturate(matcapColor.a + lerp(matcapALD.matcapALAlphaAdd.x, matcapALD.matcapALAlphaAdd.y, poiMods.audioLink[matcapALD.matcapALAlphaAddBand]));
emissionStrength += lerp(matcapALD.matcapALEmissionAdd.x, matcapALD.matcapALEmissionAdd.y, poiMods.audioLink[matcapALD.matcapALEmissionAddBand]);
}
#endif
poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, matcapColor.rgb, replace * matcapMask * matcapColor.a * .999999);
poiFragData.baseColor.rgb *= lerp(1, matcapColor.rgb, multiply * matcapMask * matcapColor.a);
poiFragData.baseColor.rgb += matcapColor.rgb * add * matcapMask * matcapColor.a;
poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, blendScreen(poiFragData.baseColor.rgb, matcapColor.rgb), screen * matcapMask * matcapColor.a);
poiLight.finalLightAdd += matcapColor.rgb * lightAdd * matcapMask * matcapColor.a;
poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, poiFragData.baseColor.rgb + poiFragData.baseColor.rgb * matcapColor.rgb, mixed * matcapMask * matcapColor.a);
poiFragData.emission += matcapColor.rgb * emissionStrength * matcapMask * matcapColor.a;
}
void getMatcapUV(inout float2 matcapUV, in float2 matcapPan, in float matcapUVMode, in float matcapUVToBlend, in float2 matCapBlendUV, in float matcapRotation, in float matcapBorder, in float3 normal, in PoiCam poiCam, in PoiLight poiLight, in PoiMesh poiMesh, in float matcapNormalStrength, in MatcapAudioLinkData matcapALD)
{
switch(matcapUVMode)
{
case 0:
{
float3 viewNormal = (mul(UNITY_MATRIX_V, float4(normal, 0))).rgb;
float3 NormalBlend_MatCapUV_Detail = viewNormal.rgb * float3(-1, -1, 1);
float3 NormalBlend_MatCapUV_Base = (mul(UNITY_MATRIX_V, float4(poiCam.viewDir, 0)).rgb * float3(-1, -1, 1)) + float3(0, 0, 1);
float3 noSknewViewNormal = NormalBlend_MatCapUV_Base * dot(NormalBlend_MatCapUV_Base, NormalBlend_MatCapUV_Detail) / NormalBlend_MatCapUV_Base.b - NormalBlend_MatCapUV_Detail;
matcapUV = noSknewViewNormal.rg * matcapBorder + 0.5;
break;
}
case 1:
{
float3 worldViewUp = normalize(float3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, float3(0, 1, 0)));
float3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
matcapUV = float2(dot(worldViewRight, normal), dot(worldViewUp, normal)) * matcapBorder + 0.5;
break;
}
case 2:
{
float3 reflection = reflect(-poiCam.viewDir, normal);
float2 uv = float2(dot(reflection, float3(1, 0, 0)), dot(reflection, float3(0, 1, 0)));
matcapUV = uv * matcapBorder + 0.5;
break;
}
case 3:
{
matcapUV = 1 - abs(dot(normal, poiCam.viewDir));
#ifdef POI_AUDIOLINK
if (matcapALD.matcapALEnabled)
{
matcapUV += AudioLinkGetChronoTime(matcapALD.matcapALChronoPanType, matcapALD.matcapALChronoPanBand) * matcapALD.matcapALChronoPanSpeed;
}
#endif
break;
}
case 4:
{
float3 worldUp = float3(0, 1, 0);
float3 tangent = normalize(cross(normal, worldUp));
float3 bitangent = normalize(cross(normal, tangent));
float2 projection;
projection.x = dot(poiLight.halfDir, tangent);
projection.y = dot(poiLight.halfDir, bitangent);
matcapUV = projection * matcapBorder + 0.5;
break;
}
}
matcapUV = lerp(matcapUV, poiMesh.uv[matcapUVToBlend], matCapBlendUV);
matcapUV += matcapPan * _Time.x;
matcapUV = RotateUV(matcapUV, matcapRotation * PI, float2(.5, .5), 1.0f);
if (IsInMirror() && matcapUVMode != 3)
{
matcapUV.x = 1 - matcapUV.x;
}
}
#if defined(POI_MATCAP0) || defined(COLOR_GRADING_HDR_3D) || defined(POI_MATCAP2) || defined(POI_MATCAP3)
void applyMatcap(inout PoiFragData poiFragData, in PoiCam poiCam, in PoiMesh poiMesh, inout PoiLight poiLight, in PoiMods poiMods)
{
float4 matcap = 0;
float matcapMask = 0;
float4 matcap2 = 0;
float matcap2Mask = 0;
float4 matcap3 = 0;
float matcap3Mask = 0;
float4 matcap4 = 0;
float matcap4Mask = 0;
float2 matcapUV = 0;
float matcapIntensity;
struct MatcapAudioLinkData matcapALD;
matcapALD.matcapALEnabled = 0.0;
matcapALD.matcapALAlphaAddBand = 0.0;
matcapALD.matcapALAlphaAdd = float4(0,0,0,0);
matcapALD.matcapALEmissionAddBand = 0.0;
matcapALD.matcapALEmissionAdd = float4(0,0,0,0);
matcapALD.matcapALIntensityAddBand = 0.0;
matcapALD.matcapALIntensityAdd = float4(0,0,0,0);
matcapALD.matcapALChronoPanType = 0.0;
matcapALD.matcapALChronoPanBand = 0.0;
matcapALD.matcapALChronoPanSpeed = 0.0;
float3 normal0 = lerp(poiMesh.normals[0], poiMesh.normals[1], 1.0);
getMatcapUV(matcapUV, float4(0,0,0,0).xy, 1.0, 1.0, float4(0,0,0,0).xy, 0.0, 0.5, normal0, poiCam, poiLight, poiMesh, 1.0, matcapALD);
matcapUV = TRANSFORM_TEX(matcapUV, _Matcap);
float mipCount0 = floor(log2(max(float4(0.00390625,0.00390625,256,256).z, float4(0.00390625,0.00390625,256,256).w)));
float matcapSmoothness = 1.0;
if (0.0)
{
// Skipped 1 lines | #if defined(PROP_MATCAPMASK) || !defined(OPTIMIZER_ENABLED)
}
matcapSmoothness = (1 - matcapSmoothness) * mipCount0;
matcap = UNITY_SAMPLE_TEX2D_SAMPLER_LOD(_Matcap, _trilinear_repeat, matcapUV, matcapSmoothness) * float4(poiThemeColor(poiMods, float4(1,1,1,1).rgb, 0.0), float4(1,1,1,1).a);
// Skipped 1 lines
matcap.rgb *= lerp(1, poiLight.directColor, 0.0);
matcapIntensity = 1.0;
#ifdef POI_AUDIOLINK
if (matcapALD.matcapALEnabled > 0)
{
matcapIntensity += lerp(matcapALD.matcapALIntensityAdd.x, matcapALD.matcapALIntensityAdd.y, poiMods.audioLink[matcapALD.matcapALIntensityAddBand]);
matcapIntensity = max(0, matcapIntensity);
}
#endif
matcap.rgb *= matcapIntensity;
#ifndef POI_GRABPASS
matcap.rgb = lerp(matcap.rgb, matcap.rgb * poiFragData.baseColor.rgb, 0.0);
#endif
if (0.0)
{
matcap.rgb = hueShift(matcap.rgb, 0.0 + _Time.x * 0.0, 0.0, 1.0);
}
// Skipped 1 lines | #if defined(PROP_MATCAPMASK) || !defined(OPTIMIZER_ENABLED)
matcapMask = 1;
if (0.0)
{
matcapMask = 1 - matcapMask;
}
#ifdef TPS_Penetrator
if (0.0)
{
matcapMask = lerp(0, matcapMask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), 1.0);
}
#endif
if(0.0)
{
matcapMask *= 1-poiEdgeNonLinear(distance(float2(0.5,0.5), matcapUV), 0.45, 0.1);
}
poiFragData.alpha *= lerp(1, matcap.a, matcapMask * 0.0);
if (0)
{
float matcapAlphaApplyValue = dot(matcap.rgb, float3(0.299, 0.587, 0.114));
if (0 == 1)
{
matcapAlphaApplyValue = poiMax(matcap.rgb);
}
if (0 == 0)
{
poiFragData.alpha += lerp(0, matcapAlphaApplyValue, 1.0);
poiFragData.alpha = saturate(poiFragData.alpha);
}
if (0 == 1)
{
poiFragData.alpha *= lerp(1, matcapAlphaApplyValue, 1.0);
}
}
blendMatcap(poiLight, poiFragData, poiMods, 0.0, 0.0, 0.406, 0.0, 0.0, 0.0, matcap, matcapMask, 0.0, 0.0, 0.0, 2.0, matcapALD);
}
#endif
float3 RotateAroundYInDegrees(float3 dir, float degrees)
{
float alpha = degrees * UNITY_PI / 180.0;
float sina;
float cosa;
sincos(alpha, sina, cosa);
float2x2 m = float2x2(cosa, -sina, sina, cosa);
return float3(mul(m, dir.xz), dir.y).xzy;
}
void applyCubemap(inout PoiFragData poiFragData, in PoiCam poiCam, in PoiMesh poiMesh, in PoiLight poiLight, in PoiMods poiMods)
{
float3 CubeMapUV = 0;
switch(1.0)
{
case 0: CubeMapUV = -poiCam.viewDir;
break;
case 1: CubeMapUV = poiCam.reflectionDir;
break;
case 2: CubeMapUV = lerp(poiMesh.normals[0], poiMesh.normals[1], 1.0);
break;
case 3: CubeMapUV = poiMesh.objNormal;
break;
}
if (any(float4(0,0,0,0).xyz) || any(float4(0,0,0,0).xyz))
{
CubeMapUV = RotateAroundYInDegrees(CubeMapUV.yxz, float4(0,0,0,0).x + (float4(0,0,0,0).x * _Time.y)).yxz;
CubeMapUV = RotateAroundYInDegrees(CubeMapUV.xyz, float4(0,0,0,0).y + (float4(0,0,0,0).y * _Time.y)).xyz;
CubeMapUV = RotateAroundYInDegrees(CubeMapUV.xzy, float4(0,0,0,0).z + (float4(0,0,0,0).z * _Time.y)).xzy;
}
float mipLevel = (1 - 1.0) * (1 - 1.0) * 8;
float4 cubeMap = _CubeMap.SampleLevel(sampler_linear_clamp, CubeMapUV, mipLevel);
cubeMap.rgb *= poiThemeColor(poiMods, _CubeMapColor, 0.0);
// Skipped 1 lines
cubeMap.rgb *= 1.0;
float CubeMapMask = POI2D_SAMPLER_PAN(_CubeMapMask, _MainTex, poiUV(poiMesh.uv[0.0], float4(1,1,0,0)), float4(0,0,0,0))[0.0];
// Skipped 1 lines
if (0.0 > 0)
{
CubeMapMask = maskBlend(CubeMapMask, poiMods.globalMask[0.0 - 1], 2.0);
}
if (0.0)
{
CubeMapMask = 1 - CubeMapMask;
}
if (1.0)
{
cubeMap.rgb = hueShift(cubeMap.rgb, _CubeMapHueShift + _Time.x * 0.0, 0.0, 1.0);
cubeMap = PoiColorBCS(cubeMap, 0.0, 1.0, _CubeMapSaturation);
}
CubeMapMask = min(CubeMapMask, lerp(1, poiLight.rampedLightMap, 0.0));
float cubeMapAlpha = CubeMapMask * cubeMap.a * 1.0;
poiFragData.baseColor.rgb = lerp(poiFragData.baseColor.rgb, cubeMap.rgb, cubeMapAlpha * (0.0 == 0));
poiFragData.baseColor.rgb *= lerp(1, cubeMap.rgb, cubeMapAlpha * (0.0 == 1));
poiFragData.baseColor.rgb += cubeMap.rgb * cubeMapAlpha * (0.0 == 2);
poiFragData.emission += cubeMap.rgb * 0.0 * CubeMapMask * cubeMap.a;
}
void ApplyPoiyomiRimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, inout PoiMods poiMods, float Is_NormalMapToRimLight, float RimInvert, float RimPower, float RimStrength, float RimShadowWidth, float RimShadowToggle, float RimWidth, float RimBlendStrength, float RimMask, float RimGlobalMask, float RimGlobalMaskBlendType, float4 RimTex, float4 RimLightColor, float RimLightColorThemeIndex, float RimHueShiftEnabled, float RimHueShift, float RimHueShiftColorSpace, float RimHueSelectOrShift, float RimHueShiftSpeed, float RimSharpness, float RimShadowMaskRampType, float RimShadowMaskInvert, float RimShadowMaskStrength, float2 RimShadowAlpha, float RimApplyGlobalMaskIndex, float RimApplyGlobalMaskBlendType, float RimBaseColorMix, float RimBrightness, float RimBlendMode, half AudioLinkRimWidthBand, float2 AudioLinkRimWidthAdd, half AudioLinkRimEmissionBand, float2 AudioLinkRimEmissionAdd, half AudioLinkRimBrightnessBand, float2 AudioLinkRimBrightnessAdd, float rimBias, float rimBiasIntensity, int RimApplyAlpha, float RimApplyAlphaBlend)
{
float viewDotNormal = abs(dot(poiCam.viewDir, lerp(poiMesh.normals[0], poiMesh.normals[1], Is_NormalMapToRimLight)));
if (RimInvert)
{
viewDotNormal = 1 - viewDotNormal;
}
viewDotNormal = pow(viewDotNormal, RimPower);
if (RimShadowWidth && RimShadowToggle)
{
viewDotNormal += lerp(0, (1 - poiLight.nDotLNormalized) * 3, RimShadowWidth);
}
viewDotNormal *= lerp(1, rimBias, rimBiasIntensity);
float rimStrength = RimStrength;
float rimWidth = lerp( - .05, 1, RimWidth);
float blendStrength = RimBlendStrength;
#ifdef POI_AUDIOLINK
if (poiMods.audioLinkAvailable)
{
rimWidth = clamp(rimWidth + lerp(AudioLinkRimWidthAdd.x, AudioLinkRimWidthAdd.y, poiMods.audioLink[AudioLinkRimWidthBand]), - .05, 1);
rimStrength += lerp(AudioLinkRimEmissionAdd.x, AudioLinkRimEmissionAdd.y, poiMods.audioLink[AudioLinkRimEmissionBand]);
RimBrightness += lerp(AudioLinkRimBrightnessAdd.x, AudioLinkRimBrightnessAdd.y, poiMods.audioLink[AudioLinkRimBrightnessBand]);
}
#endif
float rimMask = RimMask;
if (RimGlobalMask > 0)
{
rimMask = maskBlend(rimMask, poiMods.globalMask[RimGlobalMask - 1], RimGlobalMaskBlendType);
}
float4 rimColor = RimTex;
rimColor *= float4(poiThemeColor(poiMods, RimLightColor.rgb, RimLightColorThemeIndex), RimLightColor.a);
if (RimHueShiftEnabled)
{
rimColor.rgb = hueShift(rimColor.rgb, RimHueShift + _Time.x * RimHueShiftSpeed, RimHueShiftColorSpace, RimHueSelectOrShift);
}
float rim = 1 - smoothstep(min(RimSharpness, rimWidth), rimWidth, viewDotNormal);
rim *= RimLightColor.a * rimColor.a * rimMask;
if (RimShadowToggle)
{
switch(RimShadowMaskRampType)
{
case 0: float rampedLightMap = poiLight.rampedLightMap;
if (RimShadowMaskInvert) rampedLightMap = 1 - rampedLightMap;
rim = lerp(rim, rim * rampedLightMap, RimShadowMaskStrength);
break;
case 1: float nDotLNormalized = poiLight.nDotLNormalized;
if (RimShadowMaskInvert) nDotLNormalized = 1 - nDotLNormalized;
rim = lerp(rim, rim * smoothstep(RimShadowAlpha.x, RimShadowAlpha.y, nDotLNormalized), RimShadowMaskStrength);
break;
}
}
if (RimApplyGlobalMaskIndex > 0)
{
applyToGlobalMask(poiMods, RimApplyGlobalMaskIndex - 1, RimApplyGlobalMaskBlendType, rim * blendStrength);
}
if (RimApplyAlpha == 1)
{
poiFragData.alpha += lerp(0, saturate(rim), RimApplyAlphaBlend);
poiFragData.alpha = saturate(poiFragData.alpha);
}
if (RimApplyAlpha == 2)
{
poiFragData.alpha *= lerp(1, saturate(rim), RimApplyAlphaBlend);
}
#ifdef POI_GRABPASS
float3 finalRimColor = rimColor.rgb;
#else
float3 finalRimColor = rimColor.rgb * lerp(1, poiFragData.baseColor, RimBaseColorMix);
#endif
finalRimColor *= RimBrightness;
switch(RimBlendMode)
{
case 0: poiFragData.baseColor += finalRimColor * rim * blendStrength;
break;
case 1: poiFragData.baseColor = lerp(poiFragData.baseColor, finalRimColor, rim * blendStrength);
break;
case 2: poiFragData.baseColor = lerp(poiFragData.baseColor, poiFragData.baseColor * finalRimColor, rim * blendStrength);
break;
case 3: poiFragData.baseColor = lerp(poiFragData.baseColor.rgb, poiFragData.baseColor.rgb + poiFragData.baseColor.rgb * finalRimColor, rim * blendStrength);
break;
case 4: poiFragData.baseColor = lerp(poiFragData.baseColor, 1 - (1 - poiFragData.baseColor) * (1 - finalRimColor), rim * blendStrength);
break;
}
poiFragData.emission += finalRimColor * rim * rimStrength;
}
#if defined(_RIMSTYLE_UTS2) || defined(_RIM2STYLE_UTS2)
void ApplyUTS2RimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, in PoiMods poiMods, float Set_RimLightMask_var, float RimGlobalMask, float RimGlobalMaskBlendType, float4 RimLightColor, float RimLightColorThemeIndex, float Is_LightColor_RimLight, float Is_NormalMapToRimLight, float RimLight_Power, float RimLight_InsideMask, float RimLight_FeatherOff, float LightDirection_MaskOn, float Tweak_LightDirection_MaskLevel, float Add_Antipodean_RimLight, float4 Ap_RimLightColor, float RimApColorThemeIndex, float Is_LightColor_Ap_RimLight, float Ap_RimLight_Power, float Ap_RimLight_FeatherOff, float Tweak_RimLightMaskLevel, float RimHueShiftEnabled, float RimHueShift, float RimHueShiftColorSpace, float RimHueSelectOrShift, float RimHueShiftSpeed)
{
if (RimGlobalMask > 0)
{
Set_RimLightMask_var = maskBlend(Set_RimLightMask_var, poiMods.globalMask[RimGlobalMask - 1], RimGlobalMaskBlendType);
}
float3 rimColor = float3(poiThemeColor(poiMods, RimLightColor.rgb, RimLightColorThemeIndex));
float3 _Is_LightColor_RimLight_var = lerp(rimColor, (rimColor * poiLight.directColor), Is_LightColor_RimLight);
float _RimArea_var = (1.0 - dot(lerp(poiMesh.normals[0], poiMesh.normals[1], Is_NormalMapToRimLight), poiCam.viewDir));
float _RimLightPower_var = pow(_RimArea_var, exp2(lerp(3, 0, RimLight_Power)));
float _Rimlight_InsideMask_var = saturate(lerp((0.0 + ((_RimLightPower_var - RimLight_InsideMask) * (1.0 - 0.0)) / (1.0 - RimLight_InsideMask)), step(RimLight_InsideMask, _RimLightPower_var), RimLight_FeatherOff));
float _VertHalfLambert_var = 0.5 * dot(poiMesh.normals[0], poiLight.direction) + 0.5;
float3 _LightDirection_MaskOn_var = lerp((_Is_LightColor_RimLight_var * _Rimlight_InsideMask_var), (_Is_LightColor_RimLight_var * saturate((_Rimlight_InsideMask_var - ((1.0 - _VertHalfLambert_var) + Tweak_LightDirection_MaskLevel)))), LightDirection_MaskOn);
float _ApRimLightPower_var = pow(_RimArea_var, exp2(lerp(3, 0, Ap_RimLight_Power)));
float3 ApRimColor = float3(poiThemeColor(poiMods, Ap_RimLightColor.rgb, RimApColorThemeIndex));
float3 _RimLight_var = (saturate((Set_RimLightMask_var + Tweak_RimLightMaskLevel)) * lerp(_LightDirection_MaskOn_var, (_LightDirection_MaskOn_var + (lerp(ApRimColor, (ApRimColor * poiLight.directColor), Is_LightColor_Ap_RimLight) * saturate((lerp((0.0 + ((_ApRimLightPower_var - RimLight_InsideMask) * (1.0 - 0.0)) / (1.0 - RimLight_InsideMask)), step(RimLight_InsideMask, _ApRimLightPower_var), Ap_RimLight_FeatherOff) - (saturate(_VertHalfLambert_var) + Tweak_LightDirection_MaskLevel))))), Add_Antipodean_RimLight));
if (RimHueShiftEnabled)
{
_RimLight_var = hueShift(_RimLight_var, RimHueShift + _Time.x * RimHueShiftSpeed, RimHueShiftColorSpace, RimHueSelectOrShift);
}
poiFragData.baseColor += _RimLight_var;
}
#endif
#if defined(_RIMSTYLE_LILTOON) || defined(_RIM2STYLE_LILTOON)
void ApplyLiltoonRimLighting(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiCam poiCam, in PoiLight poiLight, in PoiMods poiMods, float4 RimColor, float4 RimIndirColor, float4 RimColorTex, float RimMainStrength, float RimNormalStrength, float RimDirRange, float RimIndirRange, float RimFresnelPower, float RimBackfaceMask, float RimDirStrength, float RimBorder, float RimBlur, float RimIndirBorder, float RimIndirBlur, float RimShadowMask, float RimEnableLighting, float RimVRParallaxStrength, float RimGlobalMask, float RimGlobalMaskBlendType, float RimHueShiftEnabled, float RimHueShift, float RimHueShiftColorSpace, float RimHueSelectOrShift, float RimHueShiftSpeed, int RimBlendMode, float RimTexMaskOnly, float RimLightColorThemeIndex)
{
RimColor.rgb = float3(poiThemeColor(poiMods, RimColor.rgb, RimLightColorThemeIndex));
if (RimGlobalMask > 0)
{
RimColorTex.a = maskBlend(RimColorTex.a, poiMods.globalMask[RimGlobalMask - 1], RimGlobalMaskBlendType);
}
float4 rimColor = RimColor;
float4 rimIndirColor = RimIndirColor;
if(RimTexMaskOnly > 0)
{
rimColor.a *= RimColorTex.r;
rimIndirColor.a *= RimColorTex.r;
}
else
{
rimColor *= RimColorTex;
rimIndirColor *= RimColorTex;
}
if (RimHueShiftEnabled)
{
rimColor.rgb = hueShift(rimColor.rgb, RimHueShift + _Time.x * RimHueShiftSpeed, RimHueShiftColorSpace, RimHueSelectOrShift);
rimIndirColor.rgb = hueShift(rimIndirColor.rgb, RimHueShift + _Time.x * RimHueShiftSpeed, RimHueShiftColorSpace, RimHueSelectOrShift);
}
rimColor.rgb = lerp(rimColor.rgb, rimColor.rgb * poiFragData.baseColor, RimMainStrength);
float3 centerViewDir = !IsOrthographicCamera() ? normalize(getCameraPosition() - poiMesh.worldPos.xyz) : normalize(UNITY_MATRIX_I_V._m02_m12_m22);
float3 viewDir = lerp(centerViewDir, poiCam.viewDir, RimVRParallaxStrength);
float3 normal = lerp(poiMesh.normals[0], poiMesh.normals[1], RimNormalStrength);
float nvabs = abs(dot(normal, viewDir));
float lnRaw = dot(poiLight.direction, normal) * 0.5 + 0.5;
float lnDir = saturate((lnRaw + RimDirRange) / (1.0 + RimDirRange));
float lnIndir = saturate((1.0 - lnRaw + RimIndirRange) / (1.0 + RimIndirRange));
float rim = pow(saturate(1.0 - nvabs), RimFresnelPower);
rim = !poiMesh.isFrontFace && RimBackfaceMask ? 0.0 : rim;
float rimDir = lerp(rim, rim * lnDir, RimDirStrength);
float rimIndir = rim * lnIndir * RimDirStrength;
rimDir = poiEdgeLinear(rimDir, RimBorder, RimBlur);
rimIndir = poiEdgeLinear(rimIndir, RimIndirBorder, RimIndirBlur);
rimDir = lerp(rimDir, rimDir * poiLight.rampedLightMap, RimShadowMask);
rimIndir = lerp(rimIndir, rimIndir * poiLight.rampedLightMap, RimShadowMask);
float3 lightCol = poiLight.finalLighting;
#if !defined(POI_PASS_ADD)
float3 rimLightMul = 1 - RimEnableLighting + lightCol * RimEnableLighting;
#else
float3 rimLightMul = RimBlendMode < 3 ? lightCol * RimEnableLighting : 1;
#endif
poiFragData.finalColor = lilBlendColor(poiFragData.finalColor, rimColor.rgb * rimLightMul, rimDir * rimColor.a, RimBlendMode);
poiFragData.finalColor = lilBlendColor(poiFragData.finalColor, rimIndirColor.rgb * rimLightMul, rimIndir * rimIndirColor.a, RimBlendMode);
}
#endif
float GSAA_Filament(float3 worldNormal, float perceptualRoughness, float gsaaVariance, float gsaaThreshold)
{
float3 du = ddx(worldNormal);
float3 dv = ddy(worldNormal);
float variance = gsaaVariance * (dot(du, du) + dot(dv, dv));
float roughness = perceptualRoughness * perceptualRoughness;
float kernelRoughness = min(2.0 * variance, gsaaThreshold);
float squareRoughness = saturate(roughness * roughness + kernelRoughness);
return sqrt(sqrt(squareRoughness));
}
float3 GetWorldReflections(float3 reflDir, float3 worldPos, float roughness)
{
float3 baseReflDir = reflDir;
reflDir = BoxProjection(reflDir, worldPos, unity_SpecCube0_ProbePosition, unity_SpecCube0_BoxMin, unity_SpecCube0_BoxMax);
float4 envSample0 = UNITY_SAMPLE_TEXCUBE_LOD(unity_SpecCube0, reflDir, roughness * UNITY_SPECCUBE_LOD_STEPS);
float3 p0 = DecodeHDR(envSample0, unity_SpecCube0_HDR);
float interpolator = unity_SpecCube0_BoxMin.w;
if (interpolator < 0.99999)
{
float3 refDirBlend = BoxProjection(baseReflDir, worldPos, unity_SpecCube1_ProbePosition, unity_SpecCube1_BoxMin, unity_SpecCube1_BoxMax);
float4 envSample1 = UNITY_SAMPLE_TEXCUBE_SAMPLER_LOD(unity_SpecCube1, unity_SpecCube0, refDirBlend, roughness * UNITY_SPECCUBE_LOD_STEPS);
float3 p1 = DecodeHDR(envSample1, unity_SpecCube1_HDR);
p0 = lerp(p1, p0, interpolator);
}
return p0;
}
float3 GetReflections(in PoiCam poiCam, in PoiLight pl, in PoiMesh poiMesh, float roughness, float ForceFallback, float LightFallback, TextureCube reflectionCube, float4 hdrData, float3 reflectionDir)
{
float3 reflections = 0;
float3 lighting = pl.finalLighting;
if (ForceFallback == 0)
{
if (SceneHasReflections())
{
reflections = GetWorldReflections(reflectionDir, poiMesh.worldPos.xyz, roughness);
}
else
{
float mipLevel = roughness * UNITY_SPECCUBE_LOD_STEPS;
reflections = reflectionCube.SampleLevel(sampler_linear_clamp, reflectionDir, mipLevel);
reflections = DecodeHDR(float4(reflections, 1), hdrData) * lerp(1, pl.finalLighting, LightFallback);
#ifdef POI_PASS_ADD
if (LightFallback)
{
float mipLevel = roughness * UNITY_SPECCUBE_LOD_STEPS;
reflections = reflectionCube.SampleLevel(sampler_linear_clamp, reflectionDir, mipLevel);
reflections = DecodeHDR(float4(reflections, 1), hdrData) * pl.finalLighting;
}
#endif
}
}
else
{
float mipLevel = roughness * UNITY_SPECCUBE_LOD_STEPS;
reflections = reflectionCube.SampleLevel(sampler_linear_clamp, reflectionDir, mipLevel);
reflections = DecodeHDR(float4(reflections, 1), hdrData) * lerp(1, pl.finalLighting, LightFallback);
#ifdef POI_PASS_ADD
if (LightFallback)
{
float mipLevel = roughness * UNITY_SPECCUBE_LOD_STEPS;
reflections = reflectionCube.SampleLevel(sampler_linear_clamp, reflectionDir, mipLevel);
reflections = DecodeHDR(float4(reflections, 1), hdrData) * pl.finalLighting;
}
#endif
}
reflections *= pl.occlusion;
return reflections;
}
float GetGGXTerm(float nDotL, float nDotV, float nDotH, float roughness)
{
float visibilityTerm = 0;
if (nDotL > 0)
{
float lambdaV = nDotL * (nDotV * (1 - roughness) + roughness);
float lambdaL = nDotV * (nDotL * (1 - roughness) + roughness);
visibilityTerm = 0.5f / (lambdaV + lambdaL + 1e-5f);
float a = nDotH * roughness;
float k = roughness / (1.0 - nDotH * nDotH + a * a+ 1e-5f);
float dotTerm = k * k * UNITY_INV_PI;
visibilityTerm *= dotTerm;
}
return visibilityTerm;
}
void GetSpecFresTerm(float nDotL, float nDotV, float nDotH, float lDotH, inout float3 specularTerm, inout float3 fresnelTerm, float3 specCol, float roughness)
{
specularTerm = GetGGXTerm(nDotL, nDotV, nDotH, roughness);
fresnelTerm = FresnelTerm(specCol, lDotH);
specularTerm = max(0, specularTerm * max(0.00001, nDotL));
}
float GetRoughness(float smoothness)
{
float rough = 1 - smoothness;
rough *= 1.7 - 0.7 * rough;
return rough;
}
float SFVisibility(float brdfRoughness, float3 directColor, float NDotV, float ExposureOcclusion)
{
float Visibility = saturate(length(directColor + EPSILON) * (1.0/(ExposureOcclusion)));
return saturate(pow(NDotV + Visibility, exp2(-16.0 * brdfRoughness - 1.0)) - 1.0 + Visibility);
}
void MetallicAndSpecularFragDataInit(inout PoiFragData poiFragData, in PoiMesh poiMesh, in PoiMods poiMods)
{
float smoothness = 0.5;
float smoothness2 = 1.0;
float metallic = 0.0;
float specularMask = 1;
float reflectionMask = 1;
smoothness *= poiFragData.smoothness;
smoothness2 *= poiFragData.smoothness2;
metallic *= poiFragData.metallic;
specularMask *= poiFragData.specularMask;
reflectionMask *= poiFragData.reflectionMask;
// Skipped 24 lines | #if defined(PROP_MOCHIEMETALLICMAPS) || !defined(OPTIMIZER_ENABLED)
reflectionMask *= 0.0;
specularMask *= 1.0;
if (0.0)
{
metallic = 1 - metallic;
}
if (0.0)
{
smoothness = 1 - smoothness;
smoothness2 = 1 - smoothness2;
}
if (0.0)
{
reflectionMask = 1 - reflectionMask;
}
if (0.0)
{
specularMask = 1 - specularMask;
}
poiFragData.smoothness *= smoothness;
poiFragData.smoothness2 *= smoothness2;
poiFragData.metallic *= metallic;
poiFragData.specularMask *= specularMask;
poiFragData.reflectionMask *= reflectionMask;
}
void MochieBRDF(inout PoiFragData poiFragData, in PoiCam poiCam, inout PoiLight poiLight, in PoiMesh poiMesh, inout PoiMods poiMods)
{
float smoothness = poiFragData.smoothness;
float smoothness2 = poiFragData.smoothness2;
float metallic = poiFragData.metallic;
float specularMask = poiFragData.specularMask;
float reflectionMask = poiFragData.reflectionMask;
if (0.0 > 0)
{
metallic = customBlend(metallic, poiMods.globalMask[0.0 - 1], 2.0);
}
if (0.0 > 0)
{
smoothness = customBlend(smoothness, poiMods.globalMask[0.0 - 1], 2.0);
smoothness2 = customBlend(smoothness2, poiMods.globalMask[0.0 - 1], 2.0);
}
if (0.0 > 0)
{
reflectionMask = customBlend(reflectionMask, poiMods.globalMask[0.0 - 1], 2.0);
}
if (0.0 > 0)
{
specularMask = customBlend(specularMask, poiMods.globalMask[0.0 - 1], 2.0);
}
#ifdef TPS_Penetrator
if (0.0)
{
reflectionMask = lerp(0, reflectionMask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), 1.0);
specularMask = lerp(0, specularMask * TPSBufferedDepth(poiMesh.localPos, poiMesh.vertexColor), 1.0);
}
#endif
float roughness = GetRoughness(smoothness);
float roughness2 = GetRoughness(smoothness2);
float3 specCol = lerp(unity_ColorSpaceDielectricSpec.rgb, poiFragData.baseColor, metallic);
float omr = unity_ColorSpaceDielectricSpec.a - metallic * unity_ColorSpaceDielectricSpec.a;
float percepRough = 1 - smoothness;
float percepRough2 = 1 - smoothness2;
if (1.0)
{
float3 normals = lerp(poiMesh.normals[0], poiMesh.normals[1], 1.0);
percepRough = GSAA_Filament(normals, percepRough, 0.15, 0.1);
if (0.0 == 1 && 1.0 > 0)
{
percepRough2 = GSAA_Filament(normals, percepRough2, 0.15, 0.1);
}
}
float brdfRoughness = percepRough * percepRough;
brdfRoughness = max(brdfRoughness, 0.002);
float brdfRoughness2 = percepRough2 * percepRough2;
brdfRoughness2 = max(brdfRoughness2, 0.002);
float3 diffuse = poiFragData.baseColor;
float3 specular = 0;
float3 specular2 = 0;
float3 vSpecular = 0;
float3 vSpecular2 = 0;
float3 reflections = 0;
float3 environment = 0;
#if defined(POINT) || defined(SPOT)
float attenuation = lerp(poiLight.additiveShadow, 1, 0.0);
#else
float attenuation = min(poiLight.nDotLSaturated, lerp(poiLight.attenuation, 1, 0.0));
#endif
float3 fresnelTerm = 1;
float3 specularTerm = 1;
float pbrNDotL = lerp(poiLight.vertexNDotL, poiLight.nDotL, 1.0);
float pbrNDotV = lerp(poiLight.vertexNDotV, poiLight.nDotV, 1.0);
float pbrNDotH = lerp(poiLight.vertexNDotH, poiLight.nDotH, 1.0);
float3 pbrReflectionDir = lerp(poiCam.vertexReflectionDir, poiCam.reflectionDir, 1.0);
GetSpecFresTerm(pbrNDotL, pbrNDotV, pbrNDotH, poiLight.lDotH, specularTerm, fresnelTerm, specCol, brdfRoughness);
specular = poiLight.directColor * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, float4(1,1,1,1), 0.0) * poiLight.occlusion * attenuation;
if (poiFragData.toggleVertexLights)
{
#if defined(VERTEXLIGHT_ON)
for (int index = 0;
index < 4;
index++)
{
fresnelTerm = 1;
specularTerm = 1;
float pbrVDotNL = lerp(poiLight.vertexVDotNL[index], poiLight.vDotNL[index], 1.0);
float pbrVDotNH = lerp(poiLight.vertexVDotNH[index], poiLight.vDotNH[index], 1.0);
GetSpecFresTerm(pbrVDotNL, pbrNDotV, pbrVDotNH, poiLight.vDotLH[index], specularTerm, fresnelTerm, specCol, brdfRoughness);
vSpecular += poiLight.vColor[index] * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, float4(1,1,1,1), 0.0) * poiLight.occlusion;
}
#endif
}
if (0.0 == 1)
{
float3 fresnelTerm = 1;
float3 specularTerm = 1;
GetSpecFresTerm(pbrNDotL, pbrNDotV, pbrNDotH, poiLight.lDotH, specularTerm, fresnelTerm, specCol, brdfRoughness2);
specular2 = poiLight.directColor * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, float4(1,1,1,1), 0.0) * poiLight.occlusion * attenuation * 1.0;
if (poiFragData.toggleVertexLights)
{
#if defined(VERTEXLIGHT_ON)
for (int index = 0;
index < 4;
index++)
{
fresnelTerm = 1;
specularTerm = 1;
float pbrVDotNL = lerp(poiLight.vertexVDotNL[index], poiLight.vDotNL[index], 1.0);
float pbrVDotNH = lerp(poiLight.vertexVDotNH[index], poiLight.vDotNH[index], 1.0);
GetSpecFresTerm(pbrVDotNL, pbrNDotV, pbrVDotNH, poiLight.vDotLH[index], specularTerm, fresnelTerm, specCol, brdfRoughness2);
vSpecular2 += poiLight.vColor[index] * specularTerm * fresnelTerm * specularMask * poiThemeColor(poiMods, float4(1,1,1,1), 0.0) * poiLight.occlusion * 1.0;
}
#endif
}
}
float surfaceReduction = (1.0 / (brdfRoughness * brdfRoughness + 1.0));
float grazingTerm = saturate(smoothness + (1 - omr));
float3 reflCol = GetReflections(poiCam, poiLight, poiMesh, roughness, 0.0, 1.0, _MochieReflCube, _MochieReflCube_HDR, pbrReflectionDir);
reflections = surfaceReduction * reflCol * FresnelLerp(specCol, specCol + lerp(specCol, 1, 0.5) * 0.5, pbrNDotV) * SFVisibility(brdfRoughness, poiLight.directColor, pbrNDotV, 0.0);
reflections *= poiThemeColor(poiMods, float4(1,1,1,1), 0.0);
reflections *= reflectionMask;
diffuse = lerp(diffuse, diffuse * omr, reflectionMask);
environment = max(specular + vSpecular, specular2 + vSpecular2);
environment += reflections;
diffuse *= poiLight.finalLighting;
poiFragData.finalColor = diffuse;
poiLight.finalLightAdd += environment;
}
float SSAOInterleavedGradientNoise(float2 pixelCoord)
{
return glsl_mod(52.9829189f * glsl_mod(0.06711056f * float(pixelCoord.x) + 0.00583715f * float(pixelCoord.y), 1.0f), 1.0f);
}
float CalculateAmbientOcclusion(float2 uv, float depth, float3 normal, float radius, float4 worldDirection, PoiMesh poiMesh, PoiCam poiCam)
{
float ao = 0.0f;
int totalSamples = int((2.4 * 5) * smoothstep(8.0, 6.0, poiCam.clipPos.w));
float centerImportance = 1.0;
float radiusFactor = radius * (1.0 / poiCam.clipPos.w);
float3 up = abs(normal.y) > 0.999 ? float3(1, 0, 0) : float3(0, 1, 0);
float3 tangent = normalize(cross(up, normal));
float3 bitangent = cross(normal, tangent);
float invRadius = 1.0 / radius;
float randomValue = 0.0 * (SSAOInterleavedGradientNoise(uv * _ScreenParams.xy) * 2.0 - 1.0);
[loop]
for (int sampleIndex = 0;
sampleIndex < totalSamples;
sampleIndex++)
{
float distance = sampleIndex * (1.0 / totalSamples) + randomValue;
float sampleAngle = (TWO_PI * 1.618033988 * sampleIndex) + randomValue;
float s;
float c;
sincos(sampleAngle, s, c);
float3 sampleDir = tangent * c + bitangent * s;
sampleDir = normalize(lerp(sampleDir, normal, 0.0));
float offsetFactor = distance * lerp(1.0, distance, centerImportance);
float2 screenOffset = (sampleDir.xy) * radiusFactor * offsetFactor;
float zOffset = sampleDir.z * radius * offsetFactor;
float2 samplePos = uv + screenOffset;
float sampleDepthValue = SampleScreenDepth(samplePos);
float sampleDepth = CorrectedLinearEyeDepth(sampleDepthValue, worldDirection.w);
sampleDepth += zOffset;
float aoValue = 1.0;
float depthDifference = depth - sampleDepth - 0.003;
aoValue = saturate(depthDifference * invRadius);
aoValue *= smoothstep(max(radius + float4(0.01,0.1,1,1).x + EPSILON, radius + float4(0.01,0.1,1,1).y + EPSILON), radius + float4(0.01,0.1,1,1).x, depthDifference);
ao += aoValue;
}
return (1.0 - saturate((ao / totalSamples)) * smoothstep(8.0, 6.0, poiCam.clipPos.w));
}
float calculateSSAO(PoiMesh poiMesh, PoiCam poiCam, inout PoiLight poiLight, inout PoiMods poiMods)
{
if (!DepthTextureExists() || _SSAOAnimationToggle == 0)
{
return 1;
}
float perspectiveDivide = 1.0 / poiCam.clipPos.w;
float4 direction = poiCam.worldDirection * perspectiveDivide;
float2 screenPos = poiCam.posScreenSpace * perspectiveDivide;
float depth = CorrectedLinearEyeDepth(poiCam.clipPos.z, direction.w);
float3 transformedNormal = mul((float3x3)UNITY_MATRIX_V, lerp(poiMesh.normals[0], poiMesh.normals[1], 0.0));
float mask = 1;
if (0.0 > 0)
{
mask = maskBlend(mask, poiMods.globalMask[0.0 - 1], 2.0);
}
float ssao = CalculateAmbientOcclusion(screenPos, depth, transformedNormal, 0.002, direction, poiMesh, poiCam);
ssao = lerp(1, ssao, mask);
if (0.0 > 0)
{
applyToGlobalMask(poiMods, 0.0 - 1, 0.0, ssao);
}
return ssao;
}
void applySSAO(float ssao, in PoiMesh poiMesh, inout PoiFragData poiFragData, inout PoiMods poiMods, inout PoiLight poiLight)
{
if (!DepthTextureExists() || _SSAOAnimationToggle == 0)
return;
ssao = lerp(ssao, 1, poiLight.rampedLightMap * 0.0);
float3 ssaoColor = poiThemeColor(poiMods, float4(0,0,0,1).rgb, 0.0).rgb * lerp(1, poiFragData.baseColor, 0.0);
float alphaFade = lerp(1.0, poiFragData.alpha, 1.0);
float intensity = (1 - ssao) * _SSAOIntensity * alphaFade;
if (any(float4(0,0,0,0)))
{
poiFragData.baseColor = lerp(poiFragData.baseColor, lilToneCorrection(poiFragData.baseColor, float4(0,0,0,0) + 1), intensity);
}
poiFragData.baseColor = lerp(poiFragData.baseColor, customBlend(poiFragData.baseColor, ssaoColor, 2.0), intensity);
}
struct fragmentInputWrapper
{
uint WKVRCOptimizer_MeshMaterialID : WKVRCOptimizer_MeshMaterialID;
VertexOut i;
uint facing : SV_IsFrontFace;
};
float4 frag(
fragmentInputWrapper WKVRCOptimizer_fragmentInput
) : SV_Target
{
VertexOut i = WKVRCOptimizer_fragmentInput.i;
uint facing = WKVRCOptimizer_fragmentInput.facing;
WKVRCOptimizer_MaterialID = WKVRCOptimizer_fragmentInput.WKVRCOptimizer_MeshMaterialID & 0xFFFF;
WKVRCOptimizer_MeshID = WKVRCOptimizer_fragmentInput.WKVRCOptimizer_MeshMaterialID >> 16;
if (WKVRCOptimizer_Zero)
{
float WKVRCOptimizer_val = WKVRCOptimizer_Color_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex37.x * WKVRCOptimizer_Color_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex35.x * WKVRCOptimizer_Color_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex33.x * WKVRCOptimizer_Color_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex31.x * WKVRCOptimizer_Color_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex29.x * WKVRCOptimizer_Color_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex27.x * WKVRCOptimizer_Color_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex25.x * WKVRCOptimizer_Color_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex23.x * WKVRCOptimizer_Color_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex21.x * WKVRCOptimizer_Color_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex19.x * WKVRCOptimizer_Color_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex17.x * WKVRCOptimizer_Color_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex15.x * WKVRCOptimizer_Color_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex13.x * WKVRCOptimizer_Color_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex11.x * WKVRCOptimizer_Color_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex9.x * WKVRCOptimizer_Color_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex7.x * WKVRCOptimizer_Color_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex5.x * WKVRCOptimizer_Color_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex3.x * WKVRCOptimizer_Color_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_Color_ArrayIndex1.x * WKVRCOptimizer_Color_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex38.x * WKVRCOptimizer_Saturation_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex36.x * WKVRCOptimizer_Saturation_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex34.x * WKVRCOptimizer_Saturation_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex32.x * WKVRCOptimizer_Saturation_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex30.x * WKVRCOptimizer_Saturation_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex28.x * WKVRCOptimizer_Saturation_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex26.x * WKVRCOptimizer_Saturation_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex24.x * WKVRCOptimizer_Saturation_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex22.x * WKVRCOptimizer_Saturation_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex20.x * WKVRCOptimizer_Saturation_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex18.x * WKVRCOptimizer_Saturation_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex16.x * WKVRCOptimizer_Saturation_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex14.x * WKVRCOptimizer_Saturation_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex12.x * WKVRCOptimizer_Saturation_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex10.x * WKVRCOptimizer_Saturation_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex8.x * WKVRCOptimizer_Saturation_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex6.x * WKVRCOptimizer_Saturation_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex4.x * WKVRCOptimizer_Saturation_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex2.x * WKVRCOptimizer_Saturation_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_Saturation_ArrayIndex0.x * WKVRCOptimizer_MainHueShift_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex37.x * WKVRCOptimizer_MainHueShift_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex35.x * WKVRCOptimizer_MainHueShift_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex33.x * WKVRCOptimizer_MainHueShift_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex31.x * WKVRCOptimizer_MainHueShift_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex29.x * WKVRCOptimizer_MainHueShift_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex27.x * WKVRCOptimizer_MainHueShift_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex25.x * WKVRCOptimizer_MainHueShift_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex23.x * WKVRCOptimizer_MainHueShift_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex21.x * WKVRCOptimizer_MainHueShift_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex19.x * WKVRCOptimizer_MainHueShift_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex17.x * WKVRCOptimizer_MainHueShift_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex15.x * WKVRCOptimizer_MainHueShift_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex13.x * WKVRCOptimizer_MainHueShift_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex11.x * WKVRCOptimizer_MainHueShift_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex9.x * WKVRCOptimizer_MainHueShift_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex7.x * WKVRCOptimizer_MainHueShift_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex5.x * WKVRCOptimizer_MainHueShift_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex3.x * WKVRCOptimizer_MainHueShift_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_MainHueShift_ArrayIndex1.x * WKVRCOptimizer_MainHueShift_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex38.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex36.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex34.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex32.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex30.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex28.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex26.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex24.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex22.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex20.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex18.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex16.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex14.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex12.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex10.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex8.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex6.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex4.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex2.x * WKVRCOptimizer_DecalBlendAlpha_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_DecalBlendAlpha_ArrayIndex0.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex37.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex35.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex33.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex31.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex29.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex27.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex25.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex23.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex21.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex19.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex17.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex15.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex13.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex11.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex9.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex7.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex5.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex3.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapHueShift_ArrayIndex1.x * WKVRCOptimizer_CubeMapHueShift_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex38.x * WKVRCOptimizer_CubeMapColor_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex36.x * WKVRCOptimizer_CubeMapColor_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex34.x * WKVRCOptimizer_CubeMapColor_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex32.x * WKVRCOptimizer_CubeMapColor_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex30.x * WKVRCOptimizer_CubeMapColor_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex28.x * WKVRCOptimizer_CubeMapColor_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex26.x * WKVRCOptimizer_CubeMapColor_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex24.x * WKVRCOptimizer_CubeMapColor_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex22.x * WKVRCOptimizer_CubeMapColor_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex20.x * WKVRCOptimizer_CubeMapColor_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex18.x * WKVRCOptimizer_CubeMapColor_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex16.x * WKVRCOptimizer_CubeMapColor_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex14.x * WKVRCOptimizer_CubeMapColor_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex12.x * WKVRCOptimizer_CubeMapColor_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex10.x * WKVRCOptimizer_CubeMapColor_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex8.x * WKVRCOptimizer_CubeMapColor_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex6.x * WKVRCOptimizer_CubeMapColor_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex4.x * WKVRCOptimizer_CubeMapColor_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex2.x * WKVRCOptimizer_CubeMapColor_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_CubeMapColor_ArrayIndex0.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex37.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex35.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex33.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex31.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex29.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex27.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex25.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex23.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex21.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex19.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex17.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex15.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex13.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex11.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex9.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex7.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex5.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex3.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex1.x * WKVRCOptimizer_SSAOAnimationToggle_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex38.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex36.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex34.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex32.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex30.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex28.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex26.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex24.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex22.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex20.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex18.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex16.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex14.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex12.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex10.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex8.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex6.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex4.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex2.x * WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingEnableLightVolumes_ArrayIndex0.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex37.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex35.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex33.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex31.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex29.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex27.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex25.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex23.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex21.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex19.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex17.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex15.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex13.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex11.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex9.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex7.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex5.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex3.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_SSAOIntensity_ArrayIndex1.x * WKVRCOptimizer_SSAOIntensity_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex38.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex36.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex34.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex32.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex30.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex28.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex26.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex24.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex22.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex20.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex18.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex16.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex14.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex12.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex10.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex8.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex6.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex4.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex2.x * WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveMonochromatic_ArrayIndex0.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex37.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex35.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex33.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex31.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex29.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex27.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex25.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex23.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex21.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex19.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex17.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex15.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex13.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex11.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex9.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex7.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex5.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex3.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMonochromatic_ArrayIndex1.x * WKVRCOptimizer_LightingMonochromatic_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex38.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex36.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex34.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex32.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex30.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex28.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex26.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex24.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex22.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex20.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex18.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex16.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex14.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex12.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex10.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex8.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex6.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex4.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex2.x * WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingMinLightBrightness_ArrayIndex0.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex38.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex37.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex36.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex35.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex34.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex33.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex32.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex31.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex30.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex29.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex28.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex27.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex26.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex25.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex24.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex23.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex22.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex21.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex20.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex19.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex18.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex17.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex16.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex15.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex14.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex13.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex12.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex11.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex10.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex9.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex8.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex7.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex6.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex5.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex4.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex3.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex2.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex1.x * WKVRCOptimizer_LightingAdditiveLimit_ArrayIndex0.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex38.x * WKVRCOptimizer_LightingCap_ArrayIndex37.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex36.x * WKVRCOptimizer_LightingCap_ArrayIndex35.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex34.x * WKVRCOptimizer_LightingCap_ArrayIndex33.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex32.x * WKVRCOptimizer_LightingCap_ArrayIndex31.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex30.x * WKVRCOptimizer_LightingCap_ArrayIndex29.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex28.x * WKVRCOptimizer_LightingCap_ArrayIndex27.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex26.x * WKVRCOptimizer_LightingCap_ArrayIndex25.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex24.x * WKVRCOptimizer_LightingCap_ArrayIndex23.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex22.x * WKVRCOptimizer_LightingCap_ArrayIndex21.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex20.x * WKVRCOptimizer_LightingCap_ArrayIndex19.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex18.x * WKVRCOptimizer_LightingCap_ArrayIndex17.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex16.x * WKVRCOptimizer_LightingCap_ArrayIndex15.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex14.x * WKVRCOptimizer_LightingCap_ArrayIndex13.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex12.x * WKVRCOptimizer_LightingCap_ArrayIndex11.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex10.x * WKVRCOptimizer_LightingCap_ArrayIndex9.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex8.x * WKVRCOptimizer_LightingCap_ArrayIndex7.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex6.x * WKVRCOptimizer_LightingCap_ArrayIndex5.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex4.x * WKVRCOptimizer_LightingCap_ArrayIndex3.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex2.x * WKVRCOptimizer_LightingCap_ArrayIndex1.x;
WKVRCOptimizer_val += WKVRCOptimizer_LightingCap_ArrayIndex0.x * _IsActiveMesh38;
WKVRCOptimizer_val += _IsActiveMesh37 * _IsActiveMesh36;
WKVRCOptimizer_val += _IsActiveMesh35 * _IsActiveMesh34;
WKVRCOptimizer_val += _IsActiveMesh33 * _IsActiveMesh32;
WKVRCOptimizer_val += _IsActiveMesh31 * _IsActiveMesh30;
WKVRCOptimizer_val += _IsActiveMesh29 * _IsActiveMesh28;
WKVRCOptimizer_val += _IsActiveMesh27 * _IsActiveMesh26;
WKVRCOptimizer_val += _IsActiveMesh25 * _IsActiveMesh24;
WKVRCOptimizer_val += _IsActiveMesh23 * _IsActiveMesh22;
WKVRCOptimizer_val += _IsActiveMesh21 * _IsActiveMesh20;
WKVRCOptimizer_val += _IsActiveMesh19 * _IsActiveMesh18;
WKVRCOptimizer_val += _IsActiveMesh17 * _IsActiveMesh16;
WKVRCOptimizer_val += _IsActiveMesh15 * _IsActiveMesh14;
WKVRCOptimizer_val += _IsActiveMesh13 * _IsActiveMesh12;
WKVRCOptimizer_val += _IsActiveMesh11 * _IsActiveMesh10;
WKVRCOptimizer_val += _IsActiveMesh9 * _IsActiveMesh8;
WKVRCOptimizer_val += _IsActiveMesh7 * _IsActiveMesh6;
WKVRCOptimizer_val += _IsActiveMesh5 * _IsActiveMesh4;
WKVRCOptimizer_val += _IsActiveMesh3 * _IsActiveMesh2;
WKVRCOptimizer_val += _IsActiveMesh1 * _IsActiveMesh0;
WKVRCOptimizer_val += WKVRCOptimizerAnimatedVectors[WKVRCOptimizer_MeshID].x * WKVRCOptimizerAnimatedScalars[WKVRCOptimizer_MeshID];
if (WKVRCOptimizer_val) return (float4)0;
}
shader_is_using_thry_editor = WKVRCOptimizer_MaterialID == 32 ? 69 : 0;
_Mode = WKVRCOptimizerArray_Mode[WKVRCOptimizer_MaterialID];
m_mainCategory = WKVRCOptimizer_MaterialID == 5 ? 0 : 1;
_Color = WKVRCOptimizerArray_Color[WKVRCOptimizer_MaterialID];
shouldSample_MainTex = WKVRCOptimizerArrayshouldSample_MainTex[WKVRCOptimizer_MaterialID];
_MainTex_TexelSize = WKVRCOptimizerArray_MainTex_TexelSize[WKVRCOptimizer_MaterialID];
shouldSample_BumpMap = WKVRCOptimizerArrayshouldSample_BumpMap[WKVRCOptimizer_MaterialID];
_BumpMap_TexelSize = WKVRCOptimizerArray_BumpMap_TexelSize[WKVRCOptimizer_MaterialID];
_BumpMap_ST = WKVRCOptimizerArray_BumpMap_ST[WKVRCOptimizer_MaterialID];
_BumpScale = WKVRCOptimizerArray_BumpScale[WKVRCOptimizer_MaterialID];
shouldSample_AlphaMask = WKVRCOptimizerArrayshouldSample_AlphaMask[WKVRCOptimizer_MaterialID];
_AlphaMask_TexelSize = WKVRCOptimizerArray_AlphaMask_TexelSize[WKVRCOptimizer_MaterialID];
_AlphaMask_ST = WKVRCOptimizer_MaterialID == 31 ? float4(1, 0.6, 0, 0) : float4(1, 1, 0, 0);
_MainAlphaMaskMode = WKVRCOptimizerArray_MainAlphaMaskMode[WKVRCOptimizer_MaterialID];
_Cutoff = WKVRCOptimizerArray_Cutoff[WKVRCOptimizer_MaterialID];
_Saturation = WKVRCOptimizerArray_Saturation[WKVRCOptimizer_MaterialID];
_MainHueShiftToggle = ((1u << WKVRCOptimizer_MaterialID) & 1038106611) != 0 ? 0 : 1;
_AlphaForceOpaque = WKVRCOptimizerArray_AlphaForceOpaque[WKVRCOptimizer_MaterialID];
m_start_DecalSection = WKVRCOptimizer_MaterialID == 3 ? 0 : 1;
shouldSample_DecalMask = WKVRCOptimizer_MaterialID == 2 ? true : false;
_DecalMask_TexelSize = WKVRCOptimizer_MaterialID == 2 ? float4(1.0 / 2048, 1.0 / 2048, 2048, 2048) : float4(1.0 / 4, 1.0 / 4, 4, 4);
_DecalColor = WKVRCOptimizerArray_DecalColor[WKVRCOptimizer_MaterialID];
shouldSample_DecalTexture = ((1u << WKVRCOptimizer_MaterialID) & 61390) != 0 ? true : false;
_DecalTexture_TexelSize = ((1u << WKVRCOptimizer_MaterialID) & 61390) != 0 ? float4(1.0 / 1024, 1.0 / 1024, 1024, 1024) : float4(1.0 / 4, 1.0 / 4, 4, 4);
m_start_PoiShading = WKVRCOptimizerArraym_start_PoiShading[WKVRCOptimizer_MaterialID];
s_start_ShadingAddPass = WKVRCOptimizer_MaterialID == 32 ? 1 : 0;
m_start_matcap = ((1u << WKVRCOptimizer_MaterialID) & 1073627135) != 0 ? 1 : 0;
_MatcapMultiply = WKVRCOptimizer_MaterialID == 6 ? 0.18 : 0.406;
shouldSample_Matcap0NormalMap = WKVRCOptimizer_MaterialID == 5 ? true : false;
_Matcap0NormalMap_TexelSize = WKVRCOptimizer_MaterialID == 5 ? float4(1.0 / 1024, 1.0 / 1024, 1024, 1024) : float4(1.0 / 4, 1.0 / 4, 4, 4);
_CubeMapColor = WKVRCOptimizerArray_CubeMapColor[WKVRCOptimizer_MaterialID];
_CubeMapBlendAmount = WKVRCOptimizer_MaterialID == 10 ? 0.155 : 1;
shouldSample_CubeMapMask = WKVRCOptimizer_MaterialID == 2 ? false : true;
_CubeMapMask_TexelSize = WKVRCOptimizer_MaterialID == 2 ? float4(1.0 / 4, 1.0 / 4, 4, 4) : float4(1.0 / 1024, 1.0 / 1024, 1024, 1024);
_CubeMapMaskInvert = ((1u << WKVRCOptimizer_MaterialID) & 3007) != 0 ? 0 : 1;
m_start_rimLight1Options = WKVRCOptimizer_MaterialID == 15 ? 0 : 1;
_RimBlendStrength = WKVRCOptimizer_MaterialID == 7 ? 0.149 : 0.226;
_RimSharpness = WKVRCOptimizer_MaterialID == 5 ? 0.799 : 0.25;
m_start_brdf = WKVRCOptimizer_MaterialID == 27 ? 0 : 1;
_MochieMetallicMultiplier = WKVRCOptimizer_MaterialID == 4 ? 1 : 0;
_MochieRoughnessMultiplier = WKVRCOptimizerArray_MochieRoughnessMultiplier[WKVRCOptimizer_MaterialID];
m_start_poiSSAO = WKVRCOptimizer_MaterialID == 5 ? 0 : 1;
m_specialFXCategory = WKVRCOptimizer_MaterialID == 5 ? 0 : 1;
m_vertexCategory = WKVRCOptimizerArraym_vertexCategory[WKVRCOptimizer_MaterialID];
m_start_PoiGlobalCategory = WKVRCOptimizer_MaterialID == 31 ? 1 : 0;
m_start_PoiPostProcessingCategory = WKVRCOptimizer_MaterialID == 32 ? 1 : 0;
m_start_PPAnimations = WKVRCOptimizer_MaterialID == 32 ? 1 : 0;
m_renderingCategory = WKVRCOptimizerArraym_renderingCategory[WKVRCOptimizer_MaterialID];
_Cull = WKVRCOptimizer_MaterialID == 5 ? 2 : 0;
_ZWrite = WKVRCOptimizerArray_ZWrite[WKVRCOptimizer_MaterialID];
_RenderingEarlyZEnabled = WKVRCOptimizerArray_RenderingEarlyZEnabled[WKVRCOptimizer_MaterialID];
_SrcBlend = WKVRCOptimizerArray_SrcBlend[WKVRCOptimizer_MaterialID];
_DstBlend = WKVRCOptimizerArray_DstBlend[WKVRCOptimizer_MaterialID];
_AddSrcBlend = WKVRCOptimizerArray_AddSrcBlend[WKVRCOptimizer_MaterialID];
_BlendOpAlpha = WKVRCOptimizerArray_BlendOpAlpha[WKVRCOptimizer_MaterialID];
_DstBlendAlpha = WKVRCOptimizerArray_DstBlendAlpha[WKVRCOptimizer_MaterialID];
_LightingCap = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[39 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _LightingCap : WKVRCOptimizerAnimatedScalars[39 + WKVRCOptimizer_MeshID];
_LightingAdditiveLimit = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[78 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _LightingAdditiveLimit : WKVRCOptimizerAnimatedScalars[78 + WKVRCOptimizer_MeshID];
_LightingMinLightBrightness = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[117 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _LightingMinLightBrightness : WKVRCOptimizerAnimatedScalars[117 + WKVRCOptimizer_MeshID];
_LightingMonochromatic = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[156 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _LightingMonochromatic : WKVRCOptimizerAnimatedScalars[156 + WKVRCOptimizer_MeshID];
_LightingAdditiveMonochromatic = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[195 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _LightingAdditiveMonochromatic : WKVRCOptimizerAnimatedScalars[195 + WKVRCOptimizer_MeshID];
_SSAOIntensity = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[234 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _SSAOIntensity : WKVRCOptimizerAnimatedScalars[234 + WKVRCOptimizer_MeshID];
_LightingEnableLightVolumes = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[273 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _LightingEnableLightVolumes : WKVRCOptimizerAnimatedScalars[273 + WKVRCOptimizer_MeshID];
_SSAOAnimationToggle = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[312 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _SSAOAnimationToggle : WKVRCOptimizerAnimatedScalars[312 + WKVRCOptimizer_MeshID];
_CubeMapColor = isnan(asfloat(asuint(WKVRCOptimizerAnimatedVectors[0 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _CubeMapColor : WKVRCOptimizerAnimatedVectors[0 + WKVRCOptimizer_MeshID];
_CubeMapHueShift = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[351 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _CubeMapHueShift : WKVRCOptimizerAnimatedScalars[351 + WKVRCOptimizer_MeshID];
_DecalBlendAlpha = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[390 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _DecalBlendAlpha : WKVRCOptimizerAnimatedScalars[390 + WKVRCOptimizer_MeshID];
_MainHueShift = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[429 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _MainHueShift : WKVRCOptimizerAnimatedScalars[429 + WKVRCOptimizer_MeshID];
_Saturation = isnan(asfloat(asuint(WKVRCOptimizerAnimatedScalars[468 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _Saturation : WKVRCOptimizerAnimatedScalars[468 + WKVRCOptimizer_MeshID];
_Color = isnan(asfloat(asuint(WKVRCOptimizerAnimatedVectors[39 + WKVRCOptimizer_MeshID].x) ^ asuint(WKVRCOptimizer_Zero))) ? _Color : WKVRCOptimizerAnimatedVectors[39 + WKVRCOptimizer_MeshID];
UNITY_SETUP_INSTANCE_ID(i);
UNITY_SETUP_STEREO_EYE_INDEX_POST_VERTEX(i);
PoiSHAr = unity_SHAr;
PoiSHAg = unity_SHAg;
PoiSHAb = unity_SHAb;
PoiSHBr = unity_SHBr;
PoiSHBg = unity_SHBg;
PoiSHBb = unity_SHBb;
PoiSHC =  unity_SHC;
PoiMesh poiMesh;
PoiInitStruct(PoiMesh, poiMesh);
PoiLight poiLight;
PoiInitStruct(PoiLight, poiLight);
PoiVertexLights poiVertexLights;
PoiInitStruct(PoiVertexLights, poiVertexLights);
PoiCam poiCam;
PoiInitStruct(PoiCam, poiCam);
PoiMods poiMods;
PoiInitStruct(PoiMods, poiMods);
poiMods.globalEmission = 1;
PoiFragData poiFragData;
poiFragData.smoothness = 1;
poiFragData.smoothness2 = 1;
poiFragData.metallic = 1;
poiFragData.specularMask = 1;
poiFragData.reflectionMask = 1;
poiFragData.emission = 0;
poiFragData.baseColor = float3(0, 0, 0);
poiFragData.finalColor = float3(0, 0, 0);
poiFragData.alpha = 1;
poiFragData.toggleVertexLights = 0;
#ifdef POI_UDIMDISCARD
applyUDIMDiscard(i, facing);
#endif
poiMesh.objectPosition = mul(unity_ObjectToWorld, float4(0, 0, 0, 1)).xyz;
poiMesh.objNormal = mul(unity_WorldToObject, i.normal);
poiMesh.normals[0] = i.normal;
poiMesh.tangent[0] = i.tangent.xyz;
poiMesh.binormal[0] = cross(i.normal, i.tangent.xyz) * (i.tangent.w * unity_WorldTransformParams.w);
poiMesh.worldPos = i.worldPos.xyz;
poiMesh.localPos = i.localPos.xyz;
poiMesh.vertexColor = i.vertexColor;
poiMesh.isFrontFace = facing;
poiMesh.dx = ddx(poiMesh.uv[0]);
poiMesh.dy = ddy(poiMesh.uv[0]);
poiMesh.isRightHand = i.tangent.w > 0.0;
#ifndef POI_PASS_OUTLINE
if (!poiMesh.isFrontFace && 1)
{
poiMesh.normals[0] *= -1;
poiMesh.tangent[0] *= -1;
poiMesh.binormal[0] *= -1;
}
#endif
poiCam.viewDir = !IsOrthographicCamera() ? normalize(_WorldSpaceCameraPos - i.worldPos.xyz) : normalize(UNITY_MATRIX_I_V._m02_m12_m22);
float3 tanToWorld0 = float3(poiMesh.tangent[0].x, poiMesh.binormal[0].x, poiMesh.normals[0].x);
float3 tanToWorld1 = float3(poiMesh.tangent[0].y, poiMesh.binormal[0].y, poiMesh.normals[0].y);
float3 tanToWorld2 = float3(poiMesh.tangent[0].z, poiMesh.binormal[0].z, poiMesh.normals[0].z);
float3 ase_tanViewDir = tanToWorld0 * poiCam.viewDir.x + tanToWorld1 * poiCam.viewDir.y + tanToWorld2 * poiCam.viewDir.z;
poiCam.tangentViewDir = normalize(ase_tanViewDir);
// Skipped 1 lines | #if defined(LIGHTMAP_ON) || defined(DYNAMICLIGHTMAP_ON)
poiMesh.parallaxUV = poiCam.tangentViewDir.xy / max(poiCam.tangentViewDir.z, 0.0001);
poiMesh.uv[0] = i.uv[0].xy;
poiMesh.uv[1] = i.uv[0].zw;
poiMesh.uv[2] = i.uv[1].xy;
poiMesh.uv[3] = i.uv[1].zw;
poiMesh.uv[4] = poiMesh.uv[0];
poiMesh.uv[5] = poiMesh.uv[0];
poiMesh.uv[6] = poiMesh.uv[0];
poiMesh.uv[7] = poiMesh.uv[0];
poiMesh.uv[8] = poiMesh.uv[0];
poiMesh.uv[4] = calculatePanosphereUV(poiMesh);
poiMesh.uv[5] = calculateWorldUV(poiMesh);
poiMesh.uv[6] = calculatePolarCoordinate(poiMesh);
poiMesh.uv[8] = calculatelocalUV(poiMesh);
float3 worldViewUp = normalize(float3(0, 1, 0) - poiCam.viewDir * dot(poiCam.viewDir, float3(0, 1, 0)));
float3 worldViewRight = normalize(cross(poiCam.viewDir, worldViewUp));
poiMesh.uv[9] = float2(dot(worldViewRight, poiMesh.normals[0]), dot(worldViewUp, poiMesh.normals[0])) * 0.5 + 0.5;
poiMods.globalMask[0] = 1;
poiMods.globalMask[1] = 1;
poiMods.globalMask[2] = 1;
poiMods.globalMask[3] = 1;
poiMods.globalMask[4] = 1;
poiMods.globalMask[5] = 1;
poiMods.globalMask[6] = 1;
poiMods.globalMask[7] = 1;
poiMods.globalMask[8] = 1;
poiMods.globalMask[9] = 1;
poiMods.globalMask[10] = 1;
poiMods.globalMask[11] = 1;
poiMods.globalMask[12] = 1;
poiMods.globalMask[13] = 1;
poiMods.globalMask[14] = 1;
poiMods.globalMask[15] = 1;
ApplyGlobalMaskModifiers(poiMesh, poiMods, poiCam);
float2 mainUV = poiUV(poiMesh.uv[0.0].xy, float4(1,1,0,0));
if (0.0)
{
mainUV = sharpSample(float4(0.0009765625,0.0009765625,1024,1024), mainUV);
}
float4 mainTexture = POI2D_SAMPLER_PAN_STOCHASTIC(_MainTex, _MainTex, mainUV, float4(0,0,0,0), 0.0);
mainTexture.a = max(mainTexture.a, 0.0);
poiMesh.tangentSpaceNormal = UnpackScaleNormal(POI2D_SAMPLER_PAN_STOCHASTIC(_BumpMap, _MainTex, poiUV(poiMesh.uv[0.0].xy, float4(20,20,0,0)), float4(0,0,0,0), 0.0), 1.8);
// Skipped 1 lines
float3 tangentSpaceNormal = UnpackNormal(float4(0.5, 0.5, 1, 1));
poiMesh.normals[0] = normalize( tangentSpaceNormal.x * poiMesh.tangent[0] + tangentSpaceNormal.y * poiMesh.binormal[0] + tangentSpaceNormal.z * poiMesh.normals[0]
);
poiMesh.normals[1] = normalize( poiMesh.tangentSpaceNormal.x * poiMesh.tangent[0] + poiMesh.tangentSpaceNormal.y * poiMesh.binormal[0] + poiMesh.tangentSpaceNormal.z * poiMesh.normals[0]
);
poiMesh.tangent[1] = cross(poiMesh.binormal[0], -poiMesh.normals[1]);
poiMesh.binormal[1] = cross(-poiMesh.normals[1], poiMesh.tangent[0]);
poiCam.forwardDir = getCameraForward();
poiCam.worldPos = _WorldSpaceCameraPos;
poiCam.reflectionDir = reflect(-poiCam.viewDir, poiMesh.normals[1]);
poiCam.vertexReflectionDir = reflect(-poiCam.viewDir, poiMesh.normals[0]);
poiCam.clipPos = i.pos;
poiCam.distanceToVert = distance(poiMesh.worldPos, poiCam.worldPos);
poiCam.posScreenSpace = poiTransformClipSpacetoScreenSpaceFrag(poiCam.clipPos);
#if defined(POI_GRABPASS) && defined(POI_PASS_BASE)
poiCam.screenUV = poiCam.clipPos.xy / poiGetWidthAndHeight(_PoiGrab2);
#else
poiCam.screenUV = poiCam.clipPos.xy / _ScreenParams.xy;
#endif
#ifdef UNITY_SINGLE_PASS_STEREO
poiCam.posScreenSpace.x = poiCam.posScreenSpace.x * 0.5;
#endif
poiCam.posScreenPixels = calcPixelScreenUVs(poiCam.posScreenSpace);
poiCam.vDotN = abs(dot(poiCam.viewDir, poiMesh.normals[1]));
poiCam.worldDirection.xyz = poiMesh.worldPos.xyz - poiCam.worldPos;
poiCam.worldDirection.w = i.worldDir;
calculateGlobalThemes(poiMods);
if (_UdonForceSceneLighting)
{
_LightingMinLightBrightness = 0;
_LightingCapEnabled = 0;
_LightingMonochromatic = 0;
}
poiLight.finalLightAdd = 0;
float3 L0 = float3(0, 0, 0);
float3 L1r = float3(0, 0, 0);
float3 L1g = float3(0, 0, 0);
float3 L1b = float3(0, 0, 0);
if (_UdonLightVolumeEnabled && _LightingEnableLightVolumes)
{
LightVolumeSH(poiMesh.worldPos, L0, L1r, L1g, L1b);
PoiSHAr = float4(L1r, L0.r);
PoiSHAg = float4(L1g, L0.g);
PoiSHAb = float4(L1b, L0.b);
PoiSHBr = 0;
PoiSHBg = 0;
PoiSHBb = 0;
PoiSHC = 0;
}
#if defined(PROP_LIGHTINGAOMAPS)
float4 AOMaps = POI2D_SAMPLER_PAN(_LightingAOMaps, _MainTex, poiUV(poiMesh.uv[0.0], float4(1,1,0,0)), float4(0,0,0,0));
poiLight.occlusion = min(min(min(lerp(1, AOMaps.r, 1.0), lerp(1, AOMaps.g, 0.0)), lerp(1, AOMaps.b, 0.0)), lerp(1, AOMaps.a, 0.0));
#else
poiLight.occlusion = 1;
#endif
if (0.0 > 0)
{
poiLight.occlusion = maskBlend(poiLight.occlusion, poiMods.globalMask[0.0 - 1], 2.0);
}
#if defined(PROP_LIGHTINGDETAILSHADOWMAPS)
float4 DetailShadows = POI2D_SAMPLER_PAN(_LightingDetailShadowMaps, _MainTex, poiUV(poiMesh.uv[0.0], float4(1,1,0,0)), float4(0,0,0,0));
#ifndef POI_PASS_ADD
poiLight.detailShadow = lerp(1, DetailShadows.r, 1.0) * lerp(1, DetailShadows.g, 0.0) * lerp(1, DetailShadows.b, 0.0) * lerp(1, DetailShadows.a, 0.0);
#else
poiLight.detailShadow = lerp(1, DetailShadows.r, 1.0) * lerp(1, DetailShadows.g, 0.0) * lerp(1, DetailShadows.b, 0.0) * lerp(1, DetailShadows.a, 0.0);
#endif
#else
poiLight.detailShadow = 1;
#endif
if (0.0 > 0)
{
poiLight.detailShadow = maskBlend(poiLight.detailShadow, poiMods.globalMask[0.0 - 1], 2.0);
}
#if defined(PROP_LIGHTINGSHADOWMASKS)
float4 ShadowMasks = POI2D_SAMPLER_PAN(_LightingShadowMasks, _MainTex, poiUV(poiMesh.uv[0.0], float4(1,1,0,0)), float4(0,0,0,0));
poiLight.shadowMask = lerp(1, ShadowMasks.r, 1.0) * lerp(1, ShadowMasks.g, 0.0) * lerp(1, ShadowMasks.b, 0.0) * lerp(1, ShadowMasks.a, 0.0);
#else
poiLight.shadowMask = 1;
#endif
if (0.0 > 0)
{
poiLight.shadowMask = maskBlend(poiLight.shadowMask, poiMods.globalMask[0.0 - 1], 2.0);
}
bool lightExists = false;
if (any(_LightColor0.rgb >= 0.002))
{
lightExists = true;
}
if (1.0)
{
poiFragData.toggleVertexLights = 1;
}
if (IsInMirror() && 1.0 == 0)
{
poiFragData.toggleVertexLights = 0;
}
if (1.0)
{
#if defined(VERTEXLIGHT_ON)
float4 toLightX = unity_4LightPosX0 - i.worldPos.x;
float4 toLightY = unity_4LightPosY0 - i.worldPos.y;
float4 toLightZ = unity_4LightPosZ0 - i.worldPos.z;
float4 lengthSq = 0;
lengthSq += toLightX * toLightX;
lengthSq += toLightY * toLightY;
lengthSq += toLightZ * toLightZ;
float4 lightAttenSq = unity_4LightAtten0;
float4 atten = 1.0 / (1.0 + lengthSq * lightAttenSq);
float4 vLightWeight = saturate(1 - (lengthSq * lightAttenSq / 25));
poiLight.vAttenuation = min(atten, vLightWeight * vLightWeight);
poiLight.vDotNL = 0;
poiLight.vDotNL += toLightX * poiMesh.normals[1].x;
poiLight.vDotNL += toLightY * poiMesh.normals[1].y;
poiLight.vDotNL += toLightZ * poiMesh.normals[1].z;
float4 corr = rsqrt(lengthSq);
poiLight.vertexVDotNL = max(0, poiLight.vDotNL * corr);
poiLight.vertexVDotNL = 0;
poiLight.vertexVDotNL += toLightX * poiMesh.normals[0].x;
poiLight.vertexVDotNL += toLightY * poiMesh.normals[0].y;
poiLight.vertexVDotNL += toLightZ * poiMesh.normals[0].z;
poiLight.vertexVDotNL = max(0, poiLight.vDotNL * corr);
poiLight.vSaturatedDotNL = saturate(poiLight.vDotNL);
[unroll]
for (int index = 0;
index < 4;
index++)
{
poiLight.vPosition[index] = float3(unity_4LightPosX0[index], unity_4LightPosY0[index], unity_4LightPosZ0[index]);
float3 vertexToLightSource = poiLight.vPosition[index] - poiMesh.worldPos;
poiLight.vDirection[index] = normalize(vertexToLightSource);
poiLight.vColor[index] = 1.0 ? MaxLuminance(unity_LightColor[index].rgb * poiLight.vAttenuation[index], _LightingAdditiveLimit) : unity_LightColor[index].rgb * poiLight.vAttenuation[index];
poiLight.vColor[index] = lerp(poiLight.vColor[index], dot(poiLight.vColor[index], float3(0.299, 0.587, 0.114)), _LightingAdditiveMonochromatic);
poiLight.vHalfDir[index] = Unity_SafeNormalize(poiLight.vDirection[index] + poiCam.viewDir);
poiLight.vDotNL[index] = dot(poiMesh.normals[1], poiLight.vDirection[index]);
poiLight.vCorrectedDotNL[index] = .5 * (poiLight.vDotNL[index] + 1);
poiLight.vDotLH[index] = saturate(dot(poiLight.vDirection[index], poiLight.vHalfDir[index]));
poiLight.vDotNH[index] = dot(poiMesh.normals[1], poiLight.vHalfDir[index]);
poiLight.vertexVDotNH[index] = saturate(dot(poiMesh.normals[0], poiLight.vHalfDir[index]));
}
#endif
}
if (0.0 == 0)
{
float3 magic = max(BetterSH9(normalize(PoiSHAr + PoiSHAg + PoiSHAb)), 0);
float3 normalLight = _LightColor0.rgb + BetterSH9(float4(0, 0, 0, 1));
float magiLumi = calculateluminance(magic);
float normaLumi = calculateluminance(normalLight);
float maginormalumi = magiLumi + normaLumi;
float magiratio = magiLumi / maginormalumi;
float normaRatio = normaLumi / maginormalumi;
float target = calculateluminance(magic * magiratio + normalLight * normaRatio);
float3 properLightColor = magic + normalLight;
float properLuminance = calculateluminance(magic + normalLight);
poiLight.directColor = properLightColor * max(0.0001, (target / properLuminance));
poiLight.indirectColor = BetterSH9(float4(lerp(0, poiMesh.normals[1], 0.0), 1));
}
if (0.0 == 1)
{
float3 indirectColor = BetterSH9(float4(poiMesh.normals[1], 1));
if (lightExists)
{
poiLight.directColor = _LightColor0.rgb;
poiLight.indirectColor = indirectColor;
}
else
{
poiLight.directColor = indirectColor * 0.6;
poiLight.indirectColor = indirectColor * 0.5;
}
}
if (0.0 == 2)
{
poiLight.indirectColor = saturate(max(half3(0.05, 0.05, 0.05) * 1.0, max(PoiShadeSH9(half4(0.0, 0.0, 0.0, 1.0)), PoiShadeSH9(half4(0.0, -1.0, 0.0, 1.0)).rgb) * 1.0));
poiLight.directColor = max(poiLight.indirectColor, _LightColor0.rgb);
}
if (0.0 == 3)
{
float3 lightDirectionForSH9 = OpenLitLightingDirectionForSH9();
OpenLitShadeSH9ToonDouble(lightDirectionForSH9, poiLight.directColor, poiLight.indirectColor);
poiLight.directColor += _LightColor0.rgb;
}
float lightMapMode = 0.0;
if (0.0 == 0)
{
poiLight.direction = calculateluminance(_LightColor0.rgb) * _WorldSpaceLightPos0.xyz + (PoiSHAr.xyz + PoiSHAg.xyz + PoiSHAb.xyz) / 3.0;
}
if (0.0 == 1 || 0.0 == 2)
{
if (0.0 == 1)
{
poiLight.direction = mul(unity_ObjectToWorld, float4(0,0,0,1)).xyz;
;
}
if (0.0 == 2)
{
poiLight.direction = float4(0,0,0,1);
}
if (lightMapMode == 0)
{
lightMapMode = 1;
}
}
if (0.0 == 3)
{
float3 defaultLightDirection = normalize(UNITY_MATRIX_V[2].xyz + UNITY_MATRIX_V[1].xyz);
float3 lightDirection = normalize(lerp(defaultLightDirection, _WorldSpaceLightPos0.xyz, any(_WorldSpaceLightPos0.xyz)));
poiLight.direction = lightDirection;
}
if (0.0 == 4)
{
poiLight.direction = OpenLitLightingDirection();
}
if (0.0 == 5)
{
float3 upViewDir = normalize(UNITY_MATRIX_V[1].xyz);
float3 rightViewDir = normalize(UNITY_MATRIX_V[0].xyz);
float yawOffset_Rads = radians(!IsInMirror() ? - 0.0 : 0.0);
float3 rotatedViewYaw = normalize(RotateAroundAxis(rightViewDir, upViewDir, yawOffset_Rads));
float3 rotatedViewCameraMeshOffset = RotateAroundAxis((getCameraPosition() - (poiMesh.worldPos)), upViewDir, yawOffset_Rads);
float pitchOffset_Rads = radians(!IsInMirror() ? 0.0 : - 0.0);
float3 rotatedViewPitch = RotateAroundAxis(rotatedViewCameraMeshOffset, rotatedViewYaw, pitchOffset_Rads);
poiLight.direction = normalize(rotatedViewPitch);
}
if (!any(poiLight.direction))
{
poiLight.direction = float3(.4, 1, .4);
}
poiLight.direction = normalize(poiLight.direction);
poiLight.attenuationStrength = 0.0;
poiLight.attenuation = 1;
if (!all(_LightColor0.rgb == 0.0))
{
UNITY_LIGHT_ATTENUATION(attenuation, i, poiMesh.worldPos) poiLight.attenuation *= attenuation;
}
#if defined(HANDLE_SHADOWS_BLENDING_IN_GI)
half bakedAtten = UnitySampleBakedOcclusion(poiMesh.lightmapUV.xy, poiMesh.worldPos);
float zDist = dot(_WorldSpaceCameraPos - poiMesh.worldPos, UNITY_MATRIX_V[2].xyz);
float fadeDist = UnityComputeShadowFadeDistance(poiMesh.worldPos, zDist);
poiLight.attenuation = UnityMixRealtimeAndBakedShadows(poiLight.attenuation, bakedAtten, UnityComputeShadowFade(fadeDist));
#endif
#ifdef RALIV_PENETRATION
if (0.0 || 0.0)
{
if (1.0)
{
poiLight.attenuation = 1;
}
}
#endif
if (!any(poiLight.directColor) && !any(poiLight.indirectColor) && lightMapMode == 0)
{
lightMapMode = 1;
if (0.0 == 0)
{
poiLight.direction = normalize(float3(.4, 1, .4));
}
}
poiLight.halfDir = normalize(poiLight.direction + poiCam.viewDir);
poiLight.vertexNDotL = dot(poiMesh.normals[0], poiLight.direction);
poiLight.nDotL = dot(poiMesh.normals[1], poiLight.direction);
poiLight.nDotLSaturated = saturate(poiLight.nDotL);
poiLight.nDotLNormalized = (poiLight.nDotL + 1) * 0.5;
poiLight.nDotV = abs(dot(poiMesh.normals[1], poiCam.viewDir));
poiLight.nDotVCentered = abs(dot(poiMesh.normals[1], normalize(getCameraPosition() - i.worldPos.xyz)));
poiLight.vertexNDotV = abs(dot(poiMesh.normals[0], poiCam.viewDir));
poiLight.nDotH = dot(poiMesh.normals[1], poiLight.halfDir);
poiLight.vertexNDotH = max(0.00001, dot(poiMesh.normals[0], poiLight.halfDir));
poiLight.lDotv = dot(poiLight.direction, poiCam.viewDir);
poiLight.lDotH = max(0.00001, dot(poiLight.direction, poiLight.halfDir));
if (lightMapMode == 0)
{
float3 ShadeSH9Plus = GetSHLength();
float3 ShadeSH9Minus = float3(PoiSHAr.w, PoiSHAg.w, PoiSHAb.w) + float3(PoiSHBr.z, PoiSHBg.z, PoiSHBb.z) / 3.0;
float3 greyScaleVector = float3(.33333, .33333, .33333);
float bw_lightColor = dot(poiLight.directColor, greyScaleVector);
float bw_directLighting = (((poiLight.nDotL * 0.5 + 0.5) * bw_lightColor * lerp(1, poiLight.attenuation, poiLight.attenuationStrength)) + dot(PoiShadeSH9(float4(poiMesh.normals[1], 1)), greyScaleVector));
float bw_directLightingNoAtten = (((poiLight.nDotL * 0.5 + 0.5) * bw_lightColor) + dot(PoiShadeSH9(float4(poiMesh.normals[1], 1)), greyScaleVector));
float bw_bottomIndirectLighting = dot(ShadeSH9Minus, greyScaleVector);
float bw_topIndirectLighting = dot(ShadeSH9Plus, greyScaleVector);
float lightDifference = ((bw_topIndirectLighting + bw_lightColor) - bw_bottomIndirectLighting);
poiLight.lightMap = smoothstep(0, lightDifference, bw_directLighting - bw_bottomIndirectLighting);
poiLight.lightMapNoAttenuation = smoothstep(0, lightDifference, bw_directLightingNoAtten - bw_bottomIndirectLighting);
}
if (lightMapMode == 1)
{
poiLight.lightMapNoAttenuation = poiLight.nDotLNormalized;
poiLight.lightMap = poiLight.nDotLNormalized * lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
}
if (lightMapMode == 2)
{
poiLight.lightMapNoAttenuation = poiLight.nDotLSaturated;
poiLight.lightMap = poiLight.nDotLSaturated * lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
}
if (lightMapMode == 3)
{
poiLight.lightMapNoAttenuation = 1;
poiLight.lightMap = lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
}
if (lightMapMode == 4)
{
#if defined(PROP_LIGHTDATASDFMAP)
float2 lightDataSDFMap = 1;
if (0.0 > 0)
{
float sdfLod = pow(0.0, 4.0);
lightDataSDFMap = POI2D_SAMPLER_PANGRAD(_LightDataSDFMap, _linear_repeat, poiUV(poiMesh.uv[0.0], float4(1,1,0,0)), float4(0,0,0,0), max(poiMesh.dx, sdfLod), max(poiMesh.dy, sdfLod)).rg;
}
else
{
lightDataSDFMap = POI2D_SAMPLER_PAN(_LightDataSDFMap, _linear_repeat, poiUV(poiMesh.uv[0.0], float4(1,1,0,0)), float4(0,0,0,0)).rg;
}
poiLight.lightMapNoAttenuation = poiLight.nDotLSaturated;
float3 faceR = mul((float3x3)unity_ObjectToWorld, float3(-1.0, 0.0, 0.0));
float LdotR = dot(poiLight.direction.xz, faceR.xz);
float sdf = LdotR < 0 ? lightDataSDFMap.g : lightDataSDFMap.r;
float3 faceF = mul((float3x3)unity_ObjectToWorld, float3(0.0, 0.0, 1.0)).xyz;
faceF.y *= 1.0;
faceF = dot(faceF, faceF) == 0 ? 0 : normalize(faceF);
float3 faceL = poiLight.direction;
faceL.y *= 1.0;
faceL = dot(faceL, faceL) == 0 ? 0 : normalize(faceL);
float lnSDF = dot(faceL, faceF);
poiLight.lightMapNoAttenuation = saturate(lnSDF * 0.5 + sdf * 0.5 + 0.25);
poiLight.lightMap = saturate(lnSDF * 0.5 + sdf * 0.5 + 0.25) * lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
#else
poiLight.lightMapNoAttenuation = poiLight.nDotLNormalized;
poiLight.lightMap = poiLight.nDotLNormalized * lerp(1, poiLight.attenuation, poiLight.attenuationStrength);
#endif
}
poiLight.lightMapNoAttenuation *= poiLight.detailShadow;
poiLight.lightMap *= poiLight.detailShadow;
poiLight.directColor = max(poiLight.directColor, 0.0001);
poiLight.indirectColor = max(poiLight.indirectColor, 0.0001);
if (0.0 == 3)
{
poiLight.directColor = max(poiLight.directColor, _LightingMinLightBrightness);
}
else
{
poiLight.directColor = max(poiLight.directColor, poiLight.directColor * min(10000, (_LightingMinLightBrightness * rcp(calculateluminance(poiLight.directColor)))));
poiLight.indirectColor = max(poiLight.indirectColor, poiLight.indirectColor * min(10000, (_LightingMinLightBrightness * rcp(calculateluminance(poiLight.indirectColor)))));
}
poiLight.directColor = lerp(poiLight.directColor, dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), _LightingMonochromatic);
poiLight.indirectColor = lerp(poiLight.indirectColor, dot(poiLight.indirectColor, float3(0.299, 0.587, 0.114)), _LightingMonochromatic);
if (_LightingCapEnabled)
{
poiLight.directColor = min(poiLight.directColor, _LightingCap);
poiLight.indirectColor = min(poiLight.indirectColor, _LightingCap);
}
if (0.0)
{
poiLight.directColor = poiThemeColor(poiMods, float4(1,1,1,1), 0.0);
}
poiLight.directColor = max(poiLight.directColor * 1.0, 0);
poiLight.directColor = max(poiLight.directColor + 0.0, 0);
poiLight.indirectColor = max(poiLight.indirectColor * 1.0, 0);
poiLight.indirectColor = max(poiLight.indirectColor + 0.0, 0);
#ifdef POI_PASS_ADD
if (!1.0)
{
return float4(mainTexture.rgb * .0001, 1);
}
#if defined(DIRECTIONAL)
if (1.0)
{
return float4(mainTexture.rgb * .0001, 1);
}
#endif
poiLight.direction = normalize(_WorldSpaceLightPos0.xyz - i.worldPos.xyz * _WorldSpaceLightPos0.w);
#if defined(POINT) || defined(SPOT)
#ifdef POINT
unityShadowCoord3 lightCoord = mul(unity_WorldToLight, unityShadowCoord4(poiMesh.worldPos, 1)).xyz;
poiLight.attenuation = tex2D(_LightTexture0, dot(lightCoord, lightCoord).rr).r;
#endif
#ifdef SPOT
unityShadowCoord4 lightCoord = mul(unity_WorldToLight, unityShadowCoord4(poiMesh.worldPos, 1));
poiLight.attenuation = (lightCoord.z > 0) * UnitySpotCookie(lightCoord) * UnitySpotAttenuate(lightCoord.xyz);
#endif
#else
UNITY_LIGHT_ATTENUATION(attenuation, i, poiMesh.worldPos) poiLight.attenuation = attenuation;
#endif
poiLight.additiveShadow = UNITY_SHADOW_ATTENUATION(i, poiMesh.worldPos);
poiLight.attenuationStrength = 1.0;
poiLight.directColor = 1.0 ? MaxLuminance(_LightColor0.rgb * poiLight.attenuation, _LightingAdditiveLimit) : _LightColor0.rgb * poiLight.attenuation;
#if defined(POINT_COOKIE) || defined(DIRECTIONAL_COOKIE)
poiLight.indirectColor = 0;
#else
poiLight.indirectColor = lerp(0, poiLight.directColor, _LightingAdditivePassthrough);
poiLight.indirectColor = 1.0 ? MaxLuminance(poiLight.indirectColor, _LightingAdditiveLimit) : poiLight.indirectColor;
#endif
poiLight.directColor = lerp(poiLight.directColor, dot(poiLight.directColor, float3(0.299, 0.587, 0.114)), _LightingAdditiveMonochromatic);
poiLight.indirectColor = lerp(poiLight.indirectColor, dot(poiLight.indirectColor, float3(0.299, 0.587, 0.114)), _LightingAdditiveMonochromatic);
poiLight.halfDir = normalize(poiLight.direction + poiCam.viewDir);
poiLight.nDotL = dot(poiMesh.normals[1], poiLight.direction);
poiLight.nDotLSaturated = saturate(poiLight.nDotL);
poiLight.nDotLNormalized = (poiLight.nDotL + 1) * 0.5;
poiLight.nDotV = abs(dot(poiMesh.normals[1], poiCam.viewDir));
poiLight.nDotH = dot(poiMesh.normals[1], poiLight.halfDir);
poiLight.lDotv = dot(poiLight.direction, poiCam.viewDir);
poiLight.lDotH = dot(poiLight.direction, poiLight.halfDir);
poiLight.vertexNDotL = dot(poiMesh.normals[0], poiLight.direction);
poiLight.vertexNDotV = abs(dot(poiMesh.normals[0], poiCam.viewDir));
poiLight.vertexNDotH = max(0.00001, dot(poiMesh.normals[0], poiLight.halfDir));
if (0.0 == 0 || 0.0 == 1 || 0.0 == 2)
{
poiLight.lightMap = poiLight.nDotLNormalized;
}
if (0.0 == 3)
{
poiLight.lightMap = 1;
}
poiLight.lightMap *= poiLight.detailShadow;
poiLight.lightMapNoAttenuation = poiLight.lightMap;
poiLight.lightMap *= lerp(1, poiLight.additiveShadow, poiLight.attenuationStrength);
#endif
float ssao = calculateSSAO(poiMesh, poiCam, poiLight, poiMods);
MetallicAndSpecularFragDataInit(poiFragData, poiMesh, poiMods);
poiFragData.baseColor = mainTexture.rgb;
#if !defined(POI_PASS_BASETWO) && !defined(POI_PASS_ADDTWO)
poiFragData.baseColor *= poiThemeColor(poiMods, float4(1,1,1,1).rgb, 0.0);
poiFragData.alpha = mainTexture.a * float4(1,1,1,1).a;
#else
poiFragData.baseColor *= poiThemeColor(poiMods, _TwoPassColor.rgb, _TwoPassColorThemeIndex);
poiFragData.alpha = mainTexture.a * _TwoPassColor.a;
#endif
// Skipped 1 lines | #if defined(PROP_MAINCOLORADJUSTTEXTURE) || !defined(OPTIMIZER_ENABLED)
float4 hueShiftAlpha = 1;
if (0.0 > 0)
{
hueShiftAlpha.r = maskBlend(hueShiftAlpha.r, poiMods.globalMask[0.0 - 1], 2.0);
}
if (0.0 > 0)
{
hueShiftAlpha.b = maskBlend(hueShiftAlpha.b, poiMods.globalMask[0.0 - 1], 2.0);
}
if (0.0 > 0)
{
hueShiftAlpha.g = maskBlend(hueShiftAlpha.g, poiMods.globalMask[0.0 - 1], 2.0);
}
if (0.0 > 0)
{
hueShiftAlpha.a = maskBlend(hueShiftAlpha.a, poiMods.globalMask[0.0 - 1], 2.0);
}
if (0.0 == 1)
{
float shift = _MainHueShift;
#ifdef POI_AUDIOLINK
if (poiMods.audioLinkAvailable && 0.0)
{
shift += AudioLinkGetChronoTime(0.0, 0.0) * 1.0;
}
#endif
if (1.0)
{
poiFragData.baseColor = lerp(poiFragData.baseColor, hueShift(poiFragData.baseColor, shift + _MainHueShiftSpeed * _Time.x, 0.0, 1.0), hueShiftAlpha.r);
}
else
{
poiFragData.baseColor = hueShift(poiFragData.baseColor, frac((shift - (1 - hueShiftAlpha.r) + _MainHueShiftSpeed * _Time.x)), 0.0, 1.0);
}
}
if (0.0 && 0.0)
{
float3 tempColor = OpenLitLinearToSRGB(poiFragData.baseColor);
// Skipped 1 lines
#if defined(PROP_MAINGRADATIONTEX)
tempColor.r = POI_SAMPLE_1D_X(_MainGradationTex, sampler_linear_clamp, tempColor.r).r;
tempColor.g = POI_SAMPLE_1D_X(_MainGradationTex, sampler_linear_clamp, tempColor.g).g;
tempColor.b = POI_SAMPLE_1D_X(_MainGradationTex, sampler_linear_clamp, tempColor.b).b;
#else
tempColor = float3(1, 1, 1);
#endif
tempColor = OpenLitSRGBToLinear(tempColor);
poiFragData.baseColor = lerp(poiFragData.baseColor, tempColor, 0.0);
}
poiFragData.baseColor = lerp(poiFragData.baseColor, pow(abs(poiFragData.baseColor), 1.0), hueShiftAlpha.a);
poiFragData.baseColor = lerp(poiFragData.baseColor, dot(poiFragData.baseColor, float3(0.3, 0.59, 0.11)), - (_Saturation) * hueShiftAlpha.b);
poiFragData.baseColor = saturate(lerp(poiFragData.baseColor, poiFragData.baseColor * (0.0 + 1), hueShiftAlpha.g));
if (2.0)
{
float alphaMask = POI2D_SAMPLER_PAN(_AlphaMask, _MainTex, poiUV(poiMesh.uv[0.0], float4(1,1,0,0)), float4(0,0,0,0).xy).r;
// Skipped 1 lines
alphaMask = saturate(alphaMask * 1.0 + (0.0 ? 0.0 * - 1 : 0.0));
if (0.0) alphaMask = 1 - alphaMask;
if (2.0 == 1) poiFragData.alpha = alphaMask;
if (2.0 == 2) poiFragData.alpha = poiFragData.alpha * alphaMask;
if (2.0 == 3) poiFragData.alpha = saturate(poiFragData.alpha + alphaMask);
if (2.0 == 4) poiFragData.alpha = saturate(poiFragData.alpha - alphaMask);
}
applyAlphaOptions(poiFragData, poiMesh, poiCam, poiMods);
#if defined(_LIGHTINGMODE_SHADEMAP) && defined(VIGNETTE_MASKED)
#ifndef POI_PASS_OUTLINE
#endif
#endif
#ifdef POI_PASS_OUTLINE
if (1.0)
{
calculateShading(poiLight, poiFragData, poiMesh, poiCam);
}
else
{
poiLight.finalLighting = 1;
}
#else
calculateShading(poiLight, poiFragData, poiMesh, poiCam);
#endif
// Skipped 2 lines
if (0.0 > 0)
{
applyToGlobalMask(poiMods, 0.0 - 1, 2.0, poiLight.rampedLightMap);
}
if (0.0 > 0)
{
applyToGlobalMask(poiMods, 0.0 - 1, 2.0, 1 - poiLight.rampedLightMap);
}
poiLight.directLuminance = dot(poiLight.directColor, float3(0.299, 0.587, 0.114));
poiLight.indirectLuminance = dot(poiLight.directColor, float3(0.299, 0.587, 0.114));
poiLight.finalLuminance = dot(poiLight.finalLighting, float3(0.299, 0.587, 0.114));
#ifdef POI_GRABPASS
poiLight.finalLighting = max(poiLight.finalLighting, 0.0001);
#endif
applyDecals(poiFragData, poiMesh, poiCam, poiMods, poiLight);
#if defined(POI_MATCAP0) || defined(COLOR_GRADING_HDR_3D) || defined(POI_MATCAP2) || defined(POI_MATCAP3)
applyMatcap(poiFragData, poiCam, poiMesh, poiLight, poiMods);
#endif
applyCubemap(poiFragData, poiCam, poiMesh, poiLight, poiMods);
// Skipped 3 lines | #if defined(PROP_RIMMASK) || !defined(OPTIMIZER_ENABLED)
float rimMask = 1;
float rimBias = 1;
if (0.0)
{
rimMask = 1 - rimMask;
}
// Skipped 1 lines | #if defined(PROP_RIMTEX) || !defined(OPTIMIZER_ENABLED)
float4 rimColor = 1;
half AudioLinkRimWidthBand = 0;
float2 AudioLinkRimWidthAdd = 0;
half AudioLinkRimEmissionBand = 0;
float2 AudioLinkRimEmissionAdd = 0;
half AudioLinkRimBrightnessBand = 0;
float2 AudioLinkRimBrightnessAdd = 0;
#ifdef POI_AUDIOLINK
AudioLinkRimWidthBand = 0.0;
AudioLinkRimWidthAdd = float4(0,0,0,0);
AudioLinkRimEmissionBand = 0.0;
AudioLinkRimEmissionAdd = float4(0,0,0,0);
AudioLinkRimBrightnessBand = 0.0;
AudioLinkRimBrightnessAdd = float4(0,0,0,0);
#endif
ApplyPoiyomiRimLighting(poiFragData, poiMesh, poiCam, poiLight, poiMods, 1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0, 0.226, rimMask, 0.0, 2.0, rimColor, float4(0,0,0,1), 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,  0.25, 0.0, 0.0, 1.0, float4(0,0,0,1), 0.0, 2.0, 0.0, 1.0, 2.0, AudioLinkRimWidthBand, AudioLinkRimWidthAdd, AudioLinkRimEmissionBand, AudioLinkRimEmissionAdd, AudioLinkRimBrightnessBand, AudioLinkRimBrightnessAdd, rimBias, 0.0, 0, 1.0);
applySSAO(ssao, poiMesh, poiFragData, poiMods, poiLight);
if (0.0)
{
poiFragData.baseColor *= saturate(poiFragData.alpha);
}
poiFragData.finalColor = poiFragData.baseColor;
poiFragData.finalColor = poiFragData.baseColor * poiLight.finalLighting;
MochieBRDF(poiFragData, poiCam, poiLight, poiMesh, poiMods);
if (1.0)
{
float3 position = 1.0 ? poiMesh.worldPos : poiMesh.objectPosition;
poiFragData.finalColor *= lerp(poiThemeColor(poiMods, float4(0,0,0,1).rgb, 0.0), poiThemeColor(poiMods, float4(1,1,1,1).rgb, 0.0), smoothstep(0.0, 0.15, distance(position, poiCam.worldPos)));
if (0.0)
{
poiFragData.finalColor = lerp(poiFragData.finalColor * float4(0,0,0,1).rgb, poiFragData.finalColor, saturate(poiMesh.isFrontFace));
}
}
#if !defined(POI_PASS_BASETWO) && !defined(POI_PASS_ADDTWO)
poiFragData.alpha = 0.0 ? 1 : poiFragData.alpha;
#else
poiFragData.alpha = _AlphaForceOpaque2 ? 1 : poiFragData.alpha;
#endif
poiFragData.finalColor += poiLight.finalLightAdd;
poiFragData.emission = max(poiFragData.emission * 1.0, 0);
poiFragData.finalColor = max(poiFragData.finalColor * 1.0, 0);
if (9.0 == POI_MODE_OPAQUE)
{
}
clip(poiFragData.alpha - 0.01);
if (9.0 == POI_MODE_CUTOUT && !0.0)
{
poiFragData.alpha = 1;
}
poiFragData.finalColor += poiFragData.emission * poiMods.globalEmission;
applyUnityFog(poiFragData.finalColor, i.fogData);
if (WKVRCOptimizer_Zero)
{
float WKVRCOptimizer_sum = 0;
#ifdef DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__MainTex
WKVRCOptimizer_sum += _MainTex.Load(0).x;
#endif
#ifdef DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__BumpMap
WKVRCOptimizer_sum += _BumpMap.Load(0).x;
#endif
#ifdef DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__AlphaMask
WKVRCOptimizer_sum += _AlphaMask.Load(0).x;
#endif
#ifdef DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__DecalMask
WKVRCOptimizer_sum += _DecalMask.Load(0).x;
#endif
#ifdef DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__DecalTexture
WKVRCOptimizer_sum += _DecalTexture.Load(0).x;
#endif
#ifdef DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__Matcap0NormalMap
WKVRCOptimizer_sum += _Matcap0NormalMap.Load(0).x;
#endif
#ifdef DUMMY_USE_TEXTURE_TO_PRESERVE_SAMPLER__CubeMapMask
WKVRCOptimizer_sum += _CubeMapMask.Load(0).x;
#endif
if (WKVRCOptimizer_sum) return (float4)0;
}
return float4(poiFragData.finalColor, poiFragData.alpha) + POI_SAFE_RGB0;
}
